<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js"></script>
<script src="/js/bootstrap.bundle.min.js"></script>
<script src="/js/highlight.pack.js"></script>
<script type="text/javascript" src="/js/include_html.js"></script>
<script type="text/javascript" src="/js/site.js"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Data Engineering</h1>

<!-- Distributed system BEGIN -->
<div class="card mb-4" id="subject">
  <div class="card-body">
    <h2 class="card-title">Distributed System</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#distributed-system-1">Distributed system</a></li>
      <li><a href="#distributed-system-2">Scalability</a></li>
      <li><a href="#distributed-system-3">Reliability</a></li>
      <li><a href="#distributed-system-4">Availability</a></li>
      <li><a href="#distributed-system-5">Quorum</a></li>
      <li><a href="#distributed-system-6">CAP theorem</a></li>
      <li><a href="#distributed-system-7">Consistency</a></li>
      <li><a href="#distributed-system-8">Isolation level</a></li>
      <li><a href="#distributed-system-9">Anomaly</a></li>
      <li><a href="#distributed-system-10">RPC</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="distributed-system-1">
  <div class="card-body">
    <h2 class="card-title">Distributed System</h2>

    <h3 class="card-title">Distributed system challenges</h3>
    <ul>
      <li>Network asynchrony: messages take long to deliver, deliver out of order, or not deliver at all.</li>
      <li>Partial failures: only some components fail.</li>
      <li>Concurrency: execution of multiple computations intervene each other.</li>
    </ul>

    <h3 class="card-title">Failure types</h3>
    <ul>
      <li>Fail-stop: a node halts and remains halted permanently. (Easiest scenario)</li>
      <li>Crash: a node halts, but silently.</li>
      <li>Omission: a node fails to respond to incoming requests.</li>
      <li>Byzantine: a node exhibits arbitrary behavior.</li>
    </ul>

    <h3 class="card-title">State</h3>
    <ul>
      <li>Stateless: maintains no state. Performs purely based on the inputs.</li>
      <li>Stateful: maintains and updates states. Results depend on this state.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-the-system-design-interview">Grokking the System Design Interview</a> | <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="distributed-system-2">
  <div class="card-body">
    <h2 class="card-title">Scalability</h2>
    <ul>
      <li>Capability to manage increased demand.</li>
      <li>Compute load patterns - Consistent growth, constantly fluctuating loads, cyclical loads, unpredictable bursts.</li>
      <li>Scale sets - Load balancer distributes requests across VMs. Uses health probe to determine availability of each VM by pinging it.</li>
      <li>Scaling up (vertical scaling) - Adds more resources to a single instance.</li>
      <li>Scaling out (horizontal scaling) - Addition more instances.</li>
    </ul>

    <h3 class="card-title">Strategies to achieve scalability and performance</h3>
    <ul>
      <li>Data partitioning - data partitions can be managed and accessed separately.</li>
      <li>Caching - store frequently used data for fast retrieval. Could be placed at database or application layer.</li>
      <li>Autoscaling - dynamically allocate resources to match performance requirements.</li>
      <li>Background jobs - tasks such as batch jobs, intensive processing tasks, and long-running processes should run as background jobs, decoupled from applicatio UI to minimize load.</li>
      <li>Messaging - requests can continue to flow-in without error if application can’t keep up.</li>
      <li>Scale units - define units for scaling.</li>
    </ul>

    <h3 class="card-title">Vertical partitioning</h3>
    <ul>
      <li>Divides tables into different servers based on features of data. (Split columns)</li>
      <li>Problem when data experiences additional growth.</li>
      <li>Queries must hit multiple servers and join operations are needed.</li>
    </ul>

    <h3 class="card-title">Horizontal partitioning (Sharding)</h3>
    <ul>
      <li>Puts different rows to different tables.</li>
      <li>Atomic operation is hard to achieve.</li>
      <li>It is cheaper to add more servers than growing the existing server as data increases.</li>
    </ul>

    <h4 class="card-title">Range partitioning</h4>
    <ul>
      <li>Split dataset based on specific attribute.</li>
      <li>May result in unbalanced servers.</li>
    </ul>

    <h4 class="card-title">Hash partitioning</h4>
    <ul>
      <li>Apply hash function to some attribute of data.</li>
      <li>Uniform allocation of data across servers.</li>
      <li>Adding new servers mean changing hash function and redistribution of data.</li>
    </ul>

    <h4 class="card-title">Consistent hashing</h4>
    <ul>
      <li>Only small number of keys move when servers are added or removed.</li>
      <li>Example (without virtual node): hash range is 1-100, number of nodes is 4.
        <ul>
          <li>All data in range 1-25 is stored in server 1.</li>
          <li>All data in range 26-50 is stored in server 2.</li>
          <li>All data in range 51-75 is stored in server 3.</li>
          <li>All data in range 76-100 is stored in server 4.</li>
        </ul>
      <li>Apply hash function (MD5) on the key of data to determine which node to place the data.</li>
      <li>Virtual node
        <ul>
          <li>Each node gets mutiple hash ranges and these hash ranges are randomly distributed across the nodes.</li>
          <li>Node carry replicating hash ranges for fault tolerance. (Some nodes may carry more V-nodes than others)</li>
          <li>Used in Dynamo and Cassandra.</li>
        </ul>
      </li>
      <li>Why virtual node
        <ul>
          <li>When a node is added, it receives many v-nodes from the existing nodes to maintain balanced cluster.</li>
          <li>When a node is removed, v-nodes are spread across many nodes.</li>
          <li>Random distributed of subranges decreases probability of hotspots.</li>
        </ul>
      </li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-the-system-design-interview">Grokking the System Design Interview</a> | <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="distributed-system-3">
  <div class="card-body">
    <h2 class="card-title">Reliability</h2>
    <ul>
      <li>Delivering services even when some components fail.</li>
      <li>Redunduncy of both software components and data.</li>
      <li>Recovery point objective - Maximum duration of acceptable data loss. For example, 30 minutes of data or four hours of data.</li>
      <li>Recovery time objective - Maximum duration of acceptable downtime.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-the-system-design-interview">Grokking the System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="distributed-system-4">
  <div class="card-body">
    <h2 class="card-title">Availability</h2>
    <ul>
      <li>Ability of the system to remain functional despite failures.</li>
      <li>Achieved by replication.</li>
      <li>Reliability means availability, but the opposite is not true.</li>
    </ul>

    <h3 class="card-title">Single-master replication (Primary-backup replication)</h3>
    <ul>
      <li>Primary processes updates locally and propagates updates to backups.</li>
      <li>Synchrounous - primary responds to client after receving acknowledgements from all backups.</li>
      <li>Asynchrounous - primary responds to client without receving acknowledgements from all backups.</li>
      <li>Scalable for read-heavy (read can happen from any backups) but not so for write-heavy. (only primary can handle writes)</li>
    </ul>

    <h3 class="card-title">Leader and follower</h3>
    <ul>
      <li>Only one leader is responsible for data replication and coordination work.</li>
      <li>At any time, one server is elected as a leader.</li>
      <li>Followers only accept writes from leader.</li>
    </ul>

    <h3 class="card-title">Multi-master replication (multi-primary replication)</h3>
    <ul>
      <li>All replicas can accept write requests.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-the-system-design-interview">Grokking the System Design Interview</a> | <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="distributed-system-5">
  <div class="card-body">
    <h2 class="card-title">Quorum</h2>
    <ul>
      <li>We write data to the nodes that are only resposible for write operations. We read data from all nodes and return the latest value.</li>
      <li>We need to find balance between read-write nodes and read-only nodes.</li>
      <li>Quorum is achieved when</li>
      <ul>
        <li>R + W > N. This ensures that a data is not read and written by two operations concurrently.</li>
        <li>W/2 > N. This ensures hat two write operations from two different operations cannot occur concurrently on the same data.</li>
      </ul>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-the-system-design-interview">Grokking the System Design Interview</a> | <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="distributed-system-6">
  <div class="card-body">
    <h2 class="card-title">CAP theorem</h2>
    <ul>
      <li>It is impossible to acheive all three at the same time. We can only have two out of three.</li>
      <li>Consistency: all nodes see the same data at the same time.</li>
      <li>Availability: system must be accessible even when nodes fail.</li>
      <li>Partition tolerance: system must operate even when communications between nodes break.</li>
    </ul>

    <p class="card-text">In distributed system, If there is no partition tolerance, there is no consistency or availability. This means we can only choose between consistency or availability in distributed system.</p>
    <ul>
      <li>CA - RDBMS (Non-distributed system)</li>
      <li>PA - Dynamo, Cassandra, CouchDB (BASE DBs choose availability - respond with local data w/o ensuring its the latest with peers)</li>
      <li>PC - BigTable, HBase (ACID DBs choose consistency - refuse response if cannot check peers)</li>
    </ul>

    <h3 class="card-title">PACELC theorem</h3>
    <ul>
      <li>When there is no network partition during normal operation, then choose between latency or consistency.</li>
      <li>To guarantee data consistency, the system will have to delay write operations until the data has been propagated across the system successfully, taking a latency hit.</li>
      <li>PA system would go for L (latency) and PC system would go for C (consistency)</li>
    </ul>

    <p class="card-text"><strong>Systems that choose A over C can still support eventual consistency but no linearizability/sequential/casual!</strong></p>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-the-system-design-interview">Grokking the System Design Interview</a> | <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="distributed-system-7">
  <div class="card-body">
    <h2 class="card-title">Consistency</h2>
    <ul>
      <li>Considers single object operations.</li>
    </ul>

    <h3 class="card-title">Linearizability</h3>
    <ul>
      <li>Synchronous replication technique. (Acknowledgment is not sent to the client until the new value is written to all replicas)</li>
      <li>Once an operation is complete and the ack is delivered to client, it is visible to all other clients.</li>
      <li>Ex. updating account password.</li>
    </ul>

    <h3 class="card-title">Sequential consistency</h3>
    <ul>
      <li>Preserves the ordering specified by each client’s program.</li>
      <li>For example, we don't care what’s the ordering of posts between our friends. But, the posts from a single friend has to be displayed in the right order.</li>
    </ul>

    <h3 class="card-title">Causal consistency</h3>
    <ul>
      <li>Operations that are not causally related can be seen in different orders.</li>
      <li>For example, comments and their sub-comments must appear in the right order.</li>
    </ul>

    <h3 class="card-title">Eventual consistency</h3>
    <ul>
      <li>Do not need to return the latest write as long as the system eventually arrives at a stable state.</li>
      <li>Can achieve high availability.</li>
      <li>Ex. DNS, Cassandra<./li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-the-system-design-interview">Grokking the System Design Interview</a> | <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="distributed-system-8">
  <div class="card-body">
    <h2 class="card-title">Isolation level</h2>
    <ul>
      <li>Considers multi object operations.</li>
    </ul>

    <h3 class="card-title">Serializability</h3>
    <ul>
      <li>Two transactions executed concurrently should give same result.</li>
      <li>Prevents all anomalies.</li>
    </ul>

    <h3 class="card-title">Repeatable read</h3>
    <ul>
      <li>Data once read by a transaction will not change throughout its course.</li>
    </ul>

    <h3 class="card-title">Snapshot isolation</h3>
    <ul>
      <li>All reads made in a transaction see a consistent snapshot of the database.</li>
    </ul>

    <h3 class="card-title">Read committed</h3>
    <ul>
      <li>Does not allows a transaction to read a data that has not yet been committed by other transaction.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-the-system-design-interview">Grokking the System Design Interview</a> | <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="distributed-system-9">
  <div class="card-body">
    <h2 class="card-title">Anomaly</h2>

    <h3 class="card-title">Dirty write</h3>
    <ul>
      <li>Transaction overwrites a value that was written by another transaction that is not committed yet.</li>
    </ul>

    <h3 class="card-title">Dirty read</h3>
    <ul>
      <li>Transaction reads a value that was written by another transaction that is not committed yet.</li>
    </ul>

    <h3 class="card-title">Fuzzy or non-repeatable read</h3>
    <ul>
      <li>Value is retrieved twice during a transaction and the value is different.</li>
    </ul>

    <h3 class="card-title">Phantom read</h3>
    <ul>
      <li>For example, transaction of two queries runs to calculate the maximum and the average. However, another transaction intervenes to insert lots of record, thus making the first transaction return an average that is larger than the maximum.</li>
    </ul>

    <h3 class="card-title">Lost update</h3>
    <ul>
      <li>Two transactions read the same value and then try to update it to two different values.</li>
    </ul>

    <h3 class="card-title">Read skew</h3>
    <ul>
      <li>A transaction can only see partial results of another transaction.</li>
    </ul>

    <h3 class="card-title">Dirty write</h3>
    <ul>
      <li>Two transactions read the same data, but then modify disjoint sets of data.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-the-system-design-interview">Grokking the System Design Interview</a> | <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="distributed-system-10">
  <div class="card-body">
    <h2 class="card-title">RPC</h2>
    <ul>
      <li>For building applications on top of distributed system.</li>
    </ul>

    <h3 class="card-title">RPC process</h3>
    <ul>
      <li>Client initiates client stub process by giving parameters.</li>
      <li>Client stub converts the parameters into standardized format and packs them into a message.</li>
      <li>Client RPC runtime delivers the message to the server over the network.</li>
      <li>Server RPC runtime receives the message and passes it to the server stub.</li>
      <li>Server stub unpacks the message to retrieve the parameters and calls the desired server routine.</li>
      <li>Server stub packs the returned result into a message and sends it to RPC runtime at the server.</li>
      <li>Server RPC runtime returns the packed result to Client RPC runtime over the network.</li>
      <li>Client RPC runtime sends the result to the client stub.</li>
      <li>Client stub unpacks the result.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>
<!-- Distributed system END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>