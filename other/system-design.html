<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js"></script>
<script src="/js/bootstrap.bundle.min.js"></script>
<script src="/js/highlight.pack.js"></script>
<script src="/js/tex-mml-chtml.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Other</h1>

<!-- System design BEGIN -->
<div class="card mb-4" id="system-design">
  <div class="card-body">
    <h2 class="card-title">System design</h2>
    <p class="card-text"></p>
    <ul class="list-unstyled mb-0">
      <li><a href="#system-design-1">System design</a></li>
      <li><a href="#system-design-2">Machine learning system design</a></li>
      <br>
      <li><a href="#system-design-10">Key-value store</a></li>
      <li><a href="#system-design-11">CDN</a></li>
      <li><a href="#system-design-12">Sequencer</a></li>
      <li><a href="#system-design-13">Distributed cache</a></li>
      <li><a href="#system-design-14">Distributed message queue</a></li>
      <li><a href="#system-design-15">Pub-sub</a></li>
      <li><a href="#system-design-16">Rate limiter</a></li>
      <li><a href="#system-design-17">Blob store</a></li>
      <li><a href="#system-design-18">Distributed search</a></li>
      <li><a href="#system-design-19">Distributed task scheduler</a></li>
      <li><a href="#system-design-20">Sharded counter</a></li>
      <br>
      <li><a href="#system-design-50">Youtube</a></li>
      <li><a href="#system-design-51">Quora</a></li>
      <li><a href="#system-design-52">Google maps</a></li>
      <li><a href="#system-design-53">Yelp</a></li>
      <li><a href="#system-design-54">Uber</a></li>
      <li><a href="#system-design-55">Twitter</a></li>
      <li><a href="#system-design-56">Newsfeed</a></li>
      <li><a href="#system-design-57">Instagram</a></li>
      <li><a href="#system-design-58">TinyURL</a></li>
      <li><a href="#system-design-59">Web crawler</a></li>
      <li><a href="#system-design-60">Typeahead</a></li>
      <li><a href="#system-design-61">Whatsapp</a></li>
      <li><a href="#system-design-62">Google doc</a></li>
      <br>
      <li><a href="#system-design-100">Google search</a></li>
      <li><a href="#system-design-101">Twitter feed</a></li>
      <li><a href="#system-design-102">Netflix</a></li>
      <li><a href="#system-design-103">Tesla</a></li>
      <li><a href="#system-design-104">Entity linking</a></li>
      <li><a href="#system-design-105">Ad prediction</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="system-design-1">
  <div class="card-body">
    <h2 class="card-title">System design</h2>

    <h3 class="card-title">High level design</h3>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/sd-cicd.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">Component design</h3>

  </div>
  <div class="card-footer text-muted">

  </div>
</div>

<div class="card mb-4" id="system-design-2">
  <div class="card-body">
    <h2 class="card-title">Machine learning system design</h2>

    <h3 class="card-title">High level design</h3>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/ml-highlevel.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">Component design</h3>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/ml-development-v1.png" alt="Card image cap">
    <br>
    <br>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/ml-training-v1.png" alt="Card image cap">
    <br>
    <br>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/ml-inference-batch-v1.png" alt="Card image cap">
    <br>
    <br>
    <ul>
      <li>Performce for out-of-sample and out-of-time.</li>
      <li>Features should be mostly unchanged when input data is slighly perturbed. (Could be challgenging when data contains similar/duplicate features)</li>
      <li>Interpretation should not be depending on training sample choices.</li>
    </ul>

    <h3 class="card-title">Problem definition</h3>
    <ul>
      <li>Construct ground truth.</li>
      <li>Metrics.</li>
    </ul>

    <h3 class="card-title">Data prep</h3>
    <ul>
      <li>Proportion of null/zero values across columns.</li>
      <li>Columns that should be rejected due to zero or null values.</li>
      <li>Categorical columns with high cardinality.</li>
      <li>Columns with high sparcity.</li>
      <li>Duplicate columns.</li>
      <li>Compute per-month count of rows and selected attribute to see if they make sense.</li>
      <li>Verify that join keys are consistent across tables.</li>
      <li>Verify that labels/values to apply exclusions are available in the tables.</li>
      <li>Verify that labels/values to apply ground truth are available in the tables.</li>
      <li>Rectify missing values in columns.</li>
      <ul>
      <li>Random missing value - value is missing for unexplained reason.</li>
      <li>Structural missing value - value is missing for a reason. (For example, the fact that it is missing means something)</li>
      <li>Engineered missing value - feature engineering introduced the missing values. (For example, divide by zero)</li>
      <li>Table join mismatch - IDs in one table were missing in another table, so missing values are created after join.</li>
    </ul>
    </ul>

    <h3 class="card-title">Data profiling</h3>
    <ul>
      <li>General statistics.</li>
      <li>Columns with large portion of missing values. (For example, > 10%)</li>
      <ul>
        <li>These columns should generally be retained for they may turn out to be quite predictive.</li>
        <li>XGBoost has build-in capability to handle missing values.</li>
      </ul>
      <li>Similar/duplicate columns. (For example, prefer one feature over another? Can use univariate analysis)</li>
      <li>Columns with consistant values should be removed because they provide no signal.</li>
      <li>Remove sensitive features from model inputs. (For example, age / gender)</li>
      <li>Data imputation (For example, NULL to 0) should rarely happens when feature is critical and will undergo feature engineering and treatment is known.</li>
    </ul>

    <h3 class="card-title">Exclusion</h3>
    <ul>
      <li>Exclude rows based on certain attributes. (This is driven by business reasons)</li>
    </ul>

    <h3 class="card-title">Ground truth construction</h3>

    <h3 class="card-title">Data split</h3>
    <ul>
      <li>Training: In-Time and In-Sample. Split into 5-folds for cross-validation.</li>
      <li>Testing: Out-of-Time test and In-Time & Out-of-Sample test.</li>
      <li>If a data about person is seen at many different dates, all data about that person must be assigned to the same split. (either Out-of-Sample or one of the folds) Otherwise, there is information leak bwetween training and validation.</li>
      <li>Final model is retrained with all 5 folds combined.</li>
    </ul>

    <h3 class="card-title">Data representativeness</h3>
    <ul>
      <li>Separate datasets by ground truth labels.</li>
      <li>Perform univariate analysis. For example, look at the distribution of samples of a key feature for both the entire dataset and the partitioned dataset. Repeat for all key features.</li>
      <li>All paritioned datasets must include sufficient volume of each ground truth labels across key features.</li>
      <li>Bin size may be increased or bins could be combined as a result of above analysis.</li>
    </ul>

    <h3 class="card-title">Model development</h3>
    <ul>
      <li>Define metric to evaluate the model.</li>
      <li>Score the model by the desired metric.</li>
      <li>Check model performace by month to check seasonality.</li>
      <li>Kubernetes based</li>
      <ul>
        <li>Make changes to code.</li>
        <li>Build, test, package the code.</li>
        <li>Build an image which includes the code package.</li>
        <li>Deploy the image to Kubenetes using tools like Skaffold / Helm.</li>
        <li>Run commands inside the image to execute the code.</li>
      </ul>
      <li>Databricks based</li>
      <ul>
        <li>Make changes to code.</li>
        <li>Build, test, package, publish the code.</li>
        <li>Import the code from the notebook.</li>
        <li>Write additional code on the notebook as needed.</li>
        <li>Run commands on the notebook execute the code.</li>
      </ul>
    </ul>

    <h3 class="card-title">Feature selection</h3>
    <ul>
      <li>Start with initial set of feature ~ 1500</li>
      <li>First gate</li>
      <ul>
        <li>Data preparation</li>
        <li>Feature engineering</li>
      </ul>
      <li>After exclusions ~ 1000</li>
      <li>First stage</li>
      <ul>
        <li>Assess each feature individually.</li>
        <li>Select a metric.</li>
        <li>Use 4-folds for training and 1 fold for validation.</li>
        <li>Train a shallow model with a single feature as input and compute performance in validation set.</li>
        <li>Rank individual features.</li>
        <li>Then, train a model wtih all features.</li>
        <li>Then again, rank the features.</li>
      </ul>
      <ul>
        <li>Perform recursive feature search.</li>
        <li>Use 4-folds for training and 1 fold for validation. (Validation fold must be different from previous step)</li>
        <li>For each feature in top N features, train a model and score performance on validation set.</li>
        <li>Add the best scoring features to the candidate features.</li>
      </ul>
      <li>Candidate features ~ 100</li>
      <li>Second gate</li>
      <ul>
        <li>Highly correlated features should be justified or redundant features should be removed.</li>
        <li>Future retraining starts from the candidate features.</li>
      </ul>
      <li>Second stage</li>
      <ul>
        <li>Perform 5-fold cross validation with each candidate feature.</li>
        <li>Compute shapley values on the validation set.</li>
        <li>Select stable features via union of top features across the folds.</li>
      </ul>
      <li>Stable features ~ 40</li>
    </ul>

    <h3 class="card-title">Hyperparameter tuning</h3>
    <ul>
      <li>Ex. grid search, random search, bayesian optimization.</li>
    </ul>

    <h3 class="card-title">Final model training</h3>
    <ul>
      <li>Train the model using stable features and tuned hyperparameters.</li>
      <li>Evaluate on OOS (seasonality) and OOT (final evaluation) test sets.</li>
    </ul>

    <h3 class="card-title">Monitoring</h3>
    <ul>
      <li>Partial dependency plot (PDP) assesses marginal effect of a feature to the model output.</li>
      <li>Indvidual conditional expectation (ICDE) is equivalent to PDP but for an individual data point.</li>
      <li>Feature contribution is assessed via shapley values.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">

  </div>
</div>

<div class="card mb-4" id="system-design-10">
  <div class="card-body">
    <h2 class="card-title">Key-value store</h2>
    <ul>
      <li>Distributed hash table.</li>
      <li>Key is generated by a hash function.</li>
    </ul>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Users can configure availability vs consistency.</li>
      <li>Users can write into key-value store.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <li>Reliability.</li>
      <li>Scalability.</li>
    </ul>

    <h3 class="card-title">API</h3>
    <ul>
      <li>get(key)</li>
      <li>put(key, value)</li>
    </ul>

    <h3 class="card-title">Component design</h3>

    <h4 class="card-title">Vector clock</h4>
    <ul>
      <li>A list of (node, counter) pairs.</li>
      <li>If two objects have different vector clocks, we’re able to tell whether they’re causally related or not.</li>
    </ul>

    <h4 class="card-title">Merkle tree</h4>
    <ul>
      <li>Keys are hashed and used as the leaves of the tree.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-11">
  <div class="card-body">
    <h2 class="card-title">CDN</h2>
    <ul>
      <li>Geographically distributed proxy servers.d</li>
      <li>Proxy servers are placed on the network edge.</li>
    </ul>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>CDN can retrieve content from the origin servers.</li>
      <li>CDN can respond to each user’s request.</li>
      <li>If push model, origin servers can send the content to the CDN.</li>
      <li>CDN can search against a user query.</li>
      <li>CDN can update the content within peer CDN proxy servers.</li>
      <li>CDN can delete contents from cache.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <li>Reliability.</li>
      <ul>
        <li>No single point of failure.</li>
      </ul>
      <li>Scalability.</li>
      <li>Performance.</li>
      <ul>
        <li>Minimize latency.</li>
      </ul>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>The origin server provides the URI namespace to request routing system.</li>
      <li>The origin server publishes the content to the distribution system.</li>
      <li>The distribution system distributes the content to the proxy servers and provides feedback to the request routing system.</li>
      <li>User requests the routing system for a suitable proxy server.</li>
      <li>The request routing system returns IP address of a proxy server.</li>
      <li>User requests routes through the scrubber servers for security reasons.</li>
      <li>The scrubber server forwards good traffic to the edge proxy server.</li>
      <li>The edge proxy server serves the client reques.</li>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/cdn1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">API</h3>
    <ul>
      <li>retrieve_content(proxyserver_id, content_type, description)</li>
      <li>deliver_content(originserver_id, server_list, content_type, description)</li>
      <li>request_content(user_id, content_type, description)</li>
      <li>search_content(proxyserver_id, content_type, description)</li>
      <li>update_content(proxyserver_id, content_type, description)</li>
    </ul>

    <h3 class="card-title">Component design</h3>

    <h4 class="card-title">Push CDN</h4>
    <ul>
      <li>Content gets sent automatically to the CDN proxy servers from the origin server.</li>
      <li>Appropriate for static content delivery.</li>
    </ul>

    <h4 class="card-title">Pull CDN</h4>
    <ul>
      <li>A CDN pulls the unavailable data from origin servers when requested by a user.</li>
      <li>Appropriate for dynamic content delivery.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-12">
  <div class="card-body">
    <h2 class="card-title">Sequencer</h2>
    <ul>
      <li>Geographically distributed proxy servers.d</li>
      <li>Proxy servers are placed on the network edge.</li>
    </ul>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Generate unqiue identifier.</li>
      <li>Length is limited to 64 bits.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <li>Performance.</li>
    </ul>

    <h3 class="card-title">Component design</h3>

    <h4 class="card-title">UUID</h4>
    <ul>
      <li>128-bit number, which makes the primary-key indexing slower</li>
      <li>There is a chance of duplication.</li>
    </ul>

    <h4 class="card-title">Database</h4>
    <ul>
      <li>Difficult to scale for multiple data centers.</li>
    </ul>

    <h4 class="card-title">Range handler</h4>

    <h4 class="card-title">Unix timestamp</h4>

    <h4 class="card-title">Twitter Snowflake</h4>

    <h4 class="card-title">Vector clock</h4>

    <h4 class="card-title">Google TrueTime</h4>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-13">
  <div class="card-body">
    <h2 class="card-title">Distributed cache</h2>
    <ul>
      <li>Multiple cache servers coordinate to store frequently accessed data.</li>
    </ul>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Insert data.</li>
      <li>Retrieve data.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <li>Performance.</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>Cache client: holds all the information regarding cache servers.</li>
      <li>Cache server: maintain the cache of the data.</li>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/distributed-cache1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">API</h3>
    <ul>
      <li>insert(key, value)</li>
      <li>retrieve(key)</li>
    </ul>

    <h3 class="card-title">Component design</h3>
    <ul>
      <li>Each cache client uses consistent hashing to identify the cache server.</li>
      <li>Each cache server has primary and replica servers.</li>
      <li>Configuration service ensures all users see consistent view of cache servers.</li>
      <li>Monitoring services log and report metrics of cache service.</li>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/distributed-cache2.png" alt="Card image cap">
    <br>
    <br>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-14">
  <div class="card-body">
    <h2 class="card-title">Distributed message queue</h2>
    <ul>
      <li>Component between producers and consumers.</li>
      <li>Enables asynchronous communication</li>
    </ul>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Create and delete queue.</li>
      <li>Send, retrieve, delete message.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <li>Performance.</li>
    </ul>

    <h3 class="card-title">High level design</h3>

    <img class="img-fluid" class="card-img-top" src="/img/system-design/distributed-message-queue1.png" alt="Card image cap">
    <br>
    <br>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-15">
  <div class="card-body">
    <h2 class="card-title">Pub-sub</h2>
    <ul>
      <li>Asynchronous service-to-service communication.</li>
      <li>Producers and consumers are disconnected and operate independently.</li>
    </ul>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Create and subscribe topic.</li>
      <li>Read, write, and delete message.</li>
      <li>Specify retention time.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <li>Performance.</li>
    </ul>

    <h3 class="card-title">High level design</h3>

    <img class="img-fluid" class="card-img-top" src="/img/system-design/pub-sub1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">API</h3>
    <ul>
      <li>create(topic_id, topic_name)</li>
      <li>write(topic_id, message)</li>
      <li>read(topic_id)</li>
      <li>subscribe(topic_id)</li>
      <li>unsubscribe(topic_id)</li>
      <li>delete_topic(topic_id)</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-16">
  <div class="card-body">
    <h2 class="card-title">Rate limiter</h2>
    <ul>
      <li>Prevents DDOS attack.</li>
    </ul>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Limit number of requests a client can send within time window.</li>
      <li>Make the number of requests within time window configurable.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <li>Performance.</li>
    </ul>

    <h3 class="card-title">High level design</h3>

    <img class="img-fluid" class="card-img-top" src="/img/system-design/rate-limiter1.png" alt="Card image cap">
    <br>
    <br>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-17">
  <div class="card-body">
    <h2 class="card-title">Blob store</h2>
    <ul>
      <li>For write once, read many.</li>
      <li>Huge amount of unstructured data.</li>
    </ul>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Create, list, and delete container to group blobs.</li>
      <li>Create, list, update, and delete data.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <li>Performance.</li>
      <ul>
        <li>High data throughput.</li>
      </ul>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>5M active users.</li>
        <li>A single server can handle 500 connections.</li>
      </ul>
      <li>5M / 500 = 10,000 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>250,000 videos per day.</li>
        <li>Each video is 50 MB.</li>
      </ul>
      <li>250,000 * 50 MB = 12.5TB per day.</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Each user makes 20 requests.</li>
      </ul>
      <li>12.5 TB * 8 / 86400 = 1.16 Gbps</li>
      <li>5M * 20 * 50MB * 8 = 462.96 Gbps.</li>
    </ul>

    <h3 class="card-title">High level design</h3>

    <img class="img-fluid" class="card-img-top" src="/img/system-design/blob-store1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">API</h3>
    <ul>
      <li>create_container(container_name)</li>
      <li>put_blob(container_path, blob_bame, data)</li>
      <li>get_blob(blob_path)</li>
      <li>delete_blob(blob_path)</li>
      <li>list_blob(container_path)</li>
      <li>delete_container(container_path)</li>
      <li>list_containers(account_id)</li>
    </ul>

    <h3 class="card-title">Component design</h3>
    <ul>
      <li>Data nodes: hold the actual blob data.</li>
      <li>Master node: manages storage paths and access privileges of blobs.</li>
      <li>Monitoring service: monitors the data nodes and the master node.</li>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/blob-store2.png" alt="Card image cap">
    <br>
    <br>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-18">
  <div class="card-body">
    <h2 class="card-title">Distributed search</h2>
    <ul>
      <li>Crawler: fetches content and creates documents.</li>
      <li>Indexer: builds a searchable index.</li>
      <li>Searcher: responds to search queries by running the search query on the index created by the indexer..</li>
    </ul>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>User can search via queries.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <li>Performance.</li>
      <ul>
        <li>Users should get result quickly.</li>
      </ul>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>3M daily active users.</li>
        <li>A single server can handle 1000 connections.</li>
      </ul>
      <li>3M / 1,000 = 3,000 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Single JSON is 200 KB.</li>
        <li>The number of unique terms from each document is 1000.</li>
        <li>Each term is 100 bytes.</li>
        <li>6000 videos per day.</li>
      </ul>
      <li>One video: 200 KB * 1000 * 100 bytes = 300 KB.</li>
      <li>6000 * 300 KB = 1.8 GB per day.</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>150 M queries per day.</li>
        <li>Each query is 100 bytes.</li>
        <li>Response is 4000 bytes.</li>
      </ul>
      <li>Incoming: 150 M * 100 * 8 / 86400 = 1.39 Mbps</li>
      <li>Outgoing: 150 M * 4000 * 8 / 86400 = 55.56 Mbps</li>
    </ul>

    <h3 class="card-title">High level design</h3>

    <img class="img-fluid" class="card-img-top" src="/img/system-design/distributed-search1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">API</h3>
    <ul>
      <li>search(query)</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-19">
  <div class="card-body">
    <h2 class="card-title">Distributed task scheduler</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>User can submit tasks.</li>
      <li>User can cancel submitted tasks.</li>
      <li>User can see task status.</li>
      <li>CPU and memory must be allocated efficiently.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <li>Performance.</li>
    </ul>

    <h3 class="card-title">High level design</h3>

    <img class="img-fluid" class="card-img-top" src="/img/system-design/distributed-task-scheduler1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">Component design</h3>

    <img class="img-fluid" class="card-img-top" src="/img/system-design/distributed-task-scheduler2.png" alt="Card image cap">
    <br>
    <br>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-20">
  <div class="card-body">
    <h2 class="card-title">Shared counter</h2>

  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-50">
  <div class="card-body">
    <h2 class="card-title">Youtube</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Users can upload, share, view, like/dislike, search videos.</li>
      <li>Users can add, view comments.</li>
      <li>Users can view thumbnails, number of views.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability</li>
      <ul>
        <li>Consistency can take a hit.</li>
        <li>Subscribers need not get notifications for uploaded videos immediately.</li>
        <li>No need to show consistent feed for all users.</li>
      </ul>
      <li>Reliability</li>
      <li>Scalability</li>
      <li>Performance</li>
      <ul>
        <li>Users should not feel lag watching videos.</li>
      </ul>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>1B active users and 100M daily active users.</li>
        <li>A single server can handle 10K connections.</li>
      </ul>
      <li>100M / 10K = 10,000 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Each video before encoding is 1GB.</li>
        <li>After encoding, size becomes 100MB.</li>
        <li>1000 videos are uploaded every minute.</li>
      </ul>
      <li>100MB per video * 1000 video per minute = 100GB per minute.</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Ratio of upload:view is 1:100. (Every uploaded video gets 100 views)</li>
      </ul>
      <li>Video uploads (write): 1000 per minute.</li>
      <li>Video views (reads): 1000 * 100 = 100K per minute.</li>
      <li>Incoming (upload): 1GB * 1000 per minute = 10TB per minute = 1333Gbps. (Video is uncompressed during upload)</li>
      <li>Outgoing (stream): 100MB * 100K per minute = 10TB per minute = 1333Gbps.</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>User uploads video.</li>
      <li>Server sends video to encoder.</li>
      <li>Server sends user data and metadata to relational DB.</li>
      <li>Encoder encodes video and store it in object storage.</li>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/youtube1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">API</h3>
    <ul>
      <li>upload_video(user_id, video_file, title, description, tags, default_language)</li>
      <li>stream_video(user_id, video_id, resolution)</li>
      <li>search_video(user_id, query, user_location, length, max_videos_to_return)</li>
      <li>view_thunbnail(user_id, video_id)</li>
      <li>like_or_dislike_video(user_id, video_id, like)</li>
      <li>comment_video(user_id, video_id, text)</li>
    </ul>

    <h3 class="card-title">DB</h3>
    <ul>
      <li>Store video metadata in relational DB.</li>
    </ul>

    <h4 class="card-title">User</h4>
    <ul>
      <li>id (int, pk)</li>
      <li>name (varchar)</li>
      <li>email (varchar)</li>
      <li>password (varchar)</li>
    </ul>

    <h4 class="card-title">Video</h4>
    <ul>
      <li>id (int, pk)</li>
      <li>title (varchar)</li>
      <li>description (varchar)</li>
      <li>date (datetime)</li>
      <li>uploader (int)</li>
      <li>size (longint)</li>
      <li>thumbnail (varchar)</li>
      <li>likes (int)</li>
      <li>dislikes (int)</li>
      <li>views (int)</li>
    </ul>

    <h4 class="card-title">Comment</h4>
    <ul>
      <li>id (int, pk)</li>
      <li>video_id (int)</li>
      <li>user_id (int)</li>
      <li>comment (varchar)</li>
      <li>date (datetime)</li>
      <li>likes (int)</li>
      <li>dislikes (int)</li>
    </ul>

    <h3 class="card-title">Component design</h3>
    <ul>
      <li>Load balancer: distribute user load.</li>
      <li>Web server: take user request, cache frequently accessed pages. Decouple client request from business logic. Use Lighttpd to run the server for it is fast.</li>
      <li>App server: business logic.</li>
      <li>User DB: user related data, decoupled from metadata storage for easy scalability. Need strong consistency on user data. MySQL.</li>
      <li>Metadata DB: video related data. MySQL.</li>
      <li>Thumbnail DB: BigTable.</li>
      <ul>
        <li>Combines multiple files into one block to store.</li>
        <li>Very efficient for large number of small files with low retrieval latency.</li>
      </ul>
      <li>Encoder: compress vidoes and generate thumbnail.</li>
      <li>Video DB: blob.</li>
      <li>CDN: forward videos to closer proximity to serve users faster.</li>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/youtube2.png" alt="Card image cap">
    <br>
    <br>

    <h4 class="card-title">How to manage read traffic</h4>
    <ul>
      <li>Segregate read traffic and write traffic.</li>
      <li>Distribute read traffic to different servers.</li>
      <li>For video metadata, write to primary and read from secondary.</li>
    </ul>

    <h4 class="card-title">Metadata sharding</h4>
    <ul>
      <li>Store based on UserID? It is hard to maintain uniform distribution because some users upload more than others.</li>
      <li>Store based on VideoID? Solves above problem. Can cache hot vidoes in front of DB servers.</li>
    </ul>

    <h4 class="card-title">Deduplication</h4>
    <ul>
      <li>When users upload vidoes, run video matching algorithm.</li>
    </ul>

    <h4 class="card-title">Search</h4>
    <ul>
      <li>Extract data from each video and store that data into JSON (referred as document)</li>
      <li>Key-value storage is created from the documents.</li>
      <ul>
        <li>Key: all the keywords searched by users.</li>
        <li>Value: occurrence of each key, its frequency, and location of occurrence in the different documents.</li>
      </ul>
      <li>Vidoes with most relevant keywords are returned.</li>
    </ul>

    <h4 class="card-title">Load-balancing</h4>
    <ul>
      <li>Consistent hashing between cache servers.</li>
    </ul>

    <h4 class="card-title">Cache</h4>
    <ul>
      <li>Store hot vidoes in cache servers.</li>
      <li>Use LRU eviction rule.</li>
      <li>Use distributed cache like Memcached.</li>
    </ul>

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>
    <ul>
      <li>Data replication.</li>
      <li>Local load balancer to exclude dead servers.</li>
      <li>Global load balancer to reroute traffic to different region.</li>
    </ul>

    <h4 class="card-title">Reliability</h4>
    <ul>
      <li>Data partitioning.</li>
      <li>Redundant hardware for fault tolerance.</li>
      <li>Monitor servers and use consistent hashing to add/remove servers seemlessly.</li>
    </ul>

    <h4 class="card-title">Scalability</h4>
    <ul>
      <li>Horizontally scale web and app servers. (Load balancer can multiplx them)</li>
      <li>Separate read and write to different servers.</li>
    </ul>

    <h4 class="card-title">Performance</h4>
    <ul>
      <li>Lighttpd for serving videos.</li>
      <li>Cache at various component.</li>
      <li>Right DB for different data types for fast operations.</li>
      <li>CDN</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-51">
  <div class="card-body">
    <h2 class="card-title">Quora</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Users can ask questions and provide answers.</li>
      <li>Users can upvote, downvote, and comment on answers.</li>
      <li>Users can search for questions.</li>
      <li>Feed is generated based on user interest.</li>
      <li>Answers are ranked based on usefulness.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability</li>
      <ul>
        <li>Causal consistency must be met between questions and answers and comments and sub-comments.</li>
        <li>No need for all users to see new post immediately.</li>
        <li>No need for feeds to have the same ordering for all users.</li>
      </ul>
      <li>Reliability</li>
      <li>Scalability</li>
      <li>Performance</li>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>1B active users and 100M daily active users.</li>
        <li>A single server can handle 10K connections.</li>
      </ul>
      <li>100M / 10K = 10,000 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Each user posts 1 question per day.</li>
        <li>Questions, answers, comments all together consume 1KB.</li>
        <li>20% of questions have images and 10% of questions have videos.</li>
        <li>Each image is 1MB and each video is 100MB.</li>
      </ul>
      <li>(100M * 1) * (1KB + 0.2 * 1MB + 0.1 * 100MB) = 1PB per day.</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Each user views 20 questions per day.</li>
      </ul>
      <li>Incoming: (1PB per day * 8 bits) / 86400 = 92Gbps.</li>
      <li>Outgoing: 92Gbps * 20 = 1840Gbps. (1:20 ratio between write and read)</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>Load balancer forwards user requests to web servers.</li>
      <li>Web servers generate some part of page (Mostly static content) and application servers generate other part of page. (Mostly dynamic content)</li>
      <li>Questions and answers data is stored in MySQL.</li>
      <li>Images and videos are stored in Blob storage.</li>
      <li>Different features are stored in HBase for each type of question.</li>
      <li>features are forwarded to ML engine to rank the most useful answer.</li>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/quora1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">API</h3>
    <ul>
      <li>post_question(user_id, question, description, video, image)</li>
      <li>post_answer(user_id, question_id, answer_text, video, image)</li>
      <li>upvote(user_id, question_id, answer_id)</li>
      <li>comment(user_id, answer_id, comment_text)</li>
      <li>search(user_id, search_text)</li>
    </ul>

    <h3 class="card-title">DB</h3>

    <h3 class="card-title">Component design</h3>
    <ul>
      <li>Service host: combine web and app servers into one type of powerful machine. Eliminates network I/O and latency.</li>
      <li>MySQL: vertical sharding.</li>
      <li>Zookeeper: keep mappings/metadata of vertical sharding.</li>
      <li>MyRocks: replace HBase for lower latency. Also, MyRocks has native integration with MySQL.</li>
      <li>Kafka: separate not-so-urgent tasks from regular API calls.</li>
      <li>CDN: store images and videos.</li>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/quora2.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>
    <ul>
      <li>Replicate powerful machines and DB servers.</li>
      <li>Data sharding and replication.</li>
      <li>CDN as backup of data.</li>
      <li>Load balancer to distribute requests to service hosts.</li>
      <li>Consistency</li>
      <ul>
        <li>MySQL for storing question/answer.</li>
      </ul>
    </ul>

    <h4 class="card-title">Reliability</h4>

    <h4 class="card-title">Scalability</h4>
    <ul>
      <li>Horizontally scale service hosts.</li>
      <li>Vertically scale MySQL columns.</li>
      <li>Different DB types for different purpose.</li>
    </ul>

    <h4 class="card-title">Performance</h4>
    <ul>
      <li>MyRocks for lower latency.</li>
      <li>CDN to service images and vidoes.</li>
      <li>Kafka improve service host performance.</li>
      <li>Redis cache for frequently accessed data.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-52">
  <div class="card-body">
    <h2 class="card-title">Google Maps</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Users can identify current location.</li>
      <li>Users can find the fastest route between start and end.</li>
      <li>Users can listen to directions.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability</li>
      <li>Reliability</li>
      <li>Scalability</li>
      <li>Performance</li>
      <ul>
        <li>Route and direction should be suggested fast.</li>
        <li>ETA should be accurate.</li>
      </ul>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>1B active users and 100M daily active users.</li>
        <li>A single server can handle 10K connections.</li>
      </ul>
      <li>100M / 10K = 10,000 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Only one time storage is needed in the beginning.</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Each user makes 100 requests per day.</li>
        <li>Each request size is 100 bytes.</li>
        <li>Each response size is 1 KB.</li>
      </ul>
      <li>Incoming: (100M * 100 * 100 bytes * 8) / (24 x 60 x 60) = 92 Mbps.</li>
      <li>Outgoing: 920 Mbps.</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>User enters starting and end point. Starting point can be user's current location.</li>
      <ul>
        <li>User request is forwarded to route finder service.</li>
        <li>Route finder forwards requests to area search service.</li>
        <li>Area search service finds the latitude/longitude for start and end location.</li>
        <li>Graph processing service finds the shortest path and return it to route finder.</li>
      </ul>
      <li>Nagivator updates user location on the map as user is moving. It also provides directions to user.</li>
      <li>When user deviates from the path, Pub-sub alerts area search service to recalculate the optimal path.</li>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/google-map1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">API</h3>
    <ul>
      <li>curr_location(location)</li>
      <li>find_route(start, end, transport_type)</li>
      <li>directions(curr_location, steps)</li>
    </ul>

    <h3 class="card-title">DB</h3>

    <h4 class="card-title">Key-value store</h4>
    <ul>
      <li>Segment to server</li>
      <ul>
        <li>segment_id (int)</li>
        <li>server_id (int)</li>
      </ul>
      <li>Belongs to segment</li>
      <ul>
        <li>segment_id (int)</li>
        <li>coordinates (list): stores latitude and longitude.</li>
      </ul>
      <li>Neighbors</li>
      <ul>
        <li>segment_id (int)</li>
        <li>neighbors (list): stores a list of segment IDs.</li>
      </ul>
    </ul>

    <h4 class="card-title">Graph DB</h4>
    <ul>
      <li>Graph data</li>
      <ul>
        <li>segment_id (int)</li>
        <li>road_network (graph)</li>
      </ul>
    </ul>

    <h4 class="card-title">Relational DB</h4>
    <ul>
      <li>Rush hour</li>
      <ul>
        <li>segment_id (int)</li>
        <li>edge_id (int)</li>
        <li>hour_range (tuple)</li>
        <li>rush_hour (bool): where there is congestion or not.</li>
      </ul>
    </ul>

    <h3 class="card-title">Component design</h3>

    <h4 class="card-title">Sub-graphs</h4>
    <ul>
      <li>Computing distances between two points on the entire graph is super expensive.</li>
      <li>Precalculate the shortest distance between two points in sub-graphs. Also, cache most requested routes.</li>
      <li>Connect sub-graphs and run the shortest distance algorithm.</li>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/google-map2.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>
    <ul>
      <li>Each segment is processed in a separate server.</li>
      <li>Segments can be replicated.</li>
      <li>Load balancer distributes requests to different segments.</li>
    </ul>

    <h4 class="card-title">Reliability</h4>

    <h4 class="card-title">Scalability</h4>
    <ul>
      <li>Segments can easily be added.</li>
      <li>Host segments on different servers.</li>
    </ul>

    <h4 class="card-title">Performance</h4>
    <ul>
      <li>Use of sub-graphs make computation faster than using entire graph.</li>
      <li>Cache processed sub-graphs.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-53">
  <div class="card-body">
    <h2 class="card-title">Yelp</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Users can search place of interest based on their location.</li>
      <li>Users can post reviews which consists of texts, images, videos.</li>
      <li>Users can add, delete, and update place information.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability</li>
      <li>Reliability</li>
      <li>Scalability</li>
      <ul>
        <li>Should be able to handle peak season.</li>
      </ul>
      <li>Performance</li>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>1B active users and 100M daily active users.</li>
        <li>A single server can handle 10K connections.</li>
      </ul>
      <li>100M / 10K = 10,000 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>100M places.</li>
        <li>Each place need 10KB storage for description text, images, videos. (Image and video are compressed)</li>
        <li>1M reviews are posted per day.</li>
        <li>Each review need 1KB storage for description text, images, videos. (Image and video are compressed)</li>
      </ul>
      <li>100M * 10KB + 1M per day * 1 KB = 1 TB + 1 GB per day ~ 1TB</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>1M reviews are posted per day.</li>
        <li>Each user searches once a day.</li>
        <li>Each search returns 10 pages.</li>
      </ul>
      <li>Incoming: 1M * 1KB * 8 / 86400 = 92 Kbps</li>
      <li>Outgoing: 100M * 1 * 10 * 10 KB * 8 / 86400 = 926 Mbps</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>User searches for places.</li>
      <ul>
        <li>Request goes to read servers.</li>
        <li>Key-value store holds segment (map) information.</li>
      </ul>
      <li>User post reviews.</li>
      <ul>
        <li>Images and videos go to blob storage.</li>
        <li>Other data goes to relational DB.</li>
        <li>Request goes to write servers.</li>
      </ul>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/yelp1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">API</h3>
    <ul>
      <li>search(category, user_location, radius)</li>
      <ul>
        <li>Search based on category of place. Returns JSON object.</li>
      </ul>
      <li>search(place_name, user_location, radius)</li>
      <ul>
        <li>Search based on name of place. Returns JSON object.</li>
      </ul>
      <li>add_place(place_name, place_description, category, latitude, longitude, photo)</li>
      <li>add_review(place_id, user_id, review_description, rating)</li>
    </ul>

    <h3 class="card-title">DB</h3>
    <ul>
      <li>Relational DB.</li>
    </ul>

    <h4 class="card-title">Place</h4>
    <ul>
      <li>place_id (int, pk)</li>
      <li>place_name (varchar)</li>
      <li>place_description (varchar)</li>
      <li>category (varchar)</li>
      <li>latitude (float)</li>
      <li>longitude (float)</li>
      <li>photo_id (int)</li>
    </ul>

    <h4 class="card-title">Photo</h4>
    <ul>
      <li>photo_id (int, pk)</li>
      <li>place_id (int)</li>
      <li>photo_path (varchar)</li>
    </ul>

    <h4 class="card-title">Review</h4>
    <ul>
      <li>review_id (int, pk)</li>
      <li>place_id (int)</li>
      <li>user_id (int)</li>
      <li>review_description (varchar)</li>
      <li>rating (int)</li>
    </ul>

    <h4 class="card-title">User</h4>
    <ul>
      <li>user_id (int, pk)</li>
      <li>username (varchar)</li>
      <li>password (varchar)</li>
      <li>email (varchar)</li>
    </ul>

    <h3 class="card-title">Component design</h3>

    <img class="img-fluid" class="card-img-top" src="/img/system-design/yelp2.png" alt="Card image cap">
    <br>
    <br>

    <h4 class="card-title">Segment</h4>
    <ul>
      <li>Each segment id is mapped to a list of places within that segment.</li>
    </ul>

    <h4 class="card-title">Data partitioning</h4>
    <ul>
      <li>Partition based on place id.</li>
    </ul>

    <h4 class="card-title">QuadTree server</h4>
    <ul>
      <li>Have trees that contain the places in the segments.</li>
      <li>Find a list of places based on the given radius.</li>
    </ul>

    <h4 class="card-title">Aggregator server</h4>
    <ul>
      <li>Aggregate the results from QuadTree servers and return search result to the user.</li>
    </ul>

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>
    <ul>
      <li>Horizontal scaling of read / write servers.</li>
      <li>Data paritioning.</li>
    </ul>

    <h4 class="card-title">Reliability</h4>
    <ul>
      <li>Data replication.</li>
    </ul>

    <h4 class="card-title">Scalability</h4>
    <ul>
      <li>Separation of read and write servers so that they can scale independently.</li>
      <li>Data paritioning.</li>
      <li>QuadTrees.</li>
    </ul>

    <h4 class="card-title">Performance</h4>
    <ul>
      <li>Use cashe on read servers.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-54">
  <div class="card-body">
    <h2 class="card-title">Uber</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Users can find nearby drivers.</li>
      <li>Users can request a ride.</li>
      <li>Users can view drivers ETA.</li>
      <li>Users can make payments.</li>
      <li>Drivers can confirm pickup.</li>
      <li>Drivers can end the trip upon arriving at destination.</li>
      <li>Drivers location should be updated regularly.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability</li>
      <li>Reliability</li>
      <li>Scalability</li>
      <li>Performance</li>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>100M total users, 10M daily active users, 1M drivers</li>
        <li>A single server can handle 10K connections.</li>
      </ul>
      <li>10M / 10K = 1,000 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Each user and driver require 1KB metadata.</li>
        <li>Each driver location requires 1KB metadata.</li>
        <li>Each trip information requires 1KB metadata.</li>
        <li>Each user makes 1 trip per day.</li>
      </ul>
      <li>User and driver: 100M * 1KB + 1M * 1KB = 101GB</li>
      <li>Driver location: 1M * 1KB = 1GB per day</li>
      <li>Trip information: 10M * 1KB = 10GB per day</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Driver location is updated every 2 seconds.</li>
        <li>From 1KB of drivers metadata, 100 bytes are used for driver id and location.</li>
      </ul>
      <li>Incoming (trip information): (10M trips per day / 86400) * 1KB * 8 = 0.926Mbps</li>
      <li>Outgoing (driver location): (1M drivers / 2) * 100B * 8 = 0.926Mbps = 400 Mbps</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>User enters destination.</li>
      <ul>
        <li>App displays avaiable drivers nearby.</li>
        <li>User picks a driver.</li>
        <li>Driver confirms pickup.</li>
        <li>Driver location is updated every 2 seconds.</li>
      </ul>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/uber1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">API</h3>
    <ul>
      <li>update_driver_location(driver_id, old_latitude, old_longitude, new_latitude, new_longitude)</li>
      <li>find_nearby_drivers(user_id, latitude, longitude)</li>
      <li>request_ride(user_id, latitude, longitude, dest_latitude, dest_longitude)</li>
      <li>show_eta(driver_ida)</li>
      <li>confirm_pickup(driver_id, rider_id)</li>
      <li>end_trip(trip_id, user_id, driver_id)</li>
    </ul>

    <h3 class="card-title">DB</h3>
    <ul>
      <li>Relational DB for in-progress trips.</li>
      <li>Cassandra for driver’s last location and the trip information after the trip is completed.</li>
    </ul>

    <h4 class="card-title">User</h4>
    <ul>
      <li>user_id (int, pk)</li>
      <li>username (varchar)</li>
      <li>password (varchar)</li>
      <li>email (varchar)</li>
    </ul>

    <h4 class="card-title">Driver</h4>
    <ul>
      <li>driver_id (int, pk)</li>
      <li>name (varchar)</li>
      <li>email (varchar)</li>
      <li>phone (int)</li>
      <li>vechicle_type (varchar)</li>
    </ul>

    <h4 class="card-title">Driver location</h4>
    <ul>
      <li>driver_id (int)</li>
      <li>old_latitude (float)</li>
      <li>new_longitude (float)</li>
      <li>old_latitude (float)</li>
      <li>new_longitude (float)</li>
    </ul>

    <h4 class="card-title">Trip</h4>
    <ul>
      <li>trip_id (int, pk)</li>
      <li>user_id (int)</li>
      <li>driver_id (int)</li>
    </ul>

    <h3 class="card-title">Component design</h3>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/uber2.png" alt="Card image cap">
    <br>
    <br>

    <h4 class="card-title">Location manager</h4>
    <ul>
      <li>Shows nearby drivers to the riders.</li>
      <li>Receives location updates from the drivers every 4 seconds.</li>
      <li>Saves the last location of all drivers in DB.</li>
    </ul>

    <h4 class="card-title">Quadtree server</h4>
    <ul>
      <li>Updates the location of the drivers.</li>
    </ul>

    <h4 class="card-title">Trip manager</h4>
    <ul>
      <li>Stores trip information in DB.</li>
    </ul>

    <h4 class="card-title">ETA service</h4>
    <ul>
      <li>Shows riders the pickup ETA.</li>
    </ul>

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>
    <ul>
      <li>WebSocket servers.</li>
      <li>Load balancer.</li>
      <li>Multiple replicas of DB with primary-secondary model.</li>
      <li>Cassandra: high availability and no single point of failure.</li>
    </ul>

    <h4 class="card-title">Reliability</h4>
    <ul>
      <li>Trip can continue even if connection is broken. (By using user and driver phones as local storage)</li>
      <li>WebSocket servers: smooth, nearly real-time operations.</li>
      <li>Redundancy on servers and DB.</li>
    </ul>

    <h4 class="card-title">Scalability</h4>
    <ul>
      <li>Independent services that can scale independently.</li>
      <li>Quadtree servers.</li>
      <li>CDN.</li>
      <li>Cassandra: horizontally scalable.</li>
    </ul>

    <h4 class="card-title">Performance</h4>

  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-55">
  <div class="card-body">
    <h2 class="card-title">Twitter</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Users can post new tweets.</li>
      <li>Users can delete tweets.</li>
      <li>Users can like/dislike tweets.</li>
      <li>Users can reply to tweets.</li>
      <li>Users can retweet tweets.</li>
      <li>Users can search tweets.</li>
      <li>Users can follow/unfollow other users.</li>
      <li>Display users timeline with top tweets.</li>
      <li>Tweets contain photos and videos.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability</li>
      <li>Reliability</li>
      <li>Scalability</li>
      <li>Performance</li>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>100M daily active users</li>
        <li>A single server can handle 10K connections.</li>
      </ul>
      <li>100M / 10K = 10,000 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>100M Tweets everyday.</li>
        <li>Each Tweet takes up 200 bytes. (Including the metadata)</li>
        <li>Photo in every 5 Tweets with 200KB.</li>
        <li>Video in every 10 Tweets with 2MB.</li>
      </ul>
      <li>Tweet: 100M * 200 bytes = 20GB per day.</li>
      <li>Media: (100M/5) * 200KB + (100M/10) * 2MB = 24TB per day.</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Each user views 50 tweets per day.</li>
        <li>Then, the number of Tweet views per day = 100M * 50 = 5B per day</li>
      </ul>
      <li>Incoming: 24TB per day * 8 / 86400 = 2.2Gbps.</li>
      <li>Outgoing: ( 5B * 200 bytes + (5B/5) * 200 KB + (5B/10) * 2MB ) * 8 / 86400 = (1,000GB + 200,000GB + 1,000,000GB) * 8 / 86400 = 111.2Gbps</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>User posts Tweets, which gets stored in DB.</li>
      <li>Requests go through load balancers and app servers.</li>
      <li>CDN servers photos and videos to users.</li>
      <li>DNS servers provides users with IP addresses.</li>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/twitter1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">API</h3>
    <ul>
      <li>post_tweet(user_id, tweet_content)</li>
      <li>delete_tweet(tweet_id)</li>
      <li>like_tweet(user_id, tweet_id)</li>
      <li>reply_tweet(user_id, tweet_id, reply_content)</li>
      <li>retweet_tweet(user_id, tweet_id)</li>
      <li>search_tweet(user_id, search_term)</li>
      <li>follow_user(user_id, followee_id)</li>
      <li>display_timeline(user_id, tweets_count)</li>
    </ul>

    <h3 class="card-title">DB</h3>

    <h4 class="card-title">Tweet</h4>
    <ul>
      <li>tweet_id (int, pk)</li>
      <li>user_id (int)</li>
      <li>content (varchar)</li>
      <li>creation_date (datetime)</li>
      <li>num_favorite (int)</li>
    </ul>

    <h4 class="card-title">User</h4>
    <ul>
      <li>user_id (int, pk)</li>
      <li>name (varchar)</li>
      <li>email (varchar)</li>
      <li>creation_date (datetime)</li>
    </ul>

    <h4 class="card-title">User follow</h4>
    <ul>
      <li>user_id1 (int, pk)</li>
      <li>user_id2 (int, pk)</li>
    </ul>

    <h3 class="card-title">Component design</h3>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/twitter2.png" alt="Card image cap">
    <br>
    <br>

    <h4 class="card-title">BigQuery</h4>
    <ul>
      <li>Storage for big data.</li>
    </ul>

    <h4 class="card-title">Manhattan</h4>
    <ul>
      <li>Real-time distributed key-value store.</li>
    </ul>

    <h4 class="card-title">Blob store</h4>
    <ul>
      <li>Stores photos, videos, binary files.</li>
    </ul>

    <h4 class="card-title">MySQL</h4>
    <ul>
      <li>Ad data that need strong consistency.</li>
    </ul>

    <h4 class="card-title">Kafka</h4>
    <ul>
      <li>Handles real time requests.</li>
    </ul>

    <h4 class="card-title">FlockDB</h4>
    <ul>
      <li>Graph database for huge adjacency lists, rapid reads and writes.</li>
    </ul>

    <h4 class="card-title">Apache Lucene</h4>
    <ul>
      <li>Used for real-time search, which uses an inverted index.</li>
    </ul>

<!--     <h4 class="card-title">Data sharding</h4>
    <ul>
      <li>Construct Tweet ID such that</li>
      <ul>
        <li>[epoch_timestamp]-[auto-incrementing-sequence]</li>
        <li>Assign shard based on the second part. (auto-incrementing-sequence)</li>
        <li>Reset auto-incrementing-sequence every second.</li>
      </ul>
      <li>Indexing Tweet ID makes querying the latest Tweets fast.</li>
      <li>Still need to query all the servers for timeline generation.</li>
      <li>Aggregate results from DBs and return it to users.</li>
    </ul>

    <h4 class="card-title">Caching</h4>
    <ul>
      <li>App servers can check cache servers before going to DB.</li>
      <ul>
        <li>Use LRU eviction policy.</li>
      </ul>
      <li>Cache the latest data.</li>
      <ul>
        <li>Hash table where key is UserID and value is doubly linked list containning all Tweets from the user in the past 3 days.</li>
        <li>Always insert new Tweets at the head of doubly linked list.</li>
        <li>Evict Tweets from the tail.</li>
      </ul>
    </ul>

    <h4 class="card-title">Replication</h4>
    <ul>
      <li>Each DB has multiple replicas.</li>
      <li>Writes go to primary and reads go to secondary.</li>
    </ul> -->

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>

    <h4 class="card-title">Reliability</h4>

    <h4 class="card-title">Scalability</h4>

    <h4 class="card-title">Performance</h4>

  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-56">
  <div class="card-body">
    <h2 class="card-title">Newsfeed</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Feed is generated based on posts from people, pages, groups that user follows.</li>
      <li>User can have/follow many friends, pages, groups.</li>
      <li>Feed can contain images, videos, texts.</li>
      <li>Supports adding new posts as they arrive.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <ul>
        <li>Consistency can take hit.</li>
      </ul>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <li>Performance.</li>
      <ul>
        <li>Maximum latency to generate feeds is 2 seconds.</li>
        <li>Posts should take less than 5 seconds to make it to user's feed.</li>
      </ul>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>1B total users.</li>
        <li>100M daily active users</li>
        <li>A single server can handle 10K connections.</li>
      </ul>
      <li>100M / 10K = 10,000 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Each user's metadata is 100KB.</li>
        <li>Each user's feed has 500 posts.</li>
        <li>Each post is 10KB texts, 100KB images, 1MB videos on average.</li>
      </ul>
      <li>100KB * 1B = 100TB for all user metadata.</li>
      <li>500 * 100M * (10KB + 100KB + 1MB) = 55PB for all posts.</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Each user opens app 10 times a day.</li>
      </ul>
      <li>Incoming: 100M * 10 = 1B requests per day.</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>Feed is generated via aggregating friends and followers posts.</li>
      <li>Feed is published and stored in cache and DB.</li>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/newsfeed1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">API</h3>
    <ul>
      <li>generate_feed(user_id)</li>
      <li>get_feed(user_id, count)</li>
    </ul>

    <h3 class="card-title">DB</h3>
    <ul>
      <li>Use relational database.</li>
      <li>Use a graph database only for the relationships between users.</li>
    </ul>

    <h4 class="card-title">Entity</h4>
    <ul>
      <li>entity_id (int, pk)</li>
      <li>name (varchar)</li>
      <li>name (description)</li>
      <li>creation_date (datetime)</li>
    </ul>

    <h4 class="card-title">User</h4>
    <ul>
      <li>user_id (int, pk)</li>
      <li>name (varchar)</li>
      <li>email (varchar)</li>
      <li>creation_date (datetime)</li>
    </ul>

    <h4 class="card-title">Feed item</h4>
    <ul>
      <li>feed_item_id (int, pk)</li>
      <li>user_id (int)</li>
      <li>entity_id (int)</li>
      <li>content (varchar)</li>
      <li>num_likes (int)</li>
      <li>creation_date (datetime)</li>
    </ul>

    <h4 class="card-title">Media</h4>
    <ul>
      <li>media_id (int, pk)</li>
      <li>description (varchar)</li>
      <li>path (varchar)</li>
      <li>creation_date (datetime)</li>
    </ul>

    <h4 class="card-title">User (Vertex)</h4>
    <ul>
      <li>user_id (int, pk)</li>
      <li>properties (JSON)</li>
    </ul>

    <h4 class="card-title">Relationship (Edge)</h4>
    <ul>
      <li>relation_id (int, pk)</li>
      <li>from (user_id)</li>
      <li>to (user_id)</li>
      <li>properties (JSON)</li>
    </ul>

    <h3 class="card-title">Component design</h3>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/newsfeed2.png" alt="Card image cap">
    <br>
    <br>

    <h4 class="card-title">Newsfeed generation service</h4>
    <ul>
      <li>Generate feed offline: dedicated servers that generate user feed and store them in memory.</li>
      <li>Retrive ID of all users and entities that the user follows.</li>
      <li>Retrive the latest, most popular, most relevant posts for those IDs.</li>
      <li>Ranking service ranks these posts.</li>
      <li>Newsfeed cache stores feed into cache.</li>
    </ul>

    <h4 class="card-title">Newsfeed publishing service</h4>
    <ul>
      <li>Fetches a list of post IDs from the newsfeed cache, which has <code>(post_id, user_id)</code></li>
    </ul>

    <h4 class="card-title">Notification service</h4>
    <ul>
      <li>Pull: users pull feed at regular interval.</li>
      <li>Push: post is pushed to all followers whenever it is published.</li>
      <li>Celebrity users should have pull model.</li>
    </ul>

    <!-- <h4 class="card-title">Web server</h4>
    <ul>
      <li>Maintain connection with users.</li>
      <li>Store new posts in DB servers.</li>
      <li>Retrieve and push feeds to users.</li>
    </ul>

    <h4 class="card-title">Metadata DB and cache</h4>
    <ul>
      <li>Store metadata about users, pages, groups.</li>
    </ul>

    <h4 class="card-title">Post DB and cache</h4>
    <ul>
      <li>Store metadata about posts.</li>
    </ul>

    <h4 class="card-title">Video and photo storage, and media cache</h4>
    <ul>
      <li>Blob storage to store all media.</li>
    </ul> -->

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>
    <ul>
      <li>Redundant servers and data replication.</li>
      <li>Load balancer.</li>
    </ul>

    <h4 class="card-title">Reliability</h4>

    <h4 class="card-title">Scalability</h4>
    <ul>
      <li>Independent components can scale independently.</li>
    </ul>

    <h4 class="card-title">Performance</h4>
    <ul>
      <li>Cache servers.</li>
      <li>CDN.</li>
    </ul>

  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-57">
  <div class="card-body">
    <h2 class="card-title">Instagram</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Users can upload, download, and view photos and vidoes.</li>
      <li>Users can search based on photo and video titles.</li>
      <li>Users can follow other users.</li>
      <li>Users can like/dislike posts.</li>
      <li>User feed is generated consisting of top photos of all users that the user follows.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <ul>
        <li>Consistency can take hit in the interest of high availability.</li>
      </ul>
      <li>Reliability.</li>
      <ul>
        <li>Photos and videos cannot be lost.</li>
        <li>Tolerate hardware and software failures.</li>
      </ul>
      <li>Scalability.</li>
      <ul>
        <li>Supports hundreds of millions of users.</li>
      </ul>
      <li>Performance.</li>
      <ul>
        <li>Maximum 200ms latency for feed generation.</li>
      </ul>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>100M daily active users.</li>
        <li>A single server can handle 10K connections.</li>
      </ul>
      <li>100M / 10K = 10,000 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>2M new photos per day.</li>
        <li>Average photo size 1MB.</li>
        <li>1M new videos per day.</li>
        <li>Average photo size 10MB.</li>
      </ul>
      <li>2M * 1MB + 1M * 10MB = 2TB + 10TB = 12TB per day.</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Read-write ratio is 100:1.</li>
      </ul>
      <li>Incoming: 12TB per day * 8 / 86400 = 1.1Gbps.</li>
      <li>Outgoing: 1.1Gbps * 100 = 111Gbps.</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>User uploads images/videos and they are stored in blob.</li>
      <li>User searches for images/videos stored in blob/db.</li>
      <li>Follower is notified of the images/videos uploads.</li>
      <li>Feed is generated for users.</li>
      <li>User likes posts in the feed.</li>
    </ul>

    <h3 class="card-title">API</h3>
    <ul>
      <li>post_media(user_id, media_type)</li>
      <li>search_photo(user_id, keyword)</li>
      <li>follow_user(user_id, target_user_id)</li>
      <li>view_feed(user_id)</li>
      <li>like_post(user_id, target_user_id, post_id)</li>
    </ul>

    <h3 class="card-title">DB</h3>
    <ul>
      <li>Store metadata in relational db because data is inherently relational.</li>
      <li>Need to index on (photo_id, creation_date) since we want to fetch recent photos.</li>
      <li>Store photos in distributed file storage like HDFS or S3.</li>
    </ul>

    <h4 class="card-title">User</h4>
    <ul>
      <li>user_id (int, pk)</li>
      <li>name (varchar)</li>
      <li>email (varchar)</li>
      <li>creation_date (datetime)</li>
    </ul>

    <h4 class="card-title">User follow</h4>
    <ul>
      <li>follower_id (int, PK)</li>
      <li>followee_id (int, PK)</li>
    </ul>

    <h4 class="card-title">Photo</h4>
    <ul>
      <li>photo_id (int, pk)</li>
      <li>user_id (int)</li>
      <li>photo_path (varchar)</li>
      <li>photo_latitude (int)</li>
      <li>photo_longitude (int)</li>
      <li>creation_date (datetime)</li>
    </ul>

    <h3 class="card-title">Component design</h3>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/instagram1.png" alt="Card image cap">
    <br>
    <br>

    <h4 class="card-title">The service will be read heavy</h4>
    <ul>
      <li>Dediciated servers for read and write such that</li>
      <ul>
        <li>Write operations don't hog the system and disrupt read operations.</li>
        <li>Scale and optimize independently.</li>
      </ul>
      <li>Redundancy is needed not to lose photos and for high availability of all other components.</li>
    </ul>

    <h4 class="card-title">News feed generation</h4>
    <ul>
      <li>Fetch a list of users that current user folows. Submit photos of those list of users to ranking algorithms and generate the feed. However, this will cause latency.</li>
      <li>Have dedicated server to continuously pre-generate user feed into "User feed" table.</li>
    </ul>

    <h4 class="card-title">News feed update</h4>
    <ul>
      <li>Pull: client pulls news feed from server at regular interval. Most of time, client will receive in empty response.</li>
      <li>Push: server pushes news feed to client whenever there is update. Servers may end up frequently updating client.</li>
    </ul>

    <h4 class="card-title">Fetch latest photos</h4>
    <ul>
      <li>Sort photos based on creation_date.</li>
      <li>Make creattion_date part of photo_id, which is indexed. (For example, epoch time + auto-incrementing ID from key generation service)</li>
    </ul>

    <h4 class="card-title">Data partitioning</h4>
    <ul>
      <li>Partition photos into different DBs based on PhotoID (For example, PhotoId % 10), which can be generated by key generation service.</li>
      <li>In the beginning, we can put all DBs into a single server. As the service scales, we can migrate DB to addition DB server one by one.</li>
    </ul>

    <h4 class="card-title">Video and photo storage, and media cache</h4>
    <ul>
      <li>Cache servers: CDN.</li>
      <li>Application servers: use LRU eviction policy.</li>
    </ul>

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>
    <ul>
      <li>Replicate app servers and DB servers.</li>
    </ul>

    <h4 class="card-title">Reliability</h4>
    <ul>
      <li>Database supporting replication and redundancy.</li>
      <li>Load balancer reroutes requests around failed servers.</li>
    </ul>

    <h4 class="card-title">Scalability</h4>
    <ul>
      <li>Horizontally scale read and write app servers independently.</li>
    </ul>

    <h4 class="card-title">Performance</h4>
    <ul>
      <li>Use CDN.</li>
      <li>Use cache on read app servers.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-58">
  <div class="card-body">
    <h2 class="card-title">TinyURL</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Given a URL, generate a short version.</li>
      <li>When users click short link, redirect them to original link.</li>
      <li>User can generate custom short link.</li>
      <li>User can delete short link.</li>
      <li>User can update original URL associated with short link.</li>
      <li>Link should expire after certain time.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability</li>
      <li>Reliability</li>
      <li>Scalability</li>
      <li>Performance</li>
      <ul>
        <li>Low latency.</li>
        <li>Short link must not be predictable.</li>
      </ul>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>10M daily active users</li>
        <li>A single server can handle 10K connections.</li>
      </ul>
      <li>10M / 10K = 1,000 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>100:1 read:write ratio.</li>
        <li>100M read (redirect to original) and 1M write (shorten the URL) per month.</li>
        <li>Store URL shortening request for 5 years.</li>
        <li>Each object is around 1KB.</li>
      </ul>
      <li>Total number of objects to store: 1M * 5 years * 12 months = 60M.</li>
      <li>Total storage: 60M * 1kB = 60B.</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>URL shortening per second: 1M / (30 days * 24 hrs * 3600 seconds) = 0.386 URLs/s.</li>
      <li>URL redirections per second: 100M / (30 days * 24 hrs * 3600 seconds) = 38.6k URLs/s.</li>
      <li>Write: 0.386 * 1kB * 8 = 3Kbps.</li>
      <li>Read: 38.2 * 1kB * 8 = 300Kbps.</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>User posts original URL and gets shortened URL.</li>
      <li>User clicks shortened URL and gets redirected to original URL.</li>
      <li>User deletes an existing short URL.</li>
      <li>User requests for a custom URL.</li>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/tinyurl1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">API</h3>
    <ul>
      <li>short_url(original_url)</li>
      <li>redirect_url(shortened_url)</li>
      <li>delete_url(shortened_url)</li>
    </ul>

    <h3 class="card-title">DB</h3>
    <ul>
      <li>Need to store users.</li>
      <li>Need to store mapping between original URL and short URL.</li>
      <li>Since there is no relationship between records and ready heavy, No SQL should be chosen. (MongoDB)</li>
    </ul>

    <h4 class="card-title">URL</h4>
    <ul>
      <li>shortened_url_hash (varchar, PK)</li>
      <li>original_url (varchar)</li>
      <li>user_id (int)</li>
      <li>creation_date (datetime)</li>
    </ul>

    <h4 class="card-title">User</h4>
    <ul>
      <li>user_id (int, pk)</li>
      <li>name (varchar)</li>
      <li>email (varchar)</li>
      <li>creation_date (datetime)</li>
    </ul>

    <h3 class="card-title">Component design</h3>

    <h4 class="card-title">Encode the URL</h4>
    <ul>
      <li>Want to generate characters at the end of the URL.</li>
      <li>Assume base64 encoding</li>
      <ul>
        <li>6 letters 64^6 = 68.7 billion possible strings.</li>
        <li>8 letters 64^8 = 281 trillion possible strings.</li>
      </ul>
      <li>Duplication: if multiple users enter the same URL, they can get the same shortened URL, which is not good.</li>
    </ul>

    <h4 class="card-title">Key generating service</h4>
    <ul>
      <li>Generates random 6 letter strings and store them in key DB.</li>
      <li>What is two or more servers are trying the use the same key?</li>
      <ul>
        <li>One table for keys not in used, one table for keys in use.</li>
        <li>Load some keys in memory to give to the servers and at the same time move them to "Used" table.</li>
        <ul>
          <li>If servers die, we lose keys. But that is okay given we've got enough keys to cover shortening requests.</li>
        </ul>
      </ul>
      <li>DB size: 6 (characters per key) * 68.7 billion (unique keys) = 412GB</li>
      <li>Single point of failure? Use replicas.</li>
    </ul>

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>
    <ul>
      <li>App servers and DBs can be replicated.</li>
      <li>Rate limiter limits resource allocation for each user.</li>
      <li>Global load balancer to route traffic to app servers in closest regions.</li>
    </ul>

    <h4 class="card-title">Reliability</h4>

    <h4 class="card-title">Scalability</h4>
    <ul>
      <li>Consistent hashing to distribute data shards.</li>
      <li>Separate read and write server.</li>
      <li>NoSQL DB like MongoDB.</li>
    </ul>

    <h4 class="card-title">Performance</h4>
    <ul>
      <li>MongoDB has low latency and high throughput.</li>
      <li>Distributed cache like Memcached</li>
      <li>NoSQL DB like MongoDB.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-59">
  <div class="card-body">
    <h2 class="card-title">Web crawler</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Crawl all the web. (HTML and HTTP protocol only)</li>
      <li>Store contents of URL in blob storage.</li>
      <li>Regular scheduling to update records in blob storage.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <li>Performance.</li>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>100ms to traverse one page.</li>
        <li>100ms * 15B = 1.5Bs = 17,361 days.</li>
      </ul>
      <li>To crawl the web in one day, we need 17,361 servers.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>15B HTML pages.</li>
        <li>Page size including metadata is 100KB on average.</li>
      </ul>
      <li>15B * 100KB = 1.5PB.</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>1.5PB * 8 / 86400 = 139Gbps.</li>
      <li>139Gbps / 17361 = 8Mbps per server.</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>Worker gets a URL to work on.</li>
      <li>DNS is resolved to provide the IP address.</li>
      <li>Download the document.</li>
      <li>Parse document contents to look for new URLs.</li>
      <li>Add new URLs to unvisited URL list.</li>
      <li>Process downloaded document.</li>
    </ul>

    <h3 class="card-title">API</h3>

    <h3 class="card-title">DB</h3>

    <h3 class="card-title">Component design</h3>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/web-crawler1.png" alt="Card image cap">
    <br>
    <br>

    <h4 class="card-title">URL frontier (priority queue)</h4>
    <ul>
      <li>Contains all the remaining URLs to download.</li>
      <li>Prioritize which URLs should be downloaded first.</li>
      <li>Use BFS implemented by a queue.</li>
      <li>Distributed into multiple servers.</li>
      <ul>
        <li>Each server maintains many queues such that each thread gets a queue.</li>
        <li>Hash table maps carnonical hostname to thread number that run the queue.</li>
      </ul>
      <li>Due to huge size of URLs, need to store URLs into a disk.</li>
      <ul>
        <li>Enqueue buffer, once filled, is dumped into disk.</li>
        <li>Dequeue buffer keeps cache of URLs to be visited. It periodically reads from disk to fill the buffer.</li>
      </ul>
    </ul>

    <h4 class="card-title">Relational DB</h4>
    <ul>
      <li>Stores all the URLs with two associated parameters "priority" and "update frequency".</li>
    </ul>

    <h4 class="card-title">DNS resolver</h4>
    <ul>
      <li>Custom DNS resolver is needed because DNS lookup is time consuming process.</li>
      <li>Cache frequently used IP addresses within their TTL.</li>
    </ul>

    <h4 class="card-title">HTML fetcher</h4>
    <ul>
      <li>Downloads documents corresponding to givne URL using protocol like HTTP.</li>
    </ul>

    <h4 class="card-title">Service host</h4>
    <ul>
      <li>Each worker dequeues URL from the URL frontier.</li>
      <li>Each worker uses DNS resolver to acquire web page's IP address.</li>
    </ul>

    <h4 class="card-title">Document input stream</h4>
    <ul>
      <li>Cache used to store the extracted document.</li>
      <li>Prevents downloading the same document again.</li>
    </ul>

    <h4 class="card-title">Duplicate eliminator</h4>
    <ul>
      <li>Checks if document is duplicate.</li>
      <li>Calculates 64-bit checksum of every processed document using MD5 or SHA and store it in DB.</li>
    </ul>

    <!-- <h4 class="card-title">URL filter</h4>
    <ul>
      <li>Blocks some websites so that crawler can ignore them.</li>
    </ul>

    <h4 class="card-title">URL de-dup</h4>
    <ul>
      <li>Check if URL is duplicates. (Multiple URL linking to the same document)</li>
      <li>Store checksum of URLs in carnonical forms into DB.</li>
    </ul> -->

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>

    <h4 class="card-title">Reliability</h4>

    <h4 class="card-title">Scalability</h4>
    <ul>
      <li>Data partitioning</li>
      <ul>
        <li>Distribute based on hostname which contains URLs to visit, URL checksum, document checksum.</li>
      </ul>
    </ul>

    <h4 class="card-title">Performance</h4>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-60">
  <div class="card-body">
    <h2 class="card-title">Typeahead</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Suggests top 10 terms starting with whatever user has typed.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <li>Performance.</li>
      <ul>
        <li>Users should see suggestions within 200ms.</li>
      </ul>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>3.5B queries per day = 40,509 queries per second.</li>
        <li>A single server can handle 10K connections.</li>
      </ul>
      <li>5 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>There are 3.5B queries per day.</li>
        <li>There are 2B unique queries out of 3.5B per day.</li>
        <li>Each query has 15 characters on average.</li>
        <li>Each character requires 2 bytes to store.</li>
      </ul>
      <li>2B per day * 15 * 2 = 60GB per day.</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Suggestions have the same length, which is 15 chracters.</li>
        <li>Top 10 suggestions are shown to users.</li>
      </ul>
      <li>Incoming: 3.5B * 15 * 2 * 8 / 86400 = 9.7Mbps</li>
      <li>Outgoing: 10 * 15 * 9.7Mbps = 1.46Gbps</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>Top 10 suggesstions are queried from Redis cache.</li>
      <li>User searches are stored in NoSQL DB.</li>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/typeahead1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">API</h3>
    <ul>
      <li>get_suggestions(prefix)</li>
      <li>add_to_database(query)</li>
    </ul>

    <h3 class="card-title">DB</h3>

    <h3 class="card-title">Component design</h3>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/typeahead2.png" alt="Card image cap">
    <br>
    <br>

    <h4 class="card-title">Suggestion service</h4>
    <ul>
      <li>Returns top 10 from cache. (Redis)</li>
    </ul>

    <h4 class="card-title">Collection service</h4>
    <ul>
      <li>Stores metadata about user query.</li>
    </ul>

    <h4 class="card-title">Aggregator</h4>
    <ul>
      <li>Retrieves data from HDFS and distributes to different workers.</li>
    </ul>

    <h4 class="card-title">Trie builder</h4>
    <ul>
      <li>Creat/update tries.</li>
    </ul>

    <h4 class="card-title">Trie structure</h4>
    <ul>
      <li>Store this data structure in memory. (Not in DB)</li>
      <li>Assume case insensitive.</li>
      <li>For example, when user types "CAP", node "P" will show all suggestions.</li>
    </ul>

    <h4 class="card-title">How to find top suggestions</h4>
    <ul>
      <li>Store the number of searches in the last phrase.</li>
      <li>Parent nodes recursively call child nodes to get suggestions and counts.</li>
    </ul>

    <h4 class="card-title">How to update trie</h4>
    <ul>
      <li>Spread copies of tries on each server and update them offline. (While some nodes are serving the traffic)</li>
      <li>Also, remove inappropriate terms from the tries duing this time.</li>
      <li>Also, update frequency at each node.</li>
    </ul>

    <h4 class="card-title">Client behavior</h4>
    <ul>
      <li>Client should hit the server only when no key has been pressed for 50ms.</li>
      <li>When user is typing, client should cancel in-progress request.</li>
      <li>Client should wait until at least few characters are entered in the beginning.</li>
      <li>Client can store recent history of top suggestions.</li>
      <li>Establish connection between client and server as soon as browser opens up.</li>
      <li>Server should push some part of cache to CDNs.</li>
    </ul>

    <h4 class="card-title">Data partitioning</h4>
    <ul>
      <li>Range based partitioning</li>
      <ul>
        <li>Pick storage based on starting character of queries.</li>
        <li>Results in uneven servers.</li>
        <li>There will be hot servers.</li>
        <li>May not be able to fit the size of data into each server.</li>
      </ul>
      <li>Hash based partitioning</li>
      <ul>
        <li>Each term gets a server number from hash function.</li>
        <li>Minimize hot servers.</li>
        <li>Must query all servers and aggregate the result.</li>
      </ul>
    </ul>

    <h4 class="card-title">Caching</h4>
    <ul>
      <li>Cache servers in front of trie servers with frequenctly searched terms and their typeahead suggestions.</li>
      <li>App servers should check cache servers before hitting trie servers.</li>
    </ul>

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>

    <h4 class="card-title">Reliability</h4>

    <h4 class="card-title">Scalability</h4>

    <h4 class="card-title">Performance</h4>

  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-61">
  <div class="card-body">
    <h2 class="card-title">Whatsapp</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Supports 1-on-1 conversation between users.</li>
      <li>Persists chat history.</li>
      <li>Acknowledgs sent, delivered, and read.</li>
      <li>Supports sharing of images and videos.</li>
      <li>Notifies offline users of new messages when they come online.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <ul>
        <li>Can be compromised for causal consistency.</li>
      </ul>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <li>Performance.</li>
      <ul>
        <li>Users should receive messages with low latency.</li>
      </ul>
      <li>Security.</li>
      <ul>
        <li>Messages must be secured.</li>
      </ul>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>2B connections per day.</li>
        <li>A single server can handle 10M connections per day.</li>
      </ul>
      <li>2B/10M = 200 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>100 B messages per day.</li>
        <li>Each message is 100 bytes.</li>
        <li>Whatsapp keeps messages for 30 days only.</li>
      </ul>
      <li>100 B per day * 100 bytes = 10 TB per day.</li>
      <li>300 TB per month</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>Incoming: 10 TB per day * 8 bits / 86400 seconds per day = 926 Mbps.</li>
      <li>Outgoing: 10 * 15 * 9.7Mbps = 1.46 Gbps</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>When user A sends a message to user B</li>
      <ul>
        <li>Server receives the message and send ack back to A.</li>
        <li>Server stores the message into DB and sends message to B.</li>
        <li>B receives the message and sends ack back to the server.</li>
        <li>Server notifies A that the message has been delivered.</li>
      </ul>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/whatsapp1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">API</h3>
    <ul>
      <li>send_msessage(sender_ID, reciever_ID, type, text=none, media_object=none)</li>
      <li>get_message(user_Id)</li>
      <li>upload_file(file_type, file)</li>
      <li>download_file(user_id, file_id)</li>
    </ul>

    <h3 class="card-title">DB</h3>
    <ul>
      <li>RDBMS (MySQL) or NoSQL (MongoDB) are not good because we need to do frequent read/write.</li>
      <li>Choose wide-column DB like HBase. HBase stores data into memory buffer and move data into disk when buffer is full. This works well with variable-sized data.</li>
      <li>Store multiple copies of data in different servers.</li>
    </ul>

    <h3 class="card-title">Component design</h3>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/whatsapp2.png" alt="Card image cap">
    <br>
    <br>

    <h4 class="card-title">Websocket server</h4>
    <ul>
      <li>Web socket server keeps connection open with all active users.</li>
      <li>These servers provide a port to every online user.</li>
      <li>Web socket manager maintains mapping between port and user.</li>
    </ul>

    <h4 class="card-title">Message service</h4>
    <ul>
      <li>Interface to Mnesia DB.</li>
      <li>store and retriev messages from Mnesia DB.</li>
    </ul>

    <h4 class="card-title">Asset service</h4>
    <ul>
      <li>Similar to message service, but for files.</li>
    </ul>

    <h4 class="card-title">Group service</h4>
    <ul>
      <li>Keep all information about users in each group.</li>
      <li>store and retriev messages from Mnesia DB.</li>
    </ul>

    <h4 class="card-title">Group message handler</h4>
    <ul>
      <li>Similar to Websocket server, but for group messages.</li>
    </ul>

    <h4 class="card-title">Kafka</h4>
    <ul>
      <li>Message service sends messages to Kafka, to be saved for further processing.</li>
    </ul>

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>
    <ul>
      <li>Websocket servers are replicated.</li>
    </ul>

    <h4 class="card-title">Reliability</h4>

    <h4 class="card-title">Scalability</h4>

    <h4 class="card-title">Performance</h4>
    <ul>
      <li>Low latency via web socket servers and cache.</li>
      <li>Low latency via CDN.</li>
    </ul>

  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-62">
  <div class="card-body">
    <h2 class="card-title">Google doc</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Multiple users can view/edit documents simultaneously.</li>
      <li>Chaged made by a user should be propagated to other users.</li>
      <li>Resolve conflicts when many users are updating the same portion.</li>
      <li>Users can see view count of the document.</li>
      <li>Users can see history of collaboration of the document.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <li>Performance.</li>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>100 M active users.</li>
        <li>A single server can handle 10k connections per day.</li>
      </ul>
      <li>100M / 10k = 10,000 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Each user creates 1 doc per day.</li>
        <li>100 M active users.</li>
        <li>Each doc is 1MB.</li>
      </ul>
      <li>1 per day * 100 M * 1 MB = 100 TB per day.</li>
      <li>300TB per month</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Each user views 5 doc per day.</li>
        <li>5 * 100 M / 86400 = 5787 doc views per second.</li>
        <li></li>
      </ul>
      <li>Incoming: 100 TB per day * 8 bits / 86400 seconds per day = 9.26 Gbps.</li>
      <li>Outgoing: 5787 * 1 MB * 8 = 46 Gbps.</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>When users collaborate, request is forwarded to operations queue. Conflict gets resolved here and data is batched.</li>
      <li>Different versions of document is stored in time series DB.</li>
      <li>Async operations like view count and comments are queued in pub-sub like Kafka.</li>
      <li>App server supports document import/export.</li>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/google-doc1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">API</h3>

    <h3 class="card-title">DB</h3>

    <h3 class="card-title">Component design</h3>

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>

    <h4 class="card-title">Reliability</h4>

    <h4 class="card-title">Scalability</h4>

    <h4 class="card-title">Performance</h4>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-100">
  <div class="card-body">
    <h2 class="card-title">Google search</h2>
    <ul>
      <li>A general search engine like Google.</li>
    </ul>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Training</h4>
    <ul>
      <li>Split training data and validation data by time.</li>
    </ul>

    <h4 class="card-title">Inference</h4>
    <ul>
      <li>Serving: low latency (50ms - 100ms) for search ranking.</li>
    </ul>

    <h3 class="card-title">Estimation</h3>
    <ul>
      <li>How many websites to search from? Billions of documents.</li>
      <li>How many requests per second? 10K queries per second.</li>
      <li>Assume user is logged in and historical search data of user is available.</li>
    </ul>

    <h3 class="card-title">Metric</h3>

    <h4 class="card-title">Online</h4>
    <ul>
      <li>Click through rate</li>
      <ul>
        <li>(number of clicks / number of impressions or views)</li>
        <li>Unsuccessful clicks would also be part of this metric.</li>
      </ul>
      <li>Session success rate</li>
      <ul>
        <li>Dwell time: time user spent viewing a page.</li>
        <li>(number of sucessful sessions (dwell time &gt; 10s) / number of total sessions)</li>
      </ul>
      <li>Time to success</li>
      <ul>
        <li>Low number of quries means the system was good at guess what user wanted.</li>
      </ul>
    </ul>

    <h4 class="card-title">Offline</h4>
    <ul>
      <li>Ground truth: actual outputs desired by the system. In this case, it is the rating provided by humans.</li>
      <li>Assume the search engine returns documents \( D1, D2, D3, D4 \) in the order of relevance.</li>
      <li>Assume human rates the documents on scale of 0-3 (3 is highly relevant, 0 is merely relevant) such that</li>
      <ul>
        <li>\( D1=3, D2=2, D3=3, D4=0 \)</li>
      </ul>
      <li>Cumulative gain simply adds</li>
      <ul>
        <li>\( 3 + 2 + 3 + 0 = 8 \)</li>
      </ul>
      <li>Discounted cumulative gain (DCG) penalizes if highly relevant document appears lower in the result.</li>
      <ul>
        <li>\( 3/log(1+1) + 2/log(2+1) + 3/log(3+1) + 0/log(4+1) = 3 + 1.262 + 1.5 + 0 = 5.762 \)</li>
      </ul>
      <li>Normalized discounted cumulative gain (NDCG) is computed by (DCG / IDCG) where IDCG is DCG of ideal ordering.</li>
      <ul>
        <li>Caveat: NDCG does not penalize irrelevant search result.</li>
        <li>As remedy, human rater could assign negative store to irrelvant document.</li>
      </ul>
    </ul>

    <h3 class="card-title">Architecture</h3>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/google-search1.png" alt="Card image cap">
    <br>
    <br>

    <h4 class="card-title">Query rewriting</h4>
    <ul>
      <li>Spell checker: fix basic spelling mistakes.</li>
      <li>Query expansion: add terms to user query. For example, "restaurant" is expaneded to "food" or "recipe".</li>
    </ul>

    <h4 class="card-title">Query understanding</h4>
    <ul>
      <li>Query "gas stations" most likely has local intent.</li>
      <li>Query "earthquake" may have newsy intent.</li>
    </ul>

    <h4 class="card-title">Document selection</h4>
    <ul>
      <li>Focuses on recall.</li>
      <li>Select set of documents that are relevant to query.</li>
    </ul>

    <h4 class="card-title">Ranker</h4>
    <ul>
      <li>Find the best order of documents.</li>
    </ul>

    <h4 class="card-title">Blender</h4>
    <ul>
      <li>Provides various results like posts, images, news, videos.</li>
      <li>Avoid displaying results from a single or few sources.</li>
      <li>Outputs final result page to users.</li>
    </ul>

    <h4 class="card-title">Training data generation</h4>
    <ul>
      <li>Generate positive and negative example from online data.</li>
    </ul>

    <h4 class="card-title">Feature pipeline</h4>
    <ul>
      <li>Process online features.</li>
    </ul>

    <h4 class="card-title">Feature store</h4>
    <ul>
      <li>Need low latency (<10ms) to access features before scoring. (MySQL, Redis, DynamoDB)</li>
    </ul>

    <h4 class="card-title">Model Store</h4>
    <ul>
      <li>Distributed storage like S3</li>
    </ul>

    <h3 class="card-title">Feature engineering</h3>

    <h4 class="card-title">Searcher (Assume the user is logged in)</h4>
    <ul>
      <li>Age</li>
      <li>Gender</li>
      <li>Interest</li>
    </ul>

    <h4 class="card-title">Query</h4>
    <ul>
      <li>History</li>
      <ul>
        <li>For example, query "earthquake" historically was related to recent news.</li>
      </ul>
      <li>Intent</li>
      <ul>
        <li>For example, query "Pizza places" has "local" intent, thus should give higher rank to pizza places located nearby the searcher.</li>
      </ul>
    </ul>

    <h4 class="card-title">Document</h4>
    <ul>
      <li>Page rank</li>
      <ul>
        <li>For example, the number of quality documents that link to it.</li>
      </ul>
      <li>Radius</li>
      <ul>
        <li>For example, coffee shop in Toronto is relevant to people in 10km radicus but Eiffel tower has global scope.</li>
      </ul>
    </ul>

    <h4 class="card-title">Context</h4>
    <ul>
      <li>Time of day</li>
      <ul>
        <li>For example, query "restaurant" should consider restaurant open at the time of query.</li>
      </ul>
      <li>Recent query</li>
      <ul>
        <li>Take a look at previous quries. For example, "python" -> "python list"</li>
      </ul>
    </ul>

    <h4 class="card-title">Searcher-document</h4>
    <ul>
      <li>Distance</li>
      <ul>
        <li>For queries regarding locations, consider distance between searcher and matching location.</li>
      </ul>
      <li>History</li>
      <ul>
        <li>For example, if searcher looked for video document in the past, then vidoe document would be more relevant to the searcher.</li>
      </ul>
    </ul>

    <h4 class="card-title">Query-document</h4>
    <ul>
      <li>Text match</li>
      <ul>
        <li>Matches in the title, metadata, content of document.</li>
      </ul>
      <li>N-gram match</li>
      <ul>
        <li>For example, "Seattle tourism guide". Find text match for the combinations of three words.</li>
        <li>TF-IDF</li>
        <ul>
          <li>TF: (Term Frequency) importance of each term in the document.</li>
          <li>IDF: (Inverse Document Frequency) how much information a particular term provides.</li>
        </ul>
      </ul>
      <li>Click rate</li>
      <ul>
        <li>User's historical engagement with document.</li>
      </ul>
      <li>Embeddings</li>
      <ul>
        <li>Find relationship between query and document.</li>
        <li>Similarity score is computed between query vector and each document vector.</li>
      </ul>
    </ul>

    <h3 class="card-title">Training data generation</h3>

    <h4 class="card-title">Binary classification (pointwise approach)</h4>
    <ul>
      <li>Document is either relevant or irrevant.</li>
      <ul>
        <li>If user spent some time in the document, mark it relevant.</li>
        <li>If user immediate backed after clicking the document, mark it irrelevant.</li>
      </ul>
      <li>We may never get enough negative examples.</li>
      <ul>
        <li>Maybe treat all document displayed in 50th page in Google as negative.</li>
      </ul>
    </ul>

    <h4 class="card-title">Train / test split</h4>
    <ul>
      <li>Use the first two weeks of data for training.</li>
      <li>Use the third week of data for validation and test.</li>
    </ul>

    <h4 class="card-title">Document ordering (pairwise approach)</h4>
    <ul>
      <li>The goal is to minimize inversion. (number of wrong orders compared to ground truth)</li>
      <li>Rank the document based on user activity on each document and use that as training data.</li>
    </ul>

    <h3 class="card-title">Document selection</h3>
    <ul>
      <li>Inverted index</li>
      <ul>
        <li>Map words to documents.</li>
      </ul>
      <li>Selection criteria</li>
      <ul>
        <li>Go to index and retrive all documents based on this criteria.</li>
      </ul>
      <li>Scoring scheme</li>
      <ul>
        <li>Personalization measures searcher's profile such as age, gender, interest, location.</li>
      </ul>
    </ul>

    <h3 class="card-title">Ranker</h3>
    <ul>
      <li>Stage1</li>
      <ul>
        <li>Find subset of document that should be passed to stage 2.</li>
        <li>Use simpler algorithm like logistic regression to do binary classification.</li>
        <li>Objective function takes pointwise approach.</li>
      </ul>
      <li>Stage2</li>
      <ul>
        <li>Perform complex algorithm like LambdaMART (If using offline NDCG, which is based on human-rated data) or LambdaRank (If using online training data) to do document ordering.</li>
        <li>Objective function takes pairwise approach.</li>
        <ul>
          <li>Get as many pairs of document in the right order as possible.</li>
        </ul>
      </ul>
    </ul>

    <h3 class="card-title">Filter</h3>
    <ul>
      <li>Filter inappropriate result despite good user engagement.</li>
      <li>Training data can come from human raters and/or online feedback.</li>
      <li>Extra features could be considered such as</li>
      <ul>
        <li>Website historical report rate</li>
        <li>Sexually explicit terms used</li>
        <li>Domain name</li>
        <li>Website description</li>
        <li>Images used on the website</li>
      </ul>
      <li>Use classification to determine if result inappropriate or not.</li>
    </ul>

  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/become-a-machine-learning-engineer">Become a Machine Learning Engineer</a>
  </div>
</div>

<div class="card mb-4" id="system-design-101">
  <div class="card-body">
    <h2 class="card-title">Twitter feed</h2>
    <ul>
      <li>Design a Twitter feed system.</li>
      <li>Reverse chronological order fails to catch most engaging tweets due to the sheer large number of tweets.</li>
    </ul>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Training</h4>
    <ul>
      <li>Retrain the models (incrementally) multiple times per day.</li>
      <li>Personalization.</li>
      <li>Avoid showing repetitive feed.</li>
    </ul>

    <h4 class="card-title">Inference</h4>
    <ul>
      <li>Feed Ranking needs to return within 50ms.</li>
      <li>Data pipelines need to run really fast.</li>
    </ul>

    <h3 class="card-title">Estimation</h3>
    <ul>
      <li>500M daily active users.</li>
      <li>1 user is connected to 100 users.</li>
      <li>User fetches the feed 10 times a day.</li>
      <ul>
        <li>We run Tweet ranking algorithm 5B times per day.</li>
      </ul>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>1B positive labels and 100B negative labels.</li>
      <li>Hundreds of features per data point and each row takes 500 bytes.</li>
      <li>120B rows per month.</li>
      <li>Total: 500 * 120 * 10^9 = 60 * 10^12 bytes = 60TB. Move data past 6 months to cold storage to save cost.</li>
    </ul>

    <h3 class="card-title">Metric</h3>

    <h4 class="card-title">Positive user actions</h4>
    <ul>
      <li>Time spent viewing Tweets.</li>
      <li>Liking Tweets.</li>
      <li>Re-Tweeting.</li>
      <li>Commenting on Tweets.</li>
    </ul>

    <h4 class="card-title">Negative user actions</h4>
    <ul>
      <li>Hiding Tweets.</li>
      <li>Reporting Tweets as inappropriate.</li>
    </ul>

    <h4 class="card-title">Weighted user actions</h4>
    <ul>
      <li>Not all actions are equal value.</li>
    </ul>

    <h3 class="card-title">Architecture</h3>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/twitter-feed1.png" alt="Card image cap">
    <br>
    <br>

    <h4 class="card-title">Tweet selection</h4>
    <ul>
      <li>Fetches a pool of Tweets from the user network since the last login.</li>
    </ul>

    <h4 class="card-title">Ranker</h4>
    <ul>
      <li>Predict Tweets probability of engagement.</li>
    </ul>

    <h4 class="card-title">Training data generation</h4>
    <ul>
      <li>Each user engagement action results in positive and negative examples.</li>
    </ul>

    <h3 class="card-title">Feature engineering</h3>

    <h4 class="card-title">User-author historical relations</h4>
    <ul>
      <li>author_liked_posts_3months</li>
      <ul>
        <li>Percentage of author Tweets user liked in the last 3 months.</li>
      </ul>
      <li>author_liked_posts_count_1year</li>
      <ul>
        <li>Number of author Tweets user liked in the past one year.</li>
      </ul>
    </ul>

    <h4 class="card-title">User-author similarity</h4>
    <ul>
      <li>common_followees</li>
      <ul>
        <li>Numbers of users and hash tags followed by bothN</li>
      </ul>
      <li>topic_similarity</li>
      <ul>
        <li>Similarity between hash tags in the posts that both interacted.</li>
      </ul>
      <li>tweet_content_embedding_similarity</li>
      <ul>
        <li>Generate embedding (bag-of-words) for every user and take dot product between them.</li>
      </ul>
      <li>social_embedding_similarity</li>
      <ul>
        <li>Every user is represented by bag-of-ids (rather than bag-of-words)</li>
      </ul>
    </ul>

    <h4 class="card-title">Author influence</h4>
    <ul>
      <li>is_verified</li>
      <ul>
        <li>If author is verifiedI</li>
      </ul>
      <li>author_social_rank</li>
      <ul>
        <li>Similar to Google page rank.</li>
      </ul>
      <li>author_num_followers</li>
      <ul>
        <li>Nubmer of followers that author has.</li>
      </ul>
      <li>follower_to_following_ratio</li>
    </ul>

    <h4 class="card-title">Author Tweets historical trend</h4>
    <ul>
      <li>author_engagement_rate_3months</li>
      <ul>
        <li>(Tweets-interactions) / (Tweets-views)</li>
      </ul>
      <li>author_topic_engagement_rate_3months</li>
      <ul>
        <li>Compute similar feature above but per topic.</li>
      </ul>
    </ul>

    <h4 class="card-title">User-tweet</h4>
    <ul>
      <li>topic_similarity</li>
      <ul>
        <li>Similarity between hashtags and contents that user tweeted in the past and the Tweet itself.</li>
      </ul>
      <li>embedding_similarity</li>
      <ul>
        <li>Dot product between user and Tweet vector.</li>
      </ul>
    </ul>

    <h4 class="card-title">Tweet content</h4>
    <ul>
      <li>Tweet_length</li>
      <ul>
        <li>Concise Tweet has higher chance of getting likes.</li>
      </ul>
      <li>Tweet_recency</li>
      <ul>
        <li>People are interested in latest Tweets.</li>
      </ul>
      <li>is_image_video</li>
      <ul>
        <li>Tweets with image or video are more catchy.</li>
      </ul>
      <li>is_URL</li>
      <ul>
        <li>Tweets with URL have higher probability of engagement.</li>
      </ul>
    </ul>

    <h4 class="card-title">Tweet interaction</h4>
    <ul>
      <li>num_total_interactions</li>
      <ul>
        <li>Need to use time decay model to give proper attention to trending Tweets.</li>
      </ul>
      <li>likes_in_last_3_days</li>
      <li>comments_in_last_1_day</li>
      <li>reshares_in_last_2_hours</li>
      <li>likes_in_last_3_days_user’s_network_only</li>
      <li>comments_in_last_1_day_user’s_network_only</li>
      <li>reshares_in_last_2_hours_user’s_network_only</li>
    </ul>

    <h4 class="card-title">Context based features</h4>
    <ul>
      <li>day_of_week</li>
      <li>time_of_day</li>
      <li>current_user_location</li>
      <li>season</li>
      <li>lastest_k_tag_interactions</li>
      <li>approaching_holiday</li>
    </ul>

    <h4 class="card-title">Sparse features</h4>
    <ul>
      <li>unigrams/bigrams of a Tweet</li>
      <li>user_id</li>
      <li>tweets_id</li>
    </ul>

    <h3 class="card-title">Training data generation</h3>

    <h4 class="card-title">If single model</h4>
    <ul>
      <li>All Tweets with user interation will be postive examples.</li>
      <li>All Tweeks with only impressions will be negative examples.</li>
    </ul>

    <h4 class="card-title">If many models</h4>
    <ul>
      <li>Tweets with "likes" will be positive and Tweets without "likes" will be negative.</li>
      <li>Tweets with "comments" will be positive and Tweets without "comments" will be negative.</li>
      <li>And so on.</li>
    </ul>

    <h4 class="card-title">Balancing positive and negative examples</h4>
    <ul>
      <li>Randomly downsample to match the number of positive and negative examples.</li>
    </ul>

    <h4 class="card-title">Train/dev/test</h4>
    <ul>
      <li>Train data on one time interval and validate data on next time interval.</li>
    </ul>

    <h3 class="card-title">Tweet selection</h3>

    <h4 class="card-title">Consider new Tweets</h4>
    <ul>
      <li>Tweets generated between user's log out and log in.</li>
      <li>Previous Tweets viewed by user, which was not popular but now is popular.</li>
      <li>Previous Tweets not viewed by user while user was logged in.</li>
    </ul>

    <h4 class="card-title">User comes back after a while</h4>
    <ul>
      <li>There will be limits of Tweet data to fetch.</li>
      <li>Need to fetch certain numbers of Tweets from a pool.</li>
    </ul>

    <h4 class="card-title">Tweets outside the user network</h4>
    <ul>
      <li>Aligns with user interests.</li>
      <li>Locally/globally trending.</li>
      <li>Tweet is relevant to user's network.</li>
    </ul>

    <h3 class="card-title">Ranking</h3>
    <ul>
      <li>Given Tweets, predict probabilities of likes, comments, and re-Tweets.</li>
      <li>This is classification problem.</li>
    </ul>

    <h4 class="card-title">Logistic regression</h4>
    <ul>
      <li>Must create feature in training data manually. (Tree and NN are able to learn features)</li>
      <li>Single model to predict overall engagement or separate models to predict different types of engagement.</li>
    </ul>

    <h4 class="card-title">Deep learning</h4>
    <ul>
      <li>Hyperparameters</li>
      <ul>
        <li>Learning rate</li>
        <li>Number of hidden layers</li>
        <li>Batch size</li>
        <li>Number of epochs</li>
        <li>Dropout rate</li>
      </ul>
      <li>Multi task NN where total_loss = like_loss + comment_loss + retweet_loss</li>
      <li>Better than training sepearate network for each task because shared layers make training faster.</li>
    </ul>

    <h4 class="card-title">Stacking models</h4>
    <ul>
      <li>Use Tree and NN to generate features to use in logistic regression.</li>
      <ul>
        <li>For example, use outputs of last hidden layer as input of logistic regression.</li>
        <li>Online learning: update model based on user action.</li>
      </ul>
    </ul>

    <h3 class="card-title">Diversity</h3>
    <ul>
      <li>Introduce penalty for same authors and similar content.</li>
      <ul>
        <li>For example, add negative score for repeated author and contents.</li>
      </ul>
    </ul>

    <h3 class="card-title">Online experimentation</h3>
    <ul>
      <li>Use training and validation data to train 15 different models.</li>
      <li>Use test data to select the best model offline.</li>
      <li>Do A/B testing between the best offline model and online model.</li>
      <ul>
        <li>Before testing, retrain the best offline model with the latest data.</li>
        <li>Select 1% of users. Use existing model to one half of 1% of users. Use the best offline model to the other half of 1% of users.</li>
        <li>Compare user engagement</li>
        <ul>
          <li>Use statistical significance. (Ex. p-value)</li>
          <li>Also, consider if new model causes the system to be more complex.</li>
        </ul>
      </ul>
    </ul>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/become-a-machine-learning-engineer">Become a Machine Learning Engineer</a>
  </div>
</div>

<div class="card mb-4" id="system-design-102">
  <div class="card-body">
    <h2 class="card-title">Netflix</h2>
    <ul>
      <li>Give a user and context (time, location, etc) predict probability of engagement for each movie, and order movies.</li>
      <li>Will use implicit feedback (user watched the movie or not) rathen explicit feedback (user rated the movie) to gather large training data.</li>
    </ul>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Training</h4>
    <ul>
      <li>Train many times during the day to capture temporal changes.</li>
    </ul>

    <h4 class="card-title">Inference</h4>
    <ul>
      <li>Latency needs to be under 200ms.</li>
      <li>Balance between exploitation (relevancy) and exploration (fresh new content)</li>
    </ul>

    <h3 class="card-title">Estimation</h3>
    <ul>
      <li>1B total users.</li>
      <li>150M video views per month.</li>
      <li>10% of videos are watched from 15M recommendations.</li>
      <li>User sees 100 videos on homepage.</li>
      <li>User watches 2 out of 100 recommendations.</li>
      <li>If user does not click video in 10 minutes, it is missed recommendation.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>15B positive labels and 750B negative labels per month.</li>
      <li>Hundreds of features per data point, costing 500 bytes.</li>
      <li>800B row of data point per month.</li>
      <li>Total: 500 * 800 * 10^9 = 4 * 10^14 bytes = 0.4PB per month. Keep old data past 6 months to cold storage to save cost.</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>Generate recommendation for 10M users per second.</li>
      <li>Each request will generate ranks for 1k-10k videos.</li>
    </ul>

    <h3 class="card-title">Metric</h3>

    <h4 class="card-title">Online</h4>
    <ul>
      <li>Use A/B testing to compare.</li>
      <li>Engagement rate: (user clicked a movie / total number of sessions)</li>
      <li>Videos watched: count videos user watched at least for some time.</li>
      <li>Session watch time: overall time that user spent watching movies based on recommendation in a session.</li>
    </ul>

    <h4 class="card-title">Offline</h4>
    <ul>
      <li>Mean Average Precision (mAP @ N)</li>
      <ul>
        <li>Precision = number of relevant recommendations / total number of recommendations</li>
        <li>Measures how system performs overall.</li>
      </ul>
      <li>Mean Average Recall (mAR @ N)</li>
      <ul>
        <li>Recall = number of relevant recommendations / number of all movies</li>
        <li>Measures how many top recommendation (based on historical data) that system can put in the recommendation list.</li>
      </ul>
      <li>F1 score = 2 * (mAP*mAR) / (mAP+mAR)</li>
      <li>Ranking loss, and logloss.</li>
    </ul>

    <h3 class="card-title">Architecture</h3>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/netflix1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">Feature engineering</h3>

    <h4 class="card-title">User</h4>
    <ul>
      <li>age</li>
      <li>gender</li>
      <li>language</li>
      <li>country</li>
      <li>average_session_time</li>
      <li>last_genre_watched</li>
      <li>user_actor_histogram</li>
      <ul>
        <li>Histogram showing historical interaction between users and actors in movies.</li>
      </ul>
      <li>user_genre_histogram</li>
      <li>user_language_histogram</li>
    </ul>

    <h4 class="card-title">Context</h4>
    <ul>
      <li>season_of_the_year</li>
      <li>upcoming_holiday</li>
      <li>days_to_upcoming_holiday</li>
      <li>time_of_day</li>
      <li>day_of_week</li>
      <li>device</li>
    </ul>

    <h4 class="card-title">Media</h4>
    <ul>
      <li>public-platform-rating</li>
      <li>revenue</li>
      <li>time_passed_since_release_date</li>
      <li>time_on_platform</li>
      <li>media_watch_history</li>
      <li>genre</li>
      <li>movie_duration</li>
      <li>content_set_time_period</li>
      <li>content_tags</li>
      <li>show_season_number</li>
      <li>country_of_origin</li>
      <li>release_country</li>
      <li>release_year</li>
      <li>release_type</li>
      <li>maturity_rating</li>
    </ul>

    <h4 class="card-title">User-media</h4>
    <ul>
      <li>user_genre_historical_interaction_3months</li>
      <li>user_genre_historical_interaction_1year</li>
      <li>user_and_movie_embedding_similarity</li>
      <li>user_actor</li>
      <li>user_director</li>
      <li>user_language_match</li>
      <li>user_age_match</li>
    </ul>

    <h4 class="card-title">Sparse feature</h4>
    <ul>
      <li>movie_id</li>
      <li>title_of_media</li>
      <li>synopsis</li>
      <li>original_title</li>
      <li>distributor</li>
      <li>creator</li>
      <li>original_language</li>
      <li>director</li>
      <li>first_release_year</li>
      <li>music_composer</li>
      <li>actors</li>
    </ul>

    <h3 class="card-title">Training data generation</h3>
    <ul>
      <li>User watched 80% or more of the movie? positive example.</li>
      <li>User watched 10% or less of the movie? negative example.</li>
      <li>Between 10% and 80%? uncertain example.</li>
      <li>Make sure to downsample over-represented class.</li>
    </ul>

    <h3 class="card-title">Candidate generation</h3>
    <ul>
      <li>Select top K movies to recommend to user.</li>
      <li>Focuses on recall.</li>
    </ul>

    <h4 class="card-title">Collaborative filtering</h4>
    <ul>
      <li>Find similar users to active user based on historical watches.</li>
      <li>User and media profiles do not require domain knowledge.</li>
      <li>Has cold start problem</li>
      <ul>
        <li>It is hard to find similar users to current user who had historical interactions.</li>
        <li>Cannot recommend new movies because they do not have user feedback yet.</li>
      </ul>
    </ul>

    <h4 class="card-title">Nearest neighborhood</h4>
    <ul>
      <li>Computationally expensive.</li>
      <li>Task is to predict the feedback for movies that users haven't watched.</li>
    </ul>

    <h4 class="card-title">Content-based filtering</h4>
    <ul>
      <li>Make recommendations based on content of media that user had already interacted with.</li>
      <li>User and media profiles require some domain knowledge. (Can get this by asking user preference when they sign up)</li>
      <li>Does not have cold start problem.</li>
    </ul>

    <h4 class="card-title">Two options for recommending media to user (Given TD-IDF representation for each movie)</h4>
    <ul>
      <li>Similarity with historical interactions.</li>
      <ul>
        <li>Recommend movies similar to movies that user watched in the past.</li>
        <li>Compute by taking dot product between movies.</li>
      </ul>
      <li>Similarity between media and user profiles.</li>
    </ul>

    <h4 class="card-title">Embedding-based similarity</h4>
    <ul>
      <li>Use deep learning to generate latent vectors/embeddings to represent both movies and users.</li>
      <li>Then, use KNN to find movies to recommend.</li>
      <li>Has cold start problem</li>
      <ul>
        <li>If any one of user or movie is new, then fewer feedbacks are available.</li>
        <li>In other words, there is lack of training example to update user and movie embedding vectors.</li>
      </ul>
    </ul>

    <h3 class="card-title">Ranking</h3>
    <ul>
      <li>Probability of user watching a media.</li>
      <li>Focuses on precision.</li>
    </ul>

    <h4 class="card-title">Logistic regression</h4>
    <ul>
      <li>When training data is limited.</li>
    </ul>

    <h4 class="card-title">Deep learning</h4>
    <ul>
      <li>When 100M data is available.</li>
    </ul>

    <h4 class="card-title">Two sparse features to consider</h4>
    <ul>
      <li>Videos user watched in the past.</li>
      <li>User's search terms.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/become-a-machine-learning-engineer">Become a Machine Learning Engineer</a>
  </div>
</div>

<div class="card mb-4" id="system-design-103">
  <div class="card-body">
    <h2 class="card-title">Tesla</h2>
    <ul>
      <li>Design a self-driving car system focusing on semantic image segmentation.</li>
    </ul>

    <h4 class="card-title">Scope</h4>
    <ul>
      <li>Object detection</li>
      <ul>
        <li>Identify objects by drawing bounding boxes.</li>
      </ul>
      <li>Semantic segmentation</li>
      <ul>
        <li>Pixel-wise classification of image.</li>
      </ul>
    </ul>

    <h4 class="card-title">Not in scope</h4>
    <ul>
      <li>Instance segementation</li>
      <ul>
        <li>Semantic segmentation does not differentiate instance of the same class.</li>
        <li>Combines object detection and semantic segmentation.</li>
        <li>Detects object and then classifies its pixels.</li>
      </ul>
      <li>Scene understanding</li>
      <li>Movement plan</li>
    </ul>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Training</h4>

    <h4 class="card-title">Inference</h4>

    <h3 class="card-title">Estimation</h3>

    <h3 class="card-title">Metric</h3>

    <h4 class="card-title">Online</h4>
    <ul>
      <li>Driver's manual intervention would be negative example.</li>
    </ul>

    <h4 class="card-title">Offline</h4>
    <ul>
      <li>Intersection over union (IoU) = (area of overlap / area of union)</li>
      <li>IoU is computed for each class, then averaged.</li>
    </ul>

    <h4 class="card-title">Historical example</h4>
    <ul>
      <li>Use expert drivers scene recording at ground truth.</li>
    </ul>

    <h3 class="card-title">Architecture</h3>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/tesla1.png" alt="Card image cap">
    <br>
    <br>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/tesla2.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">Training data generation</h3>
    <ul>
      <li>Human labeled data.</li>
      <li>Open source dataset.</li>
      <li>GAN</li>
      <ul>
        <li>Generate new training images.</li>
      </ul>
      <li>cGAN</li>
      <ul>
        <li>Ensure generated images have different weather conditions.</li>
      </ul>
    </ul>

    <h3 class="card-title">Modeling</h3>

    <h4 class="card-title">Fully convolutional network</h4>
    <ul>
      <li>Used for semantic segmentation.</li>
      <li>Fine-tune an image classification CNN and apply pixel-wise training.</li>
      <li>First, compress information via convolutions and poolings.</li>
      <li>Then, up-sample these feature maps to predict each pixel class.</li>
    </ul>

    <h4 class="card-title">U-Net</h4>
    <ul>
      <li>Built upon FCN with modifications.</li>
      <li>Require less training examples.</li>
      <li>First, down-sample convolutional features via pooling.</li>
      <li>Then, up-sample feature maps to generate segmentation maps.</li>
    </ul>

    <h4 class="card-title">Mask R-CNN</h4>
    <ul>
      <li>Combines</li>
      <ul>
        <li>Faster R-CNN: object detectection and localization.</li>
        <li>FCN: pixel-wise instance segmentation of objects.</li>
      </ul>
    </ul>

    <h4 class="card-title">Action predictor makes movement decision based on</h4>
    <ul>
      <li>Outputs of all visual understanding subtasks.</li>
      <li>Vehicle movements based on previous scene understanding.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/become-a-machine-learning-engineer">Become a Machine Learning Engineer</a>
  </div>
</div>

<div class="card mb-4" id="system-design-104">
  <div class="card-body">
    <h2 class="card-title">Entity linking</h2>

    <h3 class="card-title">Problem</h3>
    <ul>
      <li>Named entity recognition</li>
      <ul>
        <li>Detect person, organization, location, etc.</li>
      </ul>
      <li>Disambiguation</li>
      <ul>
        <li>Map each detected entity to corresponding entity in knowledge base.</li>
        <li>For example, "Michael Jordan is a machine learning professor at UC Berkeley."</li>
        <ul>
          <li>Michael Jordan linked to the professor at the University of California, Berkeley entity in the knowledge base.</li>
          <li>UC Berkeley is linked to the University of California entity in the knowledge base.</li>
        </ul>
      </ul>
    </ul>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Training</h4>

    <h4 class="card-title">Inference</h4>

    <h3 class="card-title">Estimation</h3>

    <h3 class="card-title">Metric</h3>
    <ul>
      <li>There will be separate metric for each of three components</li>
      <ul>
        <li>Named entity recognition</li>
        <li>Disambiguation</li>
        <li>Entity linking as a whole</li>
      </ul>
    </ul>

    <h4 class="card-title">Named entity recognition (Offline)</h4>
    <ul>
      <li>Precision = # of correctly recognized named entities / # of total recognized named entitied</li>
      <li>Recall = # of correctly recognized named entities / # of named entities in corpus</li>
      <li>F1 score = 2 * precision * recall / (precision + recall)</li>
    </ul>

    <h4 class="card-title">Disambiguation (Offline)</h4>
    <ul>
      <li>Recall doesn't make sense.</li>
      <li>Precision = # of mentions correctly linked / # of total mentions</li>
    </ul>

    <h4 class="card-title">Micro average (Offline)</h4>
    <ul>
      <li>Aggregates contributions of all documents to compute average.</li>
      <li>Precision = sum of TP / (sum of TP + sum of FP)</li>
      <li>Recall = sum of TP / (sum of TP + sum of FN)</li>
      <li>Micro-averaged F1-score is computed using above.</li>
    </ul>

    <h4 class="card-title">Macro average (Offline)</h4>
    <ul>
      <li>Computes metrics independently for each document and takes the average.</li>
      <li>Precision = sum of Precision over documents / n</li>
      <li>Recall = sum of Recall over documents / n</li>
      <li>Macro-averaged F1-score is computed using above.</li>
    </ul>

    <h3 class="card-title">Architecture</h3>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/entity-linking1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">Training data generation</h3>
    <ul>
      <li>Named entity recognition</li>
      <ul>
        <li>CoNLL-2003</li>
      </ul>
      <li>Disambiguation</li>
      <ul>
        <li>AIDA CoNLL-YAGO Dataset</li>
      </ul>
    </ul>

    <h3 class="card-title">Modeling</h3>
    <ul>
      <li>Traditional word embedding like Word2vec does not understand the context.</li>
    </ul>

    <h4 class="card-title">ELMo (Embeddings from Language Models)</h4>
    <ul>
      <li>Starts with something like Word2vec.</li>
      <li>Raw vectors are fed into bidirectional LSTM layer.</li>
      <li>Forward and backward LSTMs are trained independently.</li>
      <li>Word representations cannot take advantage of left and right context simultaneously.</li>
    </ul>

    <h4 class="card-title">BERT (Bidirectional encoder representations from transformers)</h4>
    <ul>
      <li>Take input sentenses, which can be multiple sentences separated by SEP tag.</li>
      <li>Each word is converted to embedding and fed into transformer encoder layer.</li>
      <li>All words are processed simultaneously in the layer.</li>
      <li>Final transformer layer outputs the contextualized representation of each word.</li>
    </ul>

    <h4 class="card-title">NER modelling</h4>
    <ul>
      <li>Option 1. Use embeddings generated by BERT as features in NER modelling.</li>
      <li>Option 2. Take pre-trained models and fine-tune them based on NER dataset.</li>
    </ul>

    <h4 class="card-title">Disambiguation modeling</h4>

    <h5 class="card-title">Candidate generation</h5>
    <ul>
      <li>Build an index where terms are mapped to knowledge base entities.</li>
      <li>Index should include all terms that could possibly refer to an entity.</li>
    </ul>

    <h5 class="card-title">Linking</h5>
    <ul>
      <li>Build a model that gives the probability of a candidate being true match for a recognized entity.</li>
      <li>Inputs to this model should be represented by BERT/ELMo embeddings.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/become-a-machine-learning-engineer">Become a Machine Learning Engineer</a>
  </div>
</div>

<div class="card mb-4" id="system-design-105">
  <div class="card-body">
    <h2 class="card-title">Ad prediction</h2>
    <ul>
      <li>Predict the probability of user engagement with an AD given context (query, device, etc)</li>
    </ul>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Training</h4>
    <ul>
      <li>Handle highly imbalanced data.</li>
      <li>Retrain models many times within one day.</li>
      <li>Training data and validation data is partitioned by time.</li>
    </ul>

    <h4 class="card-title">Inference</h4>
    <ul>
      <li>Low latency (50ms - 100ms) for ad prediction.</li>
      <li>Recommendation latency for ML model needs to be fast.</li>
    </ul>

    <h3 class="card-title">Estimation</h3>
    <ul>
      <li>100B ad requests per month.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Hundreds of features per data point and each row is 500 bytes.</li>
      <li>1B clicked ads.</li>
      <li>100 * 10^12 * 500 = 5 * 10^16 = 50PB.</li>
      <li>Use 1 week of data for training and use the next day for validation.</li>
    </ul>

    <h3 class="card-title">Metric</h3>

    <h4 class="card-title">Offline</h4>
    <ul>
      <li>AUC (Area under curve)</li>
      <ul>
        <li>Common metric for binary classification.</li>
        <li>Does not penalize how far off predicted score is from the actual label.</li>
        <li>Insensitive to well-calibrated probabilities.</li>
      </ul>
      <li>Log loss (Cross-entropy loss)</li>
      <ul>
        <li>Calibration sensitive metric.</li>
        <li>Captures what degree expected probabilities diverge from class label.</li>
        <li>Sensitive to background CTR.</li>
      </ul>
      <li>Normalized Cross-Entropy</li>
      <ul>
        <li>Predictive logloss divided by the cross-entropy of the background CTR.</li>
        <li>This way NCE is insensitive to background CTR.</li>
      </ul>
    </ul>

    <h4 class="card-title">Online</h4>
    <ul>
      <li>Revenue, which is the sum of winning bid value.</li>
      <ul>
        <li>If bid is 1 and user clicks the Ad, advertisement is charged 1.</li>
        <li>Advertiser is not charged unless users click the AD.</li>
      </ul>
      <li>Counter metric</li>
      <ul>
        <li>Hide the AD.</li>
        <li>Never see the AD.</li>
        <li>Report AD as inappropriate.</li>
      </ul>
    </ul>

    <h3 class="card-title">Architecture</h3>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/ad-prediction1.png" alt="Card image cap">
    <br>
    <br>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/ad-prediction2.png" alt="Card image cap">
    <br>
    <br>

    <h4 class="card-title">Auction</h4>
    <ul>
      <li>AD rank score = (AD predicted score * bid)</li>
      <li>Cost per engagement = (AD rank of AD below / AD rank score) + 0.01</li>
      <li>AD will cost the minimum price that wins the auction.</li>
    </ul>

    <h4 class="card-title">When user issues a query</h4>
    <ul>
      <li>AD selection selects all ADs matching the targeting criteria and predict AD relevance score using simple model.</li>
      <li>AD selection also ranks the ADs and sends top ADs to AD prediction.</li>
      <li>AD prediction uses ML model to predict precisely calibrated score.</li>
      <li>AD auction uses bid and predicted score to pick the top most relevant ADs shown to users.</li>
    </ul>

    <h3 class="card-title">Feature engineering</h3>

    <h4 class="card-title">Ad</h4>
    <ul>
      <li>ad_id</li>
      <li>ad_content_raw_terms</li>
      <li>historical_engagement_rate</li>
      <ul>
        <li>ad_engagement_history_last_24_hrs</li>
        <li>ad_engagement_history_last_7_days</li>
      </ul>
      <li>ad_impression</li>
      <li>ad_negative_engagement_rate</li>
      <li>ad_embedding</li>
      <li>ad_age</li>
      <li>ad_bid</li>
    </ul>

    <h4 class="card-title">Advertiser</h4>
    <ul>
      <li>advertiser_domain</li>
      <li>historical_engagement_rate</li>
      <li>region_wise_engagement</li>
    </ul>

    <h4 class="card-title">User</h4>
    <ul>
      <li>user_previous_search_terms</li>
      <li>user_search_terms</li>
      <li>age</li>
      <li>gender</li>
      <li>language</li>
      <li>embedding_last_k_ads</li>
      <li>engagement_content_type</li>
      <li>engagement_days</li>
      <li>platform_time_spent</li>
      <li>region</li>
    </ul>

    <h4 class="card-title">Context</h4>
    <ul>
      <li>current_region</li>
      <li>time</li>
      <li>device</li>
      <ul>
        <li>screen_size</li>
      </ul>
    </ul>

    <h4 class="card-title">User-ad</h4>
    <ul>
      <li>embedding_similarity</li>
      <li>region_wise_engagement</li>
      <li>user_ad_category_histogram</li>
      <li>user_ad_subcategory_histogram</li>
      <li>user_gender_ad_histogram</li>
      <li>user_age_ad_histogram</li>
    </ul>

    <h4 class="card-title">User-advertiser</h4>
    <ul>
      <li>embedding_similarity</li>
      <li>user_gender_advertiser_histogram</li>
      <li>user_age_advertiser_histogram</li>
    </ul>

    <h3 class="card-title">Training data generation</h3>

    <h4 class="card-title">Positive</h4>
    <ul>
      <li>Clicks the AD.</li>
      <li>Add item to cart.</li>
    </ul>

    <h4 class="card-title">Negative</h4>
    <ul>
      <li>Ignore the AD.</li>
      <li>Negative feedback on AD.</li>
    </ul>

    <h4 class="card-title">Model recalibration</h4>
    <ul>
      <li>Downsample negative examples because it is likely that 98% of data would be negative.</li>
      <li>Recalibration is needed such that</li>
      <ul>
        <li>q = p / ( p + (1-p)/w )</li>
        <li>q is re-calibrated prediction score.</li>
        <li>p is prediction in downsampling space.</li>
        <li>w is downsampling rate.</li>
      </ul>
    </ul>

    <h4 class="card-title">Train/test</h4>
    <ul>
      <li>Train on first two weeks of data and test on third week of data.</li>
    </ul>

    <h3 class="card-title">Ad selection</h3>

    <h4 class="card-title">1. Selection</h4>
    <ul>
      <li>Build an in-memory index.</li>
      <li>Issue a query to fetch all Ads that are targeted for the current user.</li>
      <ul>
        <li>Ex. Use search term, age, location, gender, etc to fetch the result.</li>
      </ul>
    </ul>

    <h4 class="card-title">2. Narrow down selection</h4>
    <ul>
      <li>Use (bid * prior cost per engagement score) to pick the top selections.</li>
      <ul>
        <li>If no prior score due to being new AD, give slightly higher score.</li>
      </ul>
    </ul>

    <h4 class="card-title">3. Rank using simple model</h4>
    <ul>
      <li>Select top K Ads from the result of the previous step.</li>
      <li>Use logistic regression or additive trees.</li>
      <li>At evaluation, Ads will be ranked basd on (bid * cost per engagement score)</li>
    </ul>

    <h3 class="card-title">Ad prediction</h3>

    <h4 class="card-title">Online learning</h4>
    <ul>
      <li>Refresh model with the latest impression and engagement at regular interval (15min, 30min, etc)</li>
      <ul>
        <li>Train base model and add new examples on top of it.</li>
        <li>Stochastic gradient descent is used.</li>
      </ul>
      <li>Generates the latest training examples using an online joiner.</li>
      <li>Training data generater takes those examples and generates right feature sets.</li>
      <li>Model trainer runs SGD with those examples.</li>
    </ul>

    <h4 class="card-title">Non-linear feature generation</h4>
    <ul>
      <li>Use additive trees and neural network to generate features.</li>
      <li>Use features from above in logistic regression.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/become-a-machine-learning-engineer">Become a Machine Learning Engineer</a>
  </div>
</div>
<!-- System design END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>