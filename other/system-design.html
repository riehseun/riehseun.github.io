<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js"></script>
<script src="/js/bootstrap.bundle.min.js"></script>
<script src="/js/highlight.pack.js"></script>
<script type="text/javascript" src="/js/include_html.js"></script>
<script type="text/javascript" src="/js/site.js"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Other</h1>

<!-- System design BEGIN -->
<div class="card mb-4" id="system-design">
  <div class="card-body">
    <h2 class="card-title">System design</h2>
    <p class="card-text"></p>
    <ul class="list-unstyled mb-0">
      <li><a href="#system-design-1">System design</a></li>
      <li><a href="#system-design-2">Machine learning system design</a></li>
      <li><a href="#system-design-10">Youtube</a></li>
      <li><a href="#system-design-11">Quora</a></li>
      <li><a href="#system-design-12">Google maps</a></li>
      <li><a href="#system-design-13">Yelp</a></li>
      <li><a href="#system-design-14">Uber</a></li>
      <li><a href="#system-design-15">Twitter</a></li>
      <li><a href="#system-design-16">Newsfeed</a></li>
      <li><a href="#system-design-17">Instagram</a></li>
      <li><a href="#system-design-18">TinyURL</a></li>
      <li><a href="#system-design-19">Web crawler</a></li>
      <li><a href="#system-design-20">Typeahead</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="system-design-1">
  <div class="card-body">
    <h2 class="card-title">System design</h2>

    <h3 class="card-title">High level design</h3>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/sd-cicd.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">Component design</h3>

  </div>
  <div class="card-footer text-muted">

  </div>
</div>

<div class="card mb-4" id="system-design-2">
  <div class="card-body">
    <h2 class="card-title">Machine learning system design</h2>

    <h3 class="card-title">High level design</h3>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/ml-highlevel.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">Component design</h3>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/ml-development-v1.png" alt="Card image cap">
    <br>
    <br>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/ml-training-v1.png" alt="Card image cap">
    <br>
    <br>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/ml-inference-batch-v1.png" alt="Card image cap">
    <br>
    <br>
    <ul>
      <li>Performce for out-of-sample and out-of-time.</li>
      <li>Features should be mostly unchanged when input data is slighly perturbed. (Could be challgenging when data contains similar/duplicate features)</li>
      <li>Interpretation should not be depending on training sample choices.</li>
    </ul>

    <h3 class="card-title">Problem definition</h3>
    <ul>
      <li>Construct ground truth.</li>
      <li>Metrics.</li>
    </ul>

    <h3 class="card-title">Data prep</h3>
    <ul>
      <li>Proportion of null/zero values across columns.</li>
      <li>Columns that should be rejected due to zero or null values.</li>
      <li>Categorical columns with high cardinality.</li>
      <li>Columns with high sparcity.</li>
      <li>Duplicate columns.</li>
      <li>Compute per-month count of rows and selected attribute to see if they make sense.</li>
      <li>Verify that join keys are consistent across tables.</li>
      <li>Verify that labels/values to apply exclusions are available in the tables.</li>
      <li>Verify that labels/values to apply ground truth are available in the tables.</li>
      <li>Rectify missing values in columns.</li>
      <ul>
      <li>Random missing value - value is missing for unexplained reason.</li>
      <li>Structural missing value - value is missing for a reason. (For example, the fact that it is missing means something)</li>
      <li>Engineered missing value - feature engineering introduced the missing values. (For example, divide by zero)</li>
      <li>Table join mismatch - IDs in one table were missing in another table, so missing values are created after join.</li>
    </ul>
    </ul>

    <h3 class="card-title">Data profiling</h3>
    <ul>
      <li>General statistics.</li>
      <li>Columns with large portion of missing values. (For example, > 10%)</li>
      <ul>
        <li>These columns should generally be retained for they may turn out to be quite predictive.</li>
        <li>XGBoost has build-in capability to handle missing values.</li>
      </ul>
      <li>Similar/duplicate columns. (For example, prefer one feature over another? Can use univariate analysis)</li>
      <li>Columns with consistant values should be removed because they provide no signal.</li>
      <li>Remove sensitive features from model inputs. (For example, age / gender)</li>
      <li>Data imputation (For example, NULL to 0) should rarely happens when feature is critical and will undergo feature engineering and treatment is known.</li>
    </ul>

    <h3 class="card-title">Exclusion</h3>
    <ul>
      <li>Exclude rows based on certain attributes. (This is driven by business reasons)</li>
    </ul>

    <h3 class="card-title">Ground truth construction</h3>

    <h3 class="card-title">Data split</h3>
    <ul>
      <li>Training: In-Time and In-Sample. Split into 5-folds for cross-validation.</li>
      <li>Testing: Out-of-Time test and In-Time & Out-of-Sample test.</li>
      <li>If a data about person is seen at many different dates, all data about that person must be assigned to the same split. (either Out-of-Sample or one of the folds) Otherwise, there is information leak bwetween training and validation.</li>
      <li>Final model is retrained with all 5 folds combined.</li>
    </ul>

    <h3 class="card-title">Data representativeness</h3>
    <ul>
      <li>Separate datasets by ground truth labels.</li>
      <li>Perform univariate analysis. For example, look at the distribution of samples of a key feature for both the entire dataset and the partitioned dataset. Repeat for all key features.</li>
      <li>All paritioned datasets must include sufficient volume of each ground truth labels across key features.</li>
      <li>Bin size may be increased or bins could be combined as a result of above analysis.</li>
    </ul>

    <h3 class="card-title">Model development</h3>
    <ul>
      <li>Define metric to evaluate the model.</li>
      <li>Score the model by the desired metric.</li>
      <li>Check model performace by month to check seasonality.</li>
      <li>Kubernetes based</li>
      <ul>
        <li>Make changes to code.</li>
        <li>Build, test, package the code.</li>
        <li>Build an image which includes the code package.</li>
        <li>Deploy the image to Kubenetes using tools like Skaffold / Helm.</li>
        <li>Run commands inside the image to execute the code.</li>
      </ul>
      <li>Databricks based</li>
      <ul>
        <li>Make changes to code.</li>
        <li>Build, test, package, publish the code.</li>
        <li>Import the code from the notebook.</li>
        <li>Write additional code on the notebook as needed.</li>
        <li>Run commands on the notebook execute the code.</li>
      </ul>
    </ul>

    <h3 class="card-title">Feature selection</h3>
    <ul>
      <li>Start with initial set of feature ~ 1500</li>
      <li>First gate</li>
      <ul>
        <li>Data preparation</li>
        <li>Feature engineering</li>
      </ul>
      <li>After exclusions ~ 1000</li>
      <li>First stage</li>
      <ul>
        <li>Assess each feature individually.</li>
        <li>Select a metric.</li>
        <li>Use 4-folds for training and 1 fold for validation.</li>
        <li>Train a shallow model with a single feature as input and compute performance in validation set.</li>
        <li>Rank individual features.</li>
        <li>Then, train a model wtih all features.</li>
        <li>Then again, rank the features.</li>
      </ul>
      <ul>
        <li>Perform recursive feature search.</li>
        <li>Use 4-folds for training and 1 fold for validation. (Validation fold must be different from previous step)</li>
        <li>For each feature in top N features, train a model and score performance on validation set.</li>
        <li>Add the best scoring features to the candidate features.</li>
      </ul>
      <li>Candidate features ~ 100</li>
      <li>Second gate</li>
      <ul>
        <li>Highly correlated features should be justified or redundant features should be removed.</li>
        <li>Future retraining starts from the candidate features.</li>
      </ul>
      <li>Second stage</li>
      <ul>
        <li>Perform 5-fold cross validation with each candidate feature.</li>
        <li>Compute shapley values on the validation set.</li>
        <li>Select stable features via union of top features across the folds.</li>
      </ul>
      <li>Stable features ~ 40</li>
    </ul>

    <h3 class="card-title">Hyperparameter tuning</h3>
    <ul>
      <li>Ex. grid search, random search, bayesian optimization.</li>
    </ul>

    <h3 class="card-title">Final model training</h3>
    <ul>
      <li>Train the model using stable features and tuned hyperparameters.</li>
      <li>Evaluate on OOS (seasonality) and OOT (final evaluation) test sets.</li>
    </ul>

    <h3 class="card-title">Monitoring</h3>
    <ul>
      <li>Partial dependency plot (PDP) assesses marginal effect of a feature to the model output.</li>
      <li>Indvidual conditional expectation (ICDE) is equivalent to PDP but for an individual data point.</li>
      <li>Feature contribution is assessed via shapley values.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">

  </div>
</div>

<div class="card mb-4" id="system-design-10">
  <div class="card-body">
    <h2 class="card-title">Youtube</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Users can upload, share, view, like/dislike, search videos.</li>
      <li>Users can add, view comments.</li>
      <li>Users can view thumbnauls, number of views.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <ul>
        <li>Consistency can take a hit.</li>
        <li>Subscribers need not get notifications for uploaded videos immediately.</li>
        <li>No need to show consistent feed for all users.</li>
      </ul>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <li>Performance: users should not feel lag watching videos.</li>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>1B active users and 100M daily active users.</li>
        <li>A single server can handle 10k connections.</li>
      </ul>
      <li>100M / 10k = 10,000 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Each video before encoding is 1GB.</li>
        <li>After encoding, size becomes 100MB.</li>
      </ul>
      <li>100MB per video * 1000 video per minute = 100GB per minute.</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>1000 videos are uploaded every minute.</li>
        <li>Ratio of upload:view is 1:100.</li>
        <ul>
          <li>Every uploaded video gets 100 views.</li>
        </ul>
      </ul>
      <li>Video uploads/writes: 1000 per minute.</li>
      <li>Video views/reads: 1000 * 100 = 100k per minute.</li>
      <li>Incoming (upload): 1G * 1000 = 10TB per minute = 1333 Gbps. (Video is uncompressed during upload)</li>
      <li>Outgoing (stream): 10MB * 100k = 10TB per minute = 1333 Gbps.</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>User uploads video.</li>
      <li>Server sends video to encoder.</li>
      <li>Server sends user data and metadata to DB.</li>
      <li>Encoder encodes video and store it in storage.</li>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/youtube1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">API</h3>
    <ul>
      <li>upload_video(user_id, video_file, title, description, tags, default_language)</li>
      <ul>
        <li>Return 202 on success.</li>
      </ul>
      <li>search_video(user_id, query, user_location, length, max_videos_to_return)</li>
      <ul>
        <li>Return JSON with the list of videos.</li>
      </ul>
      <li>stream_video(user_id, video_id, resolution)</li>
      <ul>
        <li>Return stream.</li>
      </ul>
      <li>like_video(user_id, video_id)</li>
      <li>dislike_video(user_id, video_id)</li>
      <li>view_thunbnail(user_id, video_id)</li>
      <li>comment_video(user_id, video_id, text)</li>
    </ul>

    <h3 class="card-title">DB</h3>
    <ul>
      <li>Store video metadata in relational DB.</li>
    </ul>

    <h4 class="card-title">User</h4>
    <ul>
      <li>id (int, pk)</li>
      <li>name (varchar)</li>
      <li>email (varchar)</li>
      <li>password (varchar)</li>
    </ul>

    <h4 class="card-title">Video</h4>
    <ul>
      <li>id (int, pk)</li>
      <li>title (varchar)</li>
      <li>description (varchar)</li>
      <li>date (datetime)</li>
      <li>uploader (int)</li>
      <li>size (longint)</li>
      <li>thumbnail (varchar)</li>
      <li>likes (int)</li>
      <li>dislikes (int)</li>
      <li>views (int)</li>
    </ul>

    <h4 class="card-title">Comment</h4>
    <ul>
      <li>id (int, pk)</li>
      <li>video_id (int)</li>
      <li>user_id (int)</li>
      <li>comment (varchar)</li>
      <li>date (datetime)</li>
      <li>likes (int)</li>
      <li>dislikes (int)</li>
    </ul>

    <h3 class="card-title">Component design</h3>
    <ul>
      <li>Load balancer: distribute user load.</li>
      <li>Web server: take user request, cache frequently accessed pages. Decouple client request from business logic. Use Lighttpd to run the server for it is fast.</li>
      <li>App server: business logic.</li>
      <li>User DB: user related data, decoupled from metadata storage for easy scalability. Need strong consistency on user data. MySQL.</li>
      <li>Metadata DB: video related data. MySQL.</li>
      <li>Thumbnail DB: BigTable.</li>
      <ul>
        <li>Combines multiple files into one block to store.</li>
        <li>Very efficient for large number of small files with low retrieval latency.</li>
      </ul>
      <li>Encoder: compress vidoes and generate thumbnail.</li>
      <li>Video DB: blob.</li>
      <li>CDN: forward videos to closer proximity to serve users faster.</li>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/youtube2.png" alt="Card image cap">
    <br>
    <br>

    <h4 class="card-title">How to manage read traffic</h4>
    <ul>
      <li>Segregate read traffic and write traffic.</li>
      <li>Distribute read traffic to different servers.</li>
      <li>For video metadata, write to primary and read from secondary.</li>
    </ul>

    <h4 class="card-title">Metadata sharding</h4>
    <ul>
      <li>Store based on UserID? It is hard to maintain uniform distribution because some users upload more than others.</li>
      <li>Store based on VideoID? Solves above problem. Can cache hot vidoes in front of DB servers.</li>
    </ul>

    <h4 class="card-title">Deduplication</h4>
    <ul>
      <li>When users upload vidoes, run video matching algorithm.</li>
    </ul>

    <h4 class="card-title">Search</h4>
    <ul>
      <li>Extract data from each video and store that data into JSON (referred as document)</li>
      <li>Key-value storage is created from the documents.</li>
      <ul>
        <li>Key: all the keywords searched by users.</li>
        <li>Value: occurrence of each key, its frequency, and location of occurrence in the different documents.</li>
      </ul>
      <li>Vidoes with most relevant keywords are returned.</li>
    </ul>

    <h4 class="card-title">Load-balancing</h4>
    <ul>
      <li>Consistent hashing between cache servers.</li>
    </ul>

    <h4 class="card-title">Cache</h4>
    <ul>
      <li>Store hot vidoes in cache servers.</li>
      <li>Use LRU eviction rule.</li>
      <li>Use distributed cache like Memcached.</li>
    </ul>

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>
    <ul>
      <li>Replicate web, app, DB servers.</li>
    </ul>

    <h4 class="card-title">Reliability</h4>
    <ul>
      <li>Data replication.</li>
    </ul>

    <h4 class="card-title">Scalability</h4>
    <ul>
      <li>Horizontally scale web, app servers. (Load balancer can multiplx them)</li>
      <li>Separate read and write to different servers.</li>
    </ul>

    <h4 class="card-title">Performance</h4>
    <ul>
      <li>Lighttpd for serving videos,</li>
      <li>Cache at various component.</li>
      <li>Right DB for different data types for fast operations.</li>
      <li>CDN</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-11">
  <div class="card-body">
    <h2 class="card-title">Quora</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Users can ask questions and provide answers.</li>
      <li>Users can upvote, downvote, and comment on answers.</li>
      <li>Users can search for questions.</li>
      <li>Feed is generated based on user interest.</li>
      <li>Answers are ranked based on usefulness.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability</li>
      <ul>
        <li>Causal consistency must be met between questions and answers and comments and sub-comments.</li>
        <li>No need for all users to see new post immediately.</li>
        <li>No need for feeds to have the same ordering for all users.</li>
      </ul>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <li>Performance.</li>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>1B active users and 100M daily active users.</li>
        <li>A single server can handle 10k connections.</li>
      </ul>
      <li>100M / 10k = 10,000 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Questions, answers, comments all together consume 1KB.</li>
        <li>20% of questions have images and 10% of questions have videos.</li>
        <li>Each image is 1MB and each video is 100MB.</li>
      </ul>
      <li>(100M * 1) * (1KB + 0.2 * 1MB + 0.1 * 100MB) = 1PB per day.</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Each user views 20 questions per day.</li>
        <li>Each user posts 1 question/answer/comment per day.</li>
      </ul>
      <li>Incoming: (1PB per day * bits) / 86400 = 92Gbps.</li>
      <li>Outgoing: 92Gbps * 20 = 1840Gbps. (1:20 ratio between write and read)</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>Load balancer forwards user requests to web servers.</li>
      <li>Web servers generate some part of page (Mostly static content) and application servers generate other part of page. (Mostly dynamic content)</li>
      <li>Questions and answers data is stored in MySQL.</li>
      <li>Images and videos are stored in Blob storage.</li>
    </ul>
    <ul>
      <li>Different features are stored in HBase for each type of question.</li>
      <li>features are forwarded to ML engine to rank the most useful answer.</li>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/quora1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">API</h3>
    <ul>
      <li>post_question(user_id, question, description, video, image)</li>
      <li>post_answer(user_id, question_id, answer_text, video, image)</li>
      <li>upvote(user_id, question_id, answer_id)</li>
      <li>comment(user_id, answer_id, comment_text)</li>
      <li>search(user_id, search_text)</li>
    </ul>

    <h3 class="card-title">DB</h3>

    <h3 class="card-title">Component design</h3>
    <ul>
      <li>Combine web and app servers into one type of powerful machine.</li>
      <li>Replace HBase with MyRocks for lower latency. Also, MyRocks has native integration with MySQL.</li>
      <li>Images and videos are forwarded to CDN.</li>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/quora2.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>
    <ul>
      <li>Replicate powerful machines and DB servers.</li>
    </ul>

    <h4 class="card-title">Reliability</h4>
    <ul>
      <li>Replicate data.</li>
      <li>CDN also serves as backup of data.</li>
    </ul>

    <h4 class="card-title">Scalability</h4>
    <ul>
      <li>Horizontally scale powerful machines. (Load balancer can multiplx them)</li>
      <li>Vertically scale MySQL columns.</li>
      <li>Different DB types for different purpose.</li>
    </ul>

    <h4 class="card-title">Performance</h4>
    <ul>
      <li>MyRocks</li>
      <li>CDN</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-12">
  <div class="card-body">
    <h2 class="card-title">Google Maps</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Users can identify current location.</li>
      <li>Users can find the fastest route between start and end.</li>
      <li>Users can listen to directions.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <li>Performance</li>
      <ul>
        <li>Route and direction should be suggested fast.</li>
        <li>ETA should be accurate.</li>
      </ul>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>1B active users and 100M daily active users.</li>
        <li>A single server can handle 10k connections.</li>
      </ul>
      <li>100M / 10k = 10,000 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Only one time storage is needed in the beginning.</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Each user makes 100 requests per day.</li>
        <li>Each request size is 100 bytes.</li>
        <li>Each response size is 1 KB.</li>
      </ul>
      <li>Incoming: (100M * 100 * 100 bytes * 8) / (24 x 60 x 60) = 92 Mbps.</li>
      <li>Outgoing: 920 Mbps.</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>User enters starting and end point. Starting point can be user's current location.</li>
      <ul>
        <li>User request is forwarded to route finder service.</li>
        <li>Route finder forwards requests to area search service.</li>
        <li>Area search service finds the latitude/longitude for start and end location.</li>
        <li>Graph processing service finds the shortest path and return it to route finder.</li>
      </ul>
      <li>Nagivator updates user location on the map as user is moving. It also provides directions to user.</li>
      <li>When user deviates from the path, Pub-sub alerts area search service to recalculate the optimal path.</li>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/google-map1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">API</h3>
    <ul>
      <li>curr_location(location)</li>
      <ul>
        <li>Returns user location</li>
      </ul>
      <li>find_route(start, end, transport_type)</li>
      <li>directions(curr_location, steps)</li>
    </ul>

    <h3 class="card-title">DB</h3>

    <h4 class="card-title">Key-value store</h4>
    <ul>
      <li>Segment to server</li>
      <ul>
        <li>segment_id (int)</li>
        <li>server_id (int)</li>
      </ul>
      <li>Belongs to segment</li>
      <ul>
        <li>segment_id (int)</li>
        <li>coordinates (list): stores latitude and longitude.</li>
      </ul>
      <li>Neighbors</li>
      <ul>
        <li>segment_id (int)</li>
        <li>neighbors (list): stores a list of segment IDs.</li>
      </ul>
    </ul>

    <h4 class="card-title">Graph DB</h4>
    <ul>
      <li>Graph data</li>
      <ul>
        <li>segment_id (int)</li>
        <li>road_network (graph)</li>
      </ul>
    </ul>

    <h4 class="card-title">Relational DB</h4>
    <ul>
      <li>Rush hour</li>
      <ul>
        <li>segment_id (int)</li>
        <li>edge_id (int)</li>
        <li>hour_range (tuple)</li>
        <li>rush_hour (bool): where there is congestion or not.</li>
      </ul>
    </ul>

    <h3 class="card-title">Component design</h3>

    <h4 class="card-title">Sub-graphs</h4>
    <ul>
      <li>Computing distances between two points on the entire graph is super expensive.</li>
      <li>Precalculate the shortest distance between two points in sub-graphs. Also, cache most requested routes.</li>
      <li>Connect sub-graphs and run the shortest distance algorithm.</li>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/google-map2.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>
    <ul>
      <li>Each segment is processed in a separate server.</li>
      <li>Segments can be replicated.</li>
    </ul>

    <h4 class="card-title">Reliability</h4>

    <h4 class="card-title">Scalability</h4>

    <h4 class="card-title">Performance</h4>
    <ul>
      <li>Use of sub-graphs make computation faster than using entire graph.</li>
      <li>Cache processed sub-graphs</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-13">
  <div class="card-body">
    <h2 class="card-title">Yelp</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Users can search place of interest based on their location.</li>
      <li>Users can post reviews which consists of texts, images, videos.</li>
      <li>Users can add, delete, and update place information.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <ul>
        <li>Should be able to handle peak season.</li>
      </ul>
      <li>Performance</li>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>1B active users and 100M daily active users.</li>
        <li>A single server can handle 10k connections.</li>
      </ul>
      <li>100M / 10k = 10,000 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>100M places.</li>
        <li>Each place need 10KB storage for description text, images, videos. (Image and video are compressed)</li>
        <li>1M reviews are posted per day.</li>
        <li>Each review need 1KB storage for description text, images, videos. (Image and video are compressed)</li>
      </ul>
      <li>100M * 10KB + 1M per day * 1 KB = 1 TB + 1 GB per day ~ 1TB</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>1M reviews are posted per day.</li>
        <li>Each user searches once a day.</li>
        <li>Each search returns 10 pages.</li>
      </ul>
      <li>Incoming: 1M * 1KB * 8 / 86400 = 92 Kbps</li>
      <li>Outgoing: 100M * 1 * 10 * 10KB * 8 / 86400 = 926 Mbps</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>User searches for places.</li>
      <ul>
        <li>Request goes to read servers.</li>
        <li>Key-value store holds segment (map) information.</li>
      </ul>
      <li>User post reviews.</li>
      <ul>
        <li>Images and vidoes go to blob storage.</li>
        <li>Other data goes to relational DB.</li>
        <li>Request goes to write servers.</li>
      </ul>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/yelp1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">API</h3>
    <ul>
      <li>search(category, user_location, radius)</li>
      <ul>
        <li>Search based on category of place. Returns JSON object.</li>
      </ul>
      <li>search(place_name, user_location, radius)</li>
      <ul>
        <li>Search based on name of place. Returns JSON object.</li>
      </ul>
      <li>add_place(place_name, place_description, category, latitude, longitude, photo)</li>
      <li>add_review(place_id, user_id, review_description, rating)</li>
    </ul>

    <h3 class="card-title">DB</h3>
    <ul>
      <li>Relational DB.</li>
    </ul>

    <h4 class="card-title">Place</h4>
    <ul>
      <li>place_id (int, pk)</li>
      <li>place_name (varchar)</li>
      <li>place_description (varchar)</li>
      <li>category (varchar)</li>
      <li>latitude (float)</li>
      <li>longitude (float)</li>
      <li>photo_id (int)</li>
    </ul>

    <h4 class="card-title">Photo</h4>
    <ul>
      <li>photo_id (int, pk)</li>
      <li>place_id (int)</li>
      <li>photo_path (varchar)</li>
    </ul>

    <h4 class="card-title">Review</h4>
    <ul>
      <li>review_id (int, pk)</li>
      <li>place_id (int)</li>
      <li>user_id (int)</li>
      <li>review_description (varchar)</li>
      <li>rating (int)</li>
    </ul>

    <h4 class="card-title">User</h4>
    <ul>
      <li>user_id (int, pk)</li>
      <li>username (varchar)</li>
      <li>password (varchar)</li>
      <li>email (varchar)</li>
    </ul>

    <h3 class="card-title">Component design</h3>

    <h4 class="card-title">Segment</h4>
    <ul>
      <li>Each segment id is mapped to a list of places within that segment.</li>
    </ul>

    <h4 class="card-title">Data partitioning</h4>
    <ul>
      <li>Partition based on place id.</li>
    </ul>

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>
    <ul>
      <li>Horizontal scaling of read / write servers.</li>
    </ul>

    <h4 class="card-title">Reliability</h4>
    <ul>
      <li>Data replication.</li>
    </ul>

    <h4 class="card-title">Scalability</h4>
    <ul>
      <li>Separation of read and write servers so that they can scale independently.</li>
      <li>Data paritioning.</li>
    </ul>

    <h4 class="card-title">Performance</h4>
    <ul>
      <li>Use cashe on read servers.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-14">
  <div class="card-body">
    <h2 class="card-title">Uber</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Users can find nearby drivers.</li>
      <li>Users can request a ride.</li>
      <li>Users can view drivers ETA.</li>
      <li>Users can make payments.</li>
      <li>Drivers can confirm pickup.</li>
      <li>Drivers can end the trip upon arriving at destination.</li>
      <li>Drivers location should be updated regularly.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <li>Performance.</li>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>100M total users, 10M daily active users, 1M drivers</li>
        <li>A single server can handle 10k connections.</li>
      </ul>
      <li>10M / 10k = 1,000 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Each user and driver require 1KB metadata.</li>
        <li>Each driver location requires 1KB metadata.</li>
        <li>Each trip information requires 1KB metadata.</li>
        <li>Each user makes 1 trip per day.</li>
      </ul>
      <li>User and driver: 100M * 1KB + 1M * 1KB = 101GB</li>
      <li>Driver location: 1M * 1KB = 1GB per day</li>
      <li>Trip information: 10M * 1KB = 10GB per day</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Driver location is updated every 2 seconds.</li>
        <li>From 1KB of drivers metadata, 100 bytes are used for driver id and location.</li>
      </ul>
      <li>Incoming (trip information): (10M trips per day / 86400) * 1KB * 8 = 0.926Mbps</li>
      <li>Outgoing (driver location): (1M drivers / 2) * 100B * 8 = 0.926Mbps = 400 Mbps</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>User enters destination.</li>
      <ul>
        <li>App displays avaiable drivers nearby.</li>
        <li>User picks a driver.</li>
        <li>Driver confirms pickup.</li>
        <li>Driver location is updated every 2 seconds.</li>
      </ul>
    </ul>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/uber1.png" alt="Card image cap">
    <br>
    <br>

    <h3 class="card-title">API</h3>
    <ul>
      <li>update_driver_location(driver_id, old_latitude, old_longitude, new_latitude, new_longitude)</li>
      <li>find_nearby_drivers(user_id, latitude, longitude)</li>
      <li>request_ride(user_id, latitude, longitude, dest_latitude, dest_longitude)</li>
      <li>show_eta(driver_ida)</li>
      <li>confirm_pickup(driver_id, rider_id)</li>
      <li>end_trip(trip_id, user_id, driver_id)</li>
    </ul>

    <h3 class="card-title">DB</h3>
    <ul>
      <li>Relational DB for in-progress trips.</li>
      <li>Cassandra for driver’s last location and the trip information after the trip is completed.</li>
    </ul>

    <h4 class="card-title">User</h4>
    <ul>
      <li>user_id (int, pk)</li>
      <li>username (varchar)</li>
      <li>password (varchar)</li>
      <li>email (varchar)</li>
    </ul>

    <h4 class="card-title">Driver</h4>
    <ul>
      <li>driver_id (int, pk)</li>
      <li>name (varchar)</li>
      <li>email (varchar)</li>
      <li>phone (int)</li>
      <li>vechicle_type (varchar)</li>
    </ul>

    <h4 class="card-title">Driver location</h4>
    <ul>
      <li>driver_id (int)</li>
      <li>old_latitude (float)</li>
      <li>new_longitude (float)</li>
      <li>old_latitude (float)</li>
      <li>new_longitude (float)</li>
    </ul>

    <h4 class="card-title">Trip</h4>
    <ul>
      <li>trip_id (int, pk)</li>
      <li>user_id (int)</li>
      <li>driver_id (int)</li>
    </ul>

    <h3 class="card-title">Component design</h3>

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>

    <h4 class="card-title">Reliability</h4>

    <h4 class="card-title">Scalability</h4>

    <h4 class="card-title">Performance</h4>

  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-15">
  <div class="card-body">
    <h2 class="card-title">Twitter</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Users can post new tweets.</li>
      <li>Users can follow other users.</li>
      <li>Users can mark tweets as favs.</li>
      <li>Display users timeline with top tweets.</li>
      <li>Tweets contain photos and videos.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <li>Performance.</li>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>100M daily active users</li>
        <li>A single server can handle 10k connections.</li>
      </ul>
      <li>100M / 10k = 10,000 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>100M Tweets everyday.</li>
        <li>Each Tweet takes up 300 bytes. (Including the metadata)</li>
        <li>Photo in every 5 Tweets with 200KB.</li>
        <li>Video in every 10 Tweets with 2MB.</li>
      </ul>
      <li>Tweet: 100M * 30 bytes = 30GB per day.</li>
      <li>Media: (100M/5) * 200KB + (100M/10) * 2MB = 24TB per day.</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Each user visits their timeline 2 times per day.</li>
        <li>Each user visits 5 other people.</li>
        <li>Each user sees 20 Tweets when visiting a timeline.</li>
        <li>Then, the number of Tweet views per day = 100M * (2+5) * 20 = 14B per day</li>
      </ul>
      <li>Incoming: 24TB per day * 8 / 86400 = 2.2Gbps.</li>
      <li>Outgoing: ( 14B * 300 bytes + (14B/5) * 200 KB + (14B/10) * 2MB ) * 8 / 86400 = 4200 + 560000 + 2800000 = 311.5Gbps</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>User posts Tweets, which is stored in DB.</li>
      <li>Web servers display Tweets.</li>
    </ul>

    <h3 class="card-title">API</h3>
    <ul>
      <li>post_tweet(user_id, tweet_content)</li>
      <li>like_tweet(user_id, tweet_id)</li>
      <li>search_tweet(user_id, search_term)</li>
    </ul>

    <h3 class="card-title">DB</h3>

    <h4 class="card-title">Tweet</h4>
    <ul>
      <li>tweet_id (int, pk)</li>
      <li>user_id (int)</li>
      <li>content (varchar)</li>
      <li>creation_date (datetime)</li>
      <li>num_favorite (int)</li>
    </ul>

    <h4 class="card-title">User</h4>
    <ul>
      <li>user_id (int, pk)</li>
      <li>name (varchar)</li>
      <li>email (varchar)</li>
      <li>creation_date (datetime)</li>
    </ul>

    <h4 class="card-title">User follow</h4>
    <ul>
      <li>user_id1 (int, pk)</li>
      <li>user_id2 (int, pk)</li>
    </ul>

    <h4 class="card-title">Favorite</h4>
    <ul>
      <li>tweet_id (int, pk)</li>
      <li>user_id (int, pk)</li>
      <li>creation_date (datetime)</li>
    </ul>

    <h3 class="card-title">Component design</h3>

    <h4 class="card-title">Data sharding</h4>
    <ul>
      <li>Construct Tweet ID such that</li>
      <ul>
        <li>[epoch_timestamp]-[auto-incrementing-sequence]</li>
        <li>Assign shard based on the second part. (auto-incrementing-sequence)</li>
        <li>Reset auto-incrementing-sequence every second.</li>
      </ul>
      <li>Indexing Tweet ID makes querying the latest Tweets fast.</li>
      <li>Still need to query all the servers for timeline generation.</li>
      <li>Aggregate results from DBs and return it to users.</li>
    </ul>

    <h4 class="card-title">Caching</h4>
    <ul>
      <li>App servers can check cache servers before going to DB.</li>
      <ul>
        <li>Use LRU eviction policy.</li>
      </ul>
      <li>Cache the latest data.</li>
      <ul>
        <li>Hash table where key is UserID and value is doubly linked list containning all Tweets from the user in the past 3 days.</li>
        <li>Always insert new Tweets at the head of doubly linked list.</li>
        <li>Evict Tweets from the tail.</li>
      </ul>
    </ul>

    <h4 class="card-title">Replication</h4>
    <ul>
      <li>Each DB has multiple replicas.</li>
      <li>Writes go to primary and reads go to secondary.</li>
    </ul>

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>

    <h4 class="card-title">Reliability</h4>

    <h4 class="card-title">Scalability</h4>

    <h4 class="card-title">Performance</h4>

  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-16">
  <div class="card-body">
    <h2 class="card-title">Newsfeed</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Feed is generated based on posts from people, pages, groups that user follows.</li>
      <li>User can have/follow many friends, pages, groups.</li>
      <li>Feed can contain images, videos, texts.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <li>Performance.</li>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>100M daily active users</li>
        <li>A single server can handle 10k connections.</li>
      </ul>
      <li>100M / 10k = 10,000 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Each user's feed has 500 posts.</li>
        <li>Each post is 1KB.</li>
      </ul>
      <li>500KB for each user.</li>
      <li>50TB for all users.</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Each user opens app 10 times a day.</li>
      </ul>
      <li>Incoming: 100M * 10 = 1B requests per day.</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>Feed is generated via aggregation.</li>
      <li>Feed is published and stored in cache and DB.</li>
    </ul>

    <h3 class="card-title">API</h3>
    <ul>
      <li>generate_feed(user_id)</li>
      <li>get_feed(user_id, count)</li>
    </ul>

    <h3 class="card-title">DB</h3>
    <ul>
      <li>Use relational database.</li>
      <li>Use a graph database only for the relationships between users.</li>
    </ul>

    <h4 class="card-title">Entity</h4>
    <ul>
      <li>entity_id (int, pk)</li>
      <li>name (varchar)</li>
      <li>name (description)</li>
      <li>creation_date (datetime)</li>
    </ul>

    <h4 class="card-title">User</h4>
    <ul>
      <li>user_id (int, pk)</li>
      <li>name (varchar)</li>
      <li>email (varchar)</li>
      <li>creation_date (datetime)</li>
    </ul>

    <h4 class="card-title">Feed item</h4>
    <ul>
      <li>feed_item_id (int, pk)</li>
      <li>user_id (int)</li>
      <li>entity_id (int)</li>
      <li>content (varchar)</li>
      <li>num_likes (int)</li>
      <li>creation_date (datetime)</li>
    </ul>

    <h4 class="card-title">Media</h4>
    <ul>
      <li>media_id (int, pk)</li>
      <li>description (varchar)</li>
      <li>path (varchar)</li>
      <li>creation_date (datetime)</li>
    </ul>

    <h4 class="card-title">User (Vertex)</h4>
    <ul>
      <li>user_id (int, pk)</li>
      <li>properties (JSON)</li>
    </ul>

    <h4 class="card-title">Relationship (Edge)</h4>
    <ul>
      <li>relation_id (int, pk)</li>
      <li>from (user_id)</li>
      <li>to (user_id)</li>
      <li>properties (JSON)</li>
    </ul>

    <h3 class="card-title">Component design</h3>

    <h4 class="card-title">Feed generation</h4>
    <ul>
      <li>Retrive ID of all users and entities that the user follows.</li>
      <li>Retrive the latest, most popular, most relevant posts for those IDs.</li>
      <li>Rank these posts.</li>
      <li>Store this feed into cache.</li>
      <li>Return top 20 posts to the user.</li>
      <li>Repeat these steps every 5 minutes to check for new posts.</li>
    </ul>

    <h4 class="card-title">Web server</h4>
    <ul>
      <li>Maintain connection with users.</li>
    </ul>

    <h4 class="card-title">Application server</h4>
    <ul>
      <li>Store new posts in DB servers.</li>
      <li>Retrieve and push feeds to users.</li>
    </ul>

    <h4 class="card-title">Metadata DB and cache</h4>
    <ul>
      <li>Store metadata about users, pages, groups.</li>
    </ul>

    <h4 class="card-title">Post DB and cache</h4>
    <ul>
      <li>Store metadata about posts.</li>
    </ul>

    <h4 class="card-title">Video and photo storage, and media cache</h4>
    <ul>
      <li>Blob storage to store all media.</li>
    </ul>

    <h4 class="card-title">Newsfeed generation service</h4>
    <ul>
      <li>Generate feed offline: dedicated servers that generate user feed and store them in memory.</li>
    </ul>

    <h4 class="card-title">Feed notification service</h4>
    <ul>
      <li>Pull: users pull feed at regular interval.</li>
      <li>Push: post is pushed to all followers whenever it is published.</li>
      <li>Celebrity users should have pull model.</li>
    </ul>

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>

    <h4 class="card-title">Reliability</h4>

    <h4 class="card-title">Scalability</h4>

    <h4 class="card-title">Performance</h4>

  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-17">
  <div class="card-body">
    <h2 class="card-title">Instagram</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Users can upload, download, and view photos and vidoes.</li>
      <li>Users can search based on photo and video titles.</li>
      <li>Users can follow other users.</li>
      <li>User feed is generated consisting of top photos of all users that the user follows.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <li>Performance.</li>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>10M daily active users</li>
        <li>A single server can handle 10k connections.</li>
      </ul>
      <li>10M / 10k = 1,000 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>2M new photos per day.</li>
        <li>Average photo size 1MB.</li>
        <li>1M new videos per day</li>
        <li>Average photo size 10MB.</li>
      </ul>
      <li>2M * 1MB + 1M * 10MB = 2TB + 10TB = 12TB per day.</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Read-write ratio is 100:1.</li>
      </ul>
      <li>Incoming: 12TB per day * 8 / 86400 = 1.1Gbps.</li>
      <li>Outgoing: 1.1Gbps * 100 = 111Gbps.</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>User uploads images/videos and they are stored in blob.</li>
      <li>Follower is notificed of the images/videos uploads.</li>
      <li>Feed is generated for users.</li>
    </ul>

    <h3 class="card-title">API</h3>
    <ul>
      <li>post_media(user_id, media_type)</li>
      <li>follow_user(user_id, target_user_id)</li>
      <li>like_post(user_id, target_user_id, post_id)</li>
      <li>search_photo(user_id, keyword)</li>
      <li>view_feed(user_id)</li>
    </ul>

    <h3 class="card-title">DB</h3>
    <ul>
      <li>Need to index on (photo_id, creation_date) since we want to fetch recent photos.</li>
      <li>Store metadata in distributed key-value storage.</li>
      <ul>
        <li>Key: photo_id, value: object containing photo_location.</li>
      </ul>
      <li>Store photos in distributed file storage like HDFS or S3.</li>
    </ul>

    <h4 class="card-title">Photo</h4>
    <ul>
      <li>photo_id (int, pk)</li>
      <li>user_id (int)</li>
      <li>photo_path (varchar)</li>
      <li>photo_latitude (int)</li>
      <li>photo_longitude (int)</li>
      <li>creation_date (datetime)</li>
    </ul>

    <h4 class="card-title">User</h4>
    <ul>
      <li>user_id (int, pk)</li>
      <li>name (varchar)</li>
      <li>email (varchar)</li>
      <li>creation_date (datetime)</li>
    </ul>

    <h4 class="card-title">User follow</h4>
    <ul>
      <li>follower_id (int, PK)</li>
      <li>followee_id (int, PK)</li>
    </ul>

    <h3 class="card-title">Component design</h3>

    <h4 class="card-title">The service will be read heavy</h4>
    <ul>
      <li>Web servers have connection limits.</li>
      <li>Dediciated servers for read and write such that</li>
      <ul>
        <li>Write operations don't hog the system and disrupt read operations.</li>
        <li>Scale and optimize independently.</li>
      </ul>
      <li>Redundancy is needed not to lose photos and for high availability of all other components.</li>
    </ul>

    <h4 class="card-title">News feed generation</h4>
    <ul>
      <li>Fetch a list of users that current user folows. Submit photos of those list of users to ranking algorithms and generate the feed. However, this will cause latency.</li>
      <li>Have dedicated server to continuously pre-generate user feed into "User feed" table.</li>
    </ul>

    <h4 class="card-title">News feed update</h4>
    <ul>
      <li>Pull: client pulls news feed from server at regular interval. Most of time, client will receive in empty response.</li>
      <li>Push: server pushes news feed to client whenever there is update. Servers may end up frequently updating client.</li>
    </ul>

    <h4 class="card-title">Fetch latest photos</h4>
    <ul>
      <li>Sort photos based on creation_date.</li>
      <li>Make creattion_date part of photo_id, which is indexed. (For example, epoch time + auto-incrementing ID from key generation service)</li>
    </ul>

    <h4 class="card-title">Data partitioning</h4>
    <ul>
      <li>Partition photos into different DBs based on PhotoID (For example, PhotoId % 10), which can be generated by key generation service.</li>
      <li>In the beginning, we can put all DBs into a single server. As the service scales, we can migrate DB to addition DB server one by one.</li>
    </ul>

    <h4 class="card-title">Video and photo storage, and media cache</h4>
    <ul>
      <li>Cache servers: CDN.</li>
      <li>Application servers: use LRU eviction policy.</li>
    </ul>

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>

    <h4 class="card-title">Reliability</h4>

    <h4 class="card-title">Scalability</h4>

    <h4 class="card-title">Performance</h4>

  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-18">
  <div class="card-body">
    <h2 class="card-title">TinyURL</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Given a URL, generate a short version.</li>
      <li>When users click short link, redirect them to original link.</li>
      <li>User can generate custom short link.</li>
      <li>User can delete short link.</li>
      <li>User can update original URL associated with short link.</li>
      <li>Link should expire after certain time.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <li>Performance.</li>
      <ul>
        <li>Low latency.</li>
      </ul>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>10M daily active users</li>
        <li>A single server can handle 10k connections.</li>
      </ul>
      <li>10M / 10k = 1,000 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>100:1 read:write ratio.</li>
        <li>100M read (redirect to original) and 1M write (shorten the URL) per month.</li>
        <li>Store URL shortening request for 5 years.</li>
        <li>Each object is around 1KB.</li>
      </ul>
      <li>Total number of objects to store: 1M * 5 years * 12 months = 60M.</li>
      <li>Total storage: 60M * 1kB = 60B.</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>URL shortening per second: 1M / (30 days * 24 hrs * 3600 seconds) = 0.386 URLs/s.</li>
      <li>URL redirections per second: 100M / (30 days * 24 hrs * 3600 seconds) = 38.6k URLs/s.</li>
      <li>Write: 0.386 * 1kB * 8 = 3Kbps.</li>
      <li>Read: 38.2 * 1kB * 8 = 300Kbps.</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>User posts original URL and gets shortened URL.</li>
      <li>User clicks shortened URL and gets redirected to original URL.</li>
    </ul>

    <h3 class="card-title">API</h3>
    <ul>
      <li>short_url(original_url)</li>
      <li>redirect_url(shortened_url)</li>
      <li>delete_url(shortened_url)</li>
    </ul>

    <h3 class="card-title">DB</h3>
    <ul>
      <li>Billions of records.</li>
      <li>Each object is small. (500k)</li>
      <li>Read heavy.</li>
      <li>Since there is no relationship between records, No SQL should be chosen. (Dynamo DB, Cassandra, etc)</li>
    </ul>

    <h4 class="card-title">URL</h4>
    <ul>
      <li>shortened_url_hash (varchar, PK)</li>
      <li>original_url (varchar)</li>
      <li>user_id (int)</li>
      <li>creation_date (datetime)</li>
    </ul>

    <h4 class="card-title">User</h4>
    <ul>
      <li>user_id (int, pk)</li>
      <li>name (varchar)</li>
      <li>email (varchar)</li>
      <li>creation_date (datetime)</li>
    </ul>

    <h3 class="card-title">Component design</h3>

    <h4 class="card-title">Encode the URL</h4>
    <ul>
      <li>Want to generate characters at the end of the URL.</li>
      <li>Assume base64 encoding</li>
      <ul>
        <li>6 letters 64^6 = 68.7 billion possible strings.</li>
        <li>8 letters 64^8 = 281 trillion possible strings.</li>
      </ul>
      <li>Duplication: if multiple users enter the same URL, they can get the same shortened URL, which is not good.</li>
    </ul>

    <h4 class="card-title">Key generating service</h4>
    <ul>
      <li>Generates random 6 letter strings and store them in key DB.</li>
      <li>What is two or more servers are trying the use the same key?</li>
      <ul>
        <li>One table for keys not in used, one table for keys in use.</li>
        <li>Load some keys in memory to give to the servers and at the same time move them to "Used" table.</li>
        <ul>
          <li>If servers die, we lose keys. But that is okay given we've got enough keys to cover shortening requests.</li>
        </ul>
      </ul>
      <li>DB size: 6 (characters per key) * 68.7 billion (unique keys) = 412GB</li>
      <li>Single point of failure? Use replicas.</li>
    </ul>

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>

    <h4 class="card-title">Reliability</h4>

    <h4 class="card-title">Scalability</h4>

    <h4 class="card-title">Performance</h4>

  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-19">
  <div class="card-body">
    <h2 class="card-title">Web crawler</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Crawl all the web. (HTML only)</li>
      <li>Consider HTTP protocol only.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <li>Performance.</li>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>10M daily active users</li>
        <li>A single server can handle 10k connections.</li>
      </ul>
      <li>10M / 10k = 1,000 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>1 billion web sites, which is in turn 15 billion HTML pages.</li>
        <li>Page size is 100KB on average with 500 bytes metadata.</li>
      </ul>
      <li>15B * (100KB + 500B) = 1.5PB.</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>1.5PB * 8 / 86400 = 139Gbps.</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>Pick a URL from unvisited URL list.</li>
      <li>Determine the IP address of the hostname.</li>
      <li>Download the document.</li>
      <li>Parse document contents to look for new URLs.</li>
      <li>Add new URLs to unvisited URL list.</li>
      <li>Process downloaded document.</li>
    </ul>

    <h3 class="card-title">API</h3>

    <h3 class="card-title">DB</h3>

    <h3 class="card-title">Component design</h3>

    <h4 class="card-title">URL frontier</h4>
    <ul>
      <li>Contains all the remaining URLs to download.</li>
      <li>Prioritize which URLs should be downloaded first.</li>
      <li>Use BFS implemented by a queue.</li>
      <li>Distributed into multiple servers.</li>
      <ul>
        <li>Each server maintains many queues such that each thread gets a queue.</li>
        <li>Hash table maps carnonical hostname to thread number that run the queue.</li>
      </ul>
      <li>Due to huge size of URLs, need to store URLs into a disk.</li>
      <ul>
        <li>Enqueue buffer, once filled, is dumped into disk.</li>
        <li>Dequeue buffer keeps cache of URLs to be visited. It periodically reads from disk to fill the buffer.</li>
      </ul>
    </ul>

    <h4 class="card-title">HTML fetcher</h4>
    <ul>
      <li>Downloads documents corresponding to givne URL using protocol like HTTP.</li>
    </ul>

    <h4 class="card-title">Document input stream</h4>
    <ul>
      <li>Caches the entire document contents.</li>
      <li>Prevents downloading the same document again.</li>
    </ul>

    <h4 class="card-title">Document de-dup</h4>
    <ul>
      <li>Checks if document is duplicate.</li>
      <li>Calculates 64-bit checksum of every processed document using MD5 or SHA and store it in DB.</li>
    </ul>

    <h4 class="card-title">URL filter</h4>
    <ul>
      <li>Blocks some websites so that crawler can ignore them.</li>
    </ul>

    <h4 class="card-title">DNS resolver</h4>
    <ul>
      <li>Caches DNS lookup results.</li>
    </ul>

    <h4 class="card-title">URL de-dup</h4>
    <ul>
      <li>Check if URL is duplicates. (Multiple URL linking to the same document)</li>
      <li>Store checksum of URLs in carnonical forms into DB.</li>
    </ul>

    <h4 class="card-title">Data partitioning</h4>
    <ul>
      <li>Distribute based on hostname which contains</li>
      <ul>
        <li>URLs to visit.</li>
        <li>URL checksum.</li>
        <li>Document checksum.</li>
      </ul>
    </ul>

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>

    <h4 class="card-title">Reliability</h4>

    <h4 class="card-title">Scalability</h4>

    <h4 class="card-title">Performance</h4>

  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-20">
  <div class="card-body">
    <h2 class="card-title">Typeahead</h2>

    <h3 class="card-title">Requirement</h3>

    <h4 class="card-title">Functional</h4>
    <ul>
      <li>Suggests top 10 terms starting with whatever user has typed.</li>
    </ul>

    <h4 class="card-title">Non-functional</h4>
    <ul>
      <li>Availability.</li>
      <li>Reliability.</li>
      <li>Scalability.</li>
      <li>Performance.</li>
    </ul>

    <h3 class="card-title">Estimation</h3>

    <h4 class="card-title">Server</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>10M daily active users</li>
        <li>A single server can handle 10k connections.</li>
      </ul>
      <li>10M / 10k = 1,000 servers are needed.</li>
    </ul>

    <h4 class="card-title">Storage</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>There are 3.5B unique queries per day.</li>
        <li>There are 2B unique queries out of 3.5B per day.</li>
        <li>Each query has 15 characters on average.</li>
        <li>Each character requires 2 bytes to store.</li>
      </ul>
      <li>2B per day * 15 * 2 = 60GB per day.</li>
    </ul>

    <h4 class="card-title">Bandwidth</h4>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Suggestions have the same length, which is 15 chracters.</li>
        <li>Top 10 suggestions are shown to users.</li>
      </ul>
      <li>Incoming: 3.5B * 2 * 15 * 8 / 86400 = 9.7Mbps</li>
      <li>Outgoing: 10 * 15 * 9.7Mbps = 1.46Gbps</li>
    </ul>

    <h3 class="card-title">High level design</h3>
    <ul>
      <li>Trie structure.</li>
      <li>Store this data structure in memory. (Not in DB)</li>
      <li>Assume case insensitive.</li>
      <li>For example, when user types "CAP", node "P" will show all suggestions.</li>
    </ul>

    <h3 class="card-title">API</h3>
    <ul>
      <li>get_suggestions(prefix)</li>
      <li>add_to_database(query)</li>
    </ul>

    <h3 class="card-title">DB</h3>

    <h3 class="card-title">Component design</h3>

    <h4 class="card-title">How to find top suggestions</h4>
    <ul>
      <li>Store the number of searches in the last phrase.</li>
      <li>Parent nodes recursively call child nodes to get suggestions and counts.</li>
    </ul>

    <h4 class="card-title">How to update trie</h4>
    <ul>
      <li>Spread copies of tries on each server and update them offline. (While some nodes are serving the traffic)</li>
      <li>Also, remove inappropriate terms from the tries duing this time.</li>
      <li>Also, update frequency at each node.</li>
    </ul>

    <h4 class="card-title">Client behavior</h4>
    <ul>
      <li>Client should hit the server only when no key has been pressed for 50ms.</li>
      <li>When user is typing, client should cancel in-progress request.</li>
      <li>Client should wait until at least few characters are entered in the beginning.</li>
      <li>Client can store recent history of top suggestions.</li>
      <li>Establish connection between client and server as soon as browser opens up.</li>
      <li>Server should push some part of cache to CDNs.</li>
    </ul>

    <h4 class="card-title">Data partitioning</h4>
    <ul>
      <li>Range based partitioning</li>
      <ul>
        <li>Pick storage based on starting character of queries.</li>
        <li>Results in uneven servers.</li>
        <li>There will be hot servers.</li>
        <li>May not be able to fit the size of data into each server.</li>
      </ul>
      <li>Hash based partitioning</li>
      <ul>
        <li>Each term gets a server number from hash function.</li>
        <li>Minimize hot servers.</li>
        <li>Must query all servers and aggregate the result.</li>
      </ul>
    </ul>

    <h4 class="card-title">Caching</h4>
    <ul>
      <li>Cache servers in front of trie servers with frequenctly searched terms and their typeahead suggestions.</li>
      <li>App servers should check cache servers before hitting trie servers.</li>
    </ul>

    <h3 class="card-title">Evaluation</h3>

    <h4 class="card-title">Availability</h4>

    <h4 class="card-title">Reliability</h4>

    <h4 class="card-title">Scalability</h4>

    <h4 class="card-title">Performance</h4>

  </div>
  <div class="card-footer text-muted">
    <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>
<!-- System design END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>