<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax/tex-chtml.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- Graph BFS BEGIN -->
<div class="card mb-4" id="graph">
  <div class="card-body">
    <h2 class="card-title">Graph BFS</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#graph-bfs-">Word Ladder</a></li>
      <li><a href="#graph-bfs-">Number of Islands</a></li>
      <li><a href="#graph-bfs-">Walls And Gates</a></li>
      <li><a href="#graph-bfs-">Shortest Distance from All Buildings</a></li>
      <li><a href="#graph-bfs-">Accounts Merge</a></li>
      <li><a href="#graph-bfs-">Bus Routes</a></li>
      <li><a href="#graph-bfs-">Shortest Path in Binary Matrix</a></li>
      <li><a href="#graph-bfs-">The Time When the Network Becomes Idle</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="graph-bfs">
  <div class="card-body">
    <h2 class="card-title">Word Ladder (H)</h2>

<pre><code class="python">class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:

        # Construct a graph where nodes are 
        # words differ by one char
        # BFS to compute shrotest distance

        graph = defaultdict(set)
        words = [beginWord] + wordList
        n = len(words)

        # Time O(kl)
        #   k = number of words 
        #   l = length of each word
        # Space O(kl)
        differ_by_one_char = defaultdict(set)
        for word in words:
            for i in range(len(word)):
                for c in 'abcdefghijklmnopqrstuvwxyz':
                    differ_by_one_char[word].add(word[:i]+c+word[i+1:])

        # Time O(k**2)
        # Space O(k**2)
        for i in range(n):
            for j in range(i+1,n):
                if words[j] in differ_by_one_char[words[i]]:
                    graph[words[i]].add(words[j])
                    graph[words[j]].add(words[i])

        # Time O(n+m)
        #   n = number of nodes = k
        #   m = number of edges = k ** 2 every node can be connected
        # Space O(n)
        def bfs(graph, start, end):

            explored = set()
            explored.add(start)

            queue = deque()
            queue.append((start,0))

            while queue:
                node, dist = queue.popleft()
                for next_node in graph[node]:
                    if next_node == end:
                        return dist+2
                    if next_node not in explored:
                        explored.add(next_node)
                        queue.append((next_node,dist+1))

            return 0

        return bfs(graph, beginWord, endWord)</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/word-ladder">127. Word Ladder</a>
  </div>
</div>

<div class="card mb-4" id="graph-bfs">
  <div class="card-body">
    <h2 class="card-title">Number of Islands (M)</h2>

<pre><code class="python">class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:

        # BFS
        # Compute number of connected component

        dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)]
        n = len(grid)
        m = len(grid[0])

        # Time O(p+q) = O(nm)
        #   p = number of nodes = nm
        #   q = number of edges = maximum 4 per node = 4nm
        # Space O(p) = O(nm)
        def bfs(grid, dirs, explored, start):

            queue = deque()
            queue.append(start)

            while queue:
                i, j = queue.popleft()

                for x, y in dirs:
                    if 0 <= i + x < n \
                        and 0 <= j + y < m \
                        and grid[i+x][j+y] == "1" \
                        and (i+x, j+y) not in explored:
                        explored.add((i+x, j+y))
                        queue.append((i+x, j+y))

        explored = set()
        count = 0

        for i in range(n):
            for j in range(m):
                if grid[i][j] == "1" \
                    and (i,j) not in explored:
                    bfs(grid, dirs, explored, (i,j))
                    count += 1

        return count</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/number-of-islands">200. Number of Islands</a>
  </div>
</div>

<div class="card mb-4" id="graph-bfs">
  <div class="card-body">
    <h2 class="card-title">Walls And Gates (M)</h2>

<pre><code class="python">class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -> None:
        """
        Do not return anything, modify rooms in-place instead.
        """

        # From each empty cell, run BFS keeping the depth
        # When hits a gate
        #   Set the distance to the gate as the depth
        #   Then, return (BFS guarantees shortest distance)

        # Alternatively, run BFS from each gate
        # When hits an empty cell,
        #   Set the value of empty cell as the depth
        #   If an empty cell sees more than one value, 
        #   set to the minimum value it has seen 

        # In graph, path only exists between empty cells
        # and empty cell and gate
       
        n = len(rooms)
        m = len(rooms[0])
        dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]

        # Time O(p+q) 
        #   p = number of nodes = n + m
        #   q = number of edges (each node can have max 4 edges)
        # Space O(p)
        def bfs(rooms, start):

            explored = set()
            explored.add(start)

            queue = deque()
            queue.append((start,0))

            while queue:
                node, depth = queue.popleft()
                i = node[0]
                j = node[1]

                for x, y in dirs:
                    if 0 <= i + x < n \
                        and 0 <= j + y < m \
                        and rooms[i+x][j+y] != -1:
                        next_node = (i+x, j+y)

                        if next_node not in explored \
                            and rooms[i+x][j+y] != 0 \
                            and rooms[i+x][j+y] != 1:
                            explored.add(next_node)
                            queue.append((next_node, depth+1))
                            rooms[i+x][j+y] = min(rooms[i+x][j+y], depth+1)
                            
        # Time O(k(p+q))
        #   k = number of gates
        for i in range(n):
            for j in range(m):
                if rooms[i][j] == 0:
                    bfs(rooms, (i, j))</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/walls-and-gates">286. Walls And Gates</a>
  </div>
</div>

<div class="card mb-4" id="graph-bfs-">
  <div class="card-body">
    <h2 class="card-title">Shortest Distance from All Buildings (H)</h2>

<pre><code class="python">class Solution:
    def shortestDistance(self, grid: List[List[int]]) -> int:

        # BFS
        # Start from a node and compute distance 
        # to reach all houses

        graph = defaultdict(set)
        nodes = set()
        dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        houses = set()
        n = len(grid)
        m = len(grid[0])

        # Save nodes from where all housese cannot be visited
        bad_nodes = set()

        # Time O(nm)
        #   n = number of rows
        #   m = number of columns
        # Space O(nm)
        for i in range(n):
            for j in range(m):
                # Obstacle
                if grid[i][j] == 2:
                    continue
                # House
                if grid[i][j] == 1:
                    houses.add((i,j))
                    continue
                # Empty land
                if grid[i][j] == 0:
                    nodes.add((i,j))
                    for x, y in dirs:
                        if 0 <= i + x < n \
                            and 0 <= j + y < m \
                            and grid[i][j] != 2:
                            graph[(i,j)].add((i+x,j+y))

        # Time O(p+q)
        #   p = number of nodes = nm
        #   q = number of edges (each node can have max 4 edges) = mn
        def bfs(grid, houses, graph, start, bad_nodes):

            explored = set()
            explored.add(start)

            queue = deque()
            queue.append((start, 0))
            
            total_dist = 0
            visited_houses = 0

            while queue:
                node, dist = queue.popleft()
                if node in bad_nodes:
                    return 0, 0
 
                if grid[node[0]][node[1]] == 1:
                    total_dist += dist

                for next_node in graph[node]:
                    if next_node not in explored:
                        explored.add(next_node)
                        queue.append((next_node, dist+1))
                        if next_node in houses:
                            visited_houses += 1
                    
            return total_dist, visited_houses

        min_dist = math.inf

        # Time O((nm)**2)
        # Space O(nm)
        for node in nodes:
            dist, visited_houses = bfs(grid, houses, graph, node, bad_nodes)
            if visited_houses < len(houses):
                bad_nodes.add(node)
                continue
            min_dist = min(min_dist, dist)

        if not nodes or min_dist == math.inf:
            return -1
        return min_dist</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/shortest-distance-from-all-buildings">317. Shortest Distance from All Buildings</a>
  </div>
</div>

<div class="card mb-4" id="graph-bfs-">
  <div class="card-body">
    <h2 class="card-title">Accounts Merge (M)</h2>

<pre><code class="python">class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:

        # Construct a graph
        #   Node is email
        #   Edge between nodes exists when they belong to same person
        # Compute connected components

        graph = defaultdict(set)
        email_to_person = defaultdict(str)
        emails = set()

        for account in accounts:
            for i in range(1, len(account)):
                graph[account[1]]
                emails.add(account[i])
                email_to_person[account[i]] = account[0]
                for j in range(i+1, len(account)):
                    graph[account[i]].add(account[j])
                    graph[account[j]].add(account[i])

        # Time max(O(n+m), O(nlogn)) 
        #   n = number of emails
        #   m = number of edges betweem emails
        #   Sorting the output at the end
        # Space O(n^2)
        def bfs(graph, explored, start):

            queue = deque()
            queue.append(start)

            explored.add(start)
            nodes = set()
            
            while queue:
                node = queue.popleft()
                nodes.add(node)
                
                for next_node in graph[node]:
                    if next_node not in explored:
                        explored.add(next_node)
                        queue.append(next_node)
                        
            return nodes

        result = []

        explored = set()
        for node in emails:
            if node not in explored:
                nodes = bfs(graph, explored, node)
                nodes = list(nodes)
                person = email_to_person[nodes[0]]
                nodes.sort()       
                result.append([person]+nodes)

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/accounts-merge">721. Accounts Merge</a>
  </div>
</div>

<div class="card mb-4" id="graph-bfs">
  <div class="card-body">
    <h2 class="card-title">Bus Routes (H)</h2>

<pre><code class="python"></code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/bus-routes">815. Bus Routes</a>
  </div>
</div>

<div class="card mb-4" id="graph-bfs">
  <div class="card-body">
    <h2 class="card-title">Shortest Path in Binary Matrix (M)</h2>

<pre><code class="python">class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:

        # Do BFS to compute shortest path

        dirs = [(-1,-1), (-1,0), (-1,1), (0,1), (1,1), (1,0), (1,-1), (0,-1)]

        n = len(grid)
        if grid[0][0] == 1 or grid[n-1][n-1] == 1:
            return -1

        start = (0, 0)
        end = (n-1, n-1)
        
        explored = set()
        explored.add(start)

        queue = deque()
        queue.append((start, 0))

        # Time O(p+q)
        #   p = number of nodes = n**2
        #   q = number of edges = 8*n = n
        # Space O(p)
        while queue:
            node, depth = queue.popleft()
            if node == end:
                return depth + 1

            i, j = node[0], node[1]
            for x, y in dirs:
                if 0 <= i + x < n \
                    and 0 <= j + y < n \
                    and grid[i+x][j+y] == 0:
                    next_node = (i+x, j+y)
                    if next_node not in explored:
                        explored.add(next_node)
                        queue.append((next_node, depth+1))

        return -1</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/shortest-path-in-binary-matrix">1091. Shortest Path in Binary Matrix</a>
  </div>
</div>
<!-- Graph BFS END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>