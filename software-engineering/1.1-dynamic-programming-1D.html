<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax/tex-chtml.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- Dynamic programming 1D BEGIN -->
<div class="card mb-4" id="dynamicprogramming">
  <div class="card-body">
    <h2 class="card-title">Dynamic programming 1D</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#dynamic-programming-1d">Climbing stairs</a></li>
      <li><a href="#dynamic-programming-1d">Decode ways</a></li>
      <li><a href="#dynamic-programming-1d">Unique binary search trees</a></li>
      <li><a href="#dynamic-programming-1d">Pascal's Triangle</a></li>
      <li><a href="#dynamic-programming-1d">Best time to buy and sell stock III</a></li>
      <li><a href="#dynamic-programming-1d">Word break II</a></li>
      <li><a href="#dynamic-programming-1d">Best time to buy and sell stock IV</a></li>
      <li><a href="#dynamic-programming-1d">House robber</a></li>
      <li><a href="#dynamic-programming-1d">Coin change</a></li>
      <li><a href="#dynamic-programming-1d">Target sum</a></li>
      <li><a href="#dynamic-programming-1d">Fibonacci Number</a></li>
      <li><a href="#dynamic-programming-1d">Minimum number of refueling stops</a></li>
      <li><a href="#dynamic-programming-1d">Nth tribonacci number</a></li>
      <li><a href="#dynamic-programming-1d">Stone Game II</a></li>
      <li><a href="#dynamic-programming-1d">Maximum Profit in Job Scheduling</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Climbing stairs (E)</h2>

<pre><code class="python">class Solution(object):
    def climbStairs(self, n):
        
        # Number of ways = number of ways (n-1) + number of ways (n-2)
        # dp[i] = dp[i-1] + dp[i-2]

        if n == 1:
            return 1

        dp = [0] * (n+1)
        dp[1] = 1
        dp[2] = 2

        # Time O(n)
        # Space O(n)
        for i in range(3, n+1):
            dp[i] = dp[i-1] + dp[i-2]

        return dp[n]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/climbing-stairs">70. Climbing Stairs</a>
  </div>
</div>
 
<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Decode ways (M)</h2>

<pre><code class="python">class Solution:
    def numDecodings(self, s: str) -> int:

        # Ex. 231
        #     2 3 1
        #   1 1 2 2

        n = len(s)
        dp = [0 for _ in range(n+1)]

        dp[0] = 1
        if s[0] == "0":
            dp[1] = 0
        else:
            dp[1] = 1

        # Time O(n) n = len(s)
        # Space O(m)
        for i in range(2, n+1):
            if 0 < int(s[i-1:i]) <= 9:
                dp[i] += dp[i-1]

            if 10 <= int(s[i-2:i]) <= 26:
                dp[i] += dp[i-2]

        return dp[n]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/decode-ways">91. Decode Ways</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Unique binary search trees (M)</h2>

<pre><code class="python">class Solution:
    def numTrees(self, n: int) -> int:

        # BST with 1 node has 1 possible configuration
        # BST with 2 nodes has 2 possible configuration
        # BST with 3 nodes has 5 possible configuration
        # https://www.cs.cmu.edu/afs/cs/academic/class/15750-s17/ScribeNotes/lecture7.pdf

        # 0 1 2 3 4 5 6 7 8
        # 0 1 2 5 11

        # Edge case
        if n == 1 or n == 2:
            return n

        dp = [1 for _ in range(n+1)]
        dp[1] = 1
        dp[2] = 2

        # Time O(n^2)
        # Space O(n)
        for i in range(3, n+1):
            num_config = 0
            for j in range(i):
                num_config += (dp[j]*dp[i-j-1])
            dp[i] = num_config

        return dp[n]></code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/unique-binary-search-trees">96. Unique Binary Search Trees</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Pascal's Triangle (E)</h2>

<pre><code class="python"></code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/pascals-triangle">118. Pascal's Triangle</a>
  </div>
</div>

<div class="card mb-4" id="array-">
  <div class="card-body">
    <h2 class="card-title">Best time to buy and sell stock III (H)</h2>

<pre><code class="python">class Solution:
    def maxProfit(self, prices: List[int]) -> int:

        #   0 3 3 5 0 0 3 1 4
        # 1 0 0 0 2 2 2 3 3 4
        # 2 0 0 0 2 2 2 5 5 6

        n = len(prices)
        k = 2
        profit_after_buy = [-math.inf for _ in range(k+1)]
        profit_after_sell = [0 for _ in range(k+1)]

        # Time O(k)
        # Space O(k)
        for i in range(n):
            for j in range(k, 0, -1):
                profit_after_buy[j] = max(profit_after_buy[j], profit_after_sell[j-1]-prices[i])
                profit_after_sell[j] = max(profit_after_sell[j], profit_after_buy[j]+prices[i])

        return profit_after_sell[k]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii">123. Best Time to Buy and Sell Stock III</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Word break II (H)</h2>

<pre><code class="python">class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:

        # Let dp[i] = all possible outputs for s[:i+1]
        # At dp[i], scan "s" from right to left to check if
        # any substring is in "wordDict"

        word_set = set(wordDict)
        n = len(s)

        dp = [[""] for _ in range(n+1)]

        # Time O(n^2)
        # Space O(n^2)
        for i in range(n):
            for j in range(i, -1, -1):
                if s[j:i+1] in word_set:
                    for sol in dp[j-1]:
                        dp[i].append(sol+" "+s[j:i+1])

        result = []
        for string in dp[n-1]:
            if len(string.strip().replace(" ", "")) == n:
                result.append(string.strip())

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/word-break-ii">140. Word Break II</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Best time to buy and sell stock IV (H)</h2>

<pre><code class="python">class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:

        n = len(prices)
        profit_after_buy = [-math.inf for _ in range(k+1)]
        profit_after_sell = [0 for _ in range(k+1)]

        # Time O(k)
        # Space O(k)
        for i in range(n):
            for j in range(k, 0, -1):
                profit_after_buy[j] = max(profit_after_buy[j], profit_after_sell[j-1]-prices[i])
                profit_after_sell[j] = max(profit_after_sell[j], profit_after_buy[j]+prices[i])

        return profit_after_sell[k]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv">188. Best Time to Buy and Sell Stock IV</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">House robber (M) (Amazon)</h2>

<pre><code class="python">class Solution:
    def rob(self, nums: List[int]) -> int:

        # Let dp[i] = money earned by robbing up to houses i
        # dp[i] = max(dp[i-1], nums[i]+dp[i-2])
        #   Because two adjacent houses cannot be robbed
        # dp[0] = 0

        n = len(nums)
        dp = [0] * (n+1)

        # Time O(n)
        #   n = len(nums)
        # Space O(n)
        for i in range(1, n+1):
            dp[i] = max(dp[i-1], nums[i-1]+dp[i-2])

        return dp[n]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/house-robber">198. House Robber</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Coin change (M) (Amazon)</h2>

<pre><code class="python">class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:

        # Let dp[j] minimum number of coins to make amount j
        # dp[j] = minimum of dp[j-i] + 1 over all i's
        # Ex. [1,2,5], 11
        #   dp[8] = min(dp[7] + 1, dp[6] + 1, d[3] + 1)
        #   dp[7] = min(dp[6] + 1, dp[5] + 1, dp[2] + 1)
        #   Initially, dp[0] = 0

        dp = [inf] * (amount+1)
        dp[0] = 0

        # Time O(nm)
        #   n = amount
        #   m = len(coins)
        # Space O(n)
        for j in range(1, amount+1):
            minimum = math.inf
            for i in coins:
                # Amount must be greater than each coin
                if j - i >= 0:
                    minimum = min(minimum, dp[j-i]+1)
            dp[j] = minimum

        if dp[amount] == math.inf:
            return -1

        return dp[amount]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/coin-change">322. Coin Change</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Target sum (M)</h2>

<pre><code class="python">class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:

        # Let P = positive subset, N = negative subset
        # Then, sum(P) + sum(N) = sum(nums) (1)
        # We want to find subsets such that, sum(P) - sum(N) = target (2)
        # Add (1) and (2), then sum(P) = (sum(nums) + target) / 2
        # We notice that (sum(nums) + target) must be even number

        if (sum(nums)+target) % 2 != 0 or (sum(nums)+target) < 0:
            return 0

        n = (sum(nums)+target) // 2
        m = len(nums)
        dp = [0 for _ in range(n+1)]
        dp[0] = 1

        # Time O(nm)
        # Space O(n)
        for num in nums:
            for i in range(n, num-1, -1):
                dp[i] += dp[i-num]

        return dp[n]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/target-sum">494. Target Sum</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d-">
  <div class="card-body">
    <h2 class="card-title">Fibonacci Number (E) (Google)</h2>

<pre><code class="python">class Solution:
    def fib(self, n: int) -> int:
        
        # DP

        # Time O(n)
        # Space O(n)
        dp = [0 for i in range(n+1)]
        
        for i in range(1, n+1):
            if i == 1:
                dp[1] = 1
            else:
                dp[i] = dp[i-1] + dp[i-2]

        return dp[n]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/fibonacci-number">509. Fibonacci Number</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Minimum number of refueling stops (H)</h2>

<pre><code class="python">class Solution:
    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:

        # dp[t] = furthest distance we can travel with fueling t times
        # Then, dp[t+1] = max(dp[t+1], dp[t]+stations[i][1])

        # start = 10, target = 100, [10,60],[20,30],[30,30],[60,40]
        # 0  1  2  3  4
        # 10 70 110

        if startFuel >= target:
            return 0

        if not stations:
            return -1

        n = len(stations)
        dp = [startFuel] + [0] * n

        # Time O(n^2)
        # Space O(n)
        for i in range(n):
            for t in range(i, -1, -1):
                if dp[t] >= stations[i][0] and t != n:
                    dp[t+1] = max(dp[t+1], dp[t]+stations[i][1])

        for t, d in enumerate(dp):
            if d >= target:
                return t

        return -1</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/minimum-number-of-refueling-stops">871. Minimum Number of Refueling Stops</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Nth tribonacci number (E)</h2>

<pre><code class="python">class Solution:
    def tribonacci(self, n: int) -> int:

        if n == 0:
            return 0
        if n == 1:
            return 1
        if n == 2:
            return 1

        dp = [0] * (n+1)
        dp[0], dp[1], dp[2] = 0, 1, 1

        # Time O(n)
        # Space O(n)
        for i in range(3, n+1):
            dp[i] = dp[i-3] + dp[i-2] + dp[i-1]

        return dp[n]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/n-th-tribonacci-number">1137. N-th Tribonacci Number</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Stone Game II (H)</h2>

<pre><code class="python"></code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/stone-game-ii">1140. Stone Game II</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Maximum Profit in Job Scheduling (H) (Amazon)</h2>

<pre><code class="python">class Solution:
    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:

        # Sort jobs based on start time
        # At each interval, there are two choices
        #   Skip the current job and move to next job
        #   Execute current job and move to next non-conflicting job
        # Let dp[i] = profit from jobs from index i to n
        #   If skip job i, dp[i] = dp[i+1]
        #   If execute job i, dp[i] = profit at i + d[next_i]
        # Use binary search to find next_i since start time is sorted

        # Time O(nlogn)
        intervals = []
        for x, y, z in zip(startTime, endTime, profit):
            intervals.append([x,y,z])

        intervals.sort(key=lambda x: x[0])
        
        n = len(intervals)
        dp = [0] * (n+1)

        def binary_search(i, intervals):

            end_t = intervals[i][1]
            left = 0
            right = len(intervals) - 1
            next_i = len(intervals)
            
            while left <= right:
                mid = (left+right) // 2
                if intervals[mid][0] >= end_t:
                    right = mid - 1
                    next_i = mid
                else:
                    left = mid + 1
                
            return next_i

        # Time O(nlogn)
        # Space O(n)
        for i in range(n-1, -1, -1):
            next_i = binary_search(i, intervals)
            print(f"{i}, {next_i}")
            if next_i == -1:
                dp[i] = max(dp[i+1], intervals[i][2])
            else:
                dp[i] = max(dp[i+1], intervals[i][2]+dp[next_i])

        return dp[0]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/maximum-profit-in-job-scheduling">1235. Maximum Profit in Job Scheduling</a>
  </div>
</div>
<!-- Dynamic programming 1D END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>