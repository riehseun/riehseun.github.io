<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax/tex-chtml.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- Dynamic programming 1D BEGIN -->
<div class="card mb-4" id="dynamicprogramming">
  <div class="card-body">
    <h2 class="card-title">Dynamic programming 1D</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#dynamic-programming-1d">Climbing Stairs</a></li>
      <li><a href="#dynamic-programming-1d">Decode Ways</a></li>
      <li><a href="#dynamic-programming-1d">Word Break II</a></li>
      <li><a href="#dynamic-programming-1d">House Robber</a></li>
      <li><a href="#dynamic-programming-1d">House Robber II</a></li>
      <li><a href="#dynamic-programming-1d">Coin Change</a></li>
      <li><a href="#dynamic-programming-1d">Min Cost Climbing Stairs</a></li>
      <li><a href="#dynamic-programming-1d">Maximum Profit in Job Scheduling</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Climbing Stairs (E)</h2>

<pre><code class="python">class Solution(object):
    def climbStairs(self, n):
        
        # n = 0 => Invalid
        # n = 1 => 1

        # DP
        # dp[n] = dp[n-1] + dp[n-2]
        # Time O(n)
        # Space O(n)

        if n == 1:
            return 1

        dp = [0 for _ in range(n+1)]
        dp[1] = 1
        dp[2] = 2

        for i in range(3, n+1):
            dp[i] = dp[i-1] + dp[i-2]

        return dp[n]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/climbing-stairs">70. Climbing Stairs</a> | <a href="https://neetcode.io/problems/climbing-stairs">Climbing Stairs</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Decode Ways (M)</h2>

<pre><code class="python">class Solution:
    def numDecodings(self, s: str) -> int:

        # s = "" => Invalid
        # s = "0" => Invalud
        # s = "1" => 1
        # s = "101" => 1
        # s = "111" => aaa, ka, ak 3
 
        # DP
        # dp[i] = number of ways to decode s[:i]
        # if s[i-1] != 0:
        #   dp[i] += dp[i-1]
        # if 10 <= s[i-2:i] <= 26: 
        #   dp[i] += dp[i-2]
        # Time O(n) n = len(s)
        # Space O(n)

        n = len(s)
        dp = [0 for _ in range(n+1)]

        dp[0] = 1 
        if s[0] == "0":
            dp[1] = 0
        else:
            dp[1] = 1

        for i in range(2,n+1):
            if int(s[i-1]) != 0:
                dp[i] += dp[i-1]
            if 10 <= int(s[i-2:i]) <= 26: 
                dp[i] += dp[i-2]
         
        return dp[n]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/decode-ways">91. Decode Ways</a> | <a href="https://neetcode.io/problems/decode-ways">Decode Ways</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Word Break II (H)</h2>

<pre><code class="python">class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:

        # Let dp[i] = all possible outputs for s[:i+1]
        # At dp[i], scan "s" from right to left to check if 
        # any substring is in "wordDict"
        
        word_set = set(wordDict)
        n = len(s)

        dp = [[""] for _ in range(n+1)]

        # Time O(n**2)
        # Space O(n**2)
        for i in range(n):
            for j in range(i, -1, -1):
                if s[j:i+1] in word_set:
                    for sol in dp[j-1]:
                        dp[i].append(sol+" "+s[j:i+1])

        result = []
        for string in dp[n-1]:
            if len(string.strip().replace(" ", "")) == n:
                result.append(string.strip())

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/word-break-ii">140. Word Break II</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">House Robber (M)</h2>

<pre><code class="python">class Solution:
    def rob(self, nums: List[int]) -> int:

        # nums = [] => Invalid
        # nums = [2] => 2
        # nums = [1,3,1] => 3
        # nums = [2,3,2] => 4

        # DP
        # dp[n] = max(dp[n-1], dp[n]+dp[n-2])
        # Time O(n) n = len(nums)
        # Space O(n)
        
        n = len(nums)
        dp = [0 for _ in range(n+1)]
        
        for i in range(1, n+1):
            dp[i] = max(dp[i-1], nums[i-1]+dp[i-2])
        
        return dp[n]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/house-robber">198. House Robber</a> | <a href="https://neetcode.io/problems/house-robber">House Robber</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">House Robber II (M)</h2>

<pre><code class="python">class Solution:
    def rob(self, nums: List[int]) -> int:
        
        # nums = [1] => 1
        # nums = [] => Invalid
        # nums = [2,4] => 4
        
        # DP
        # dp[i] = max(dp[i-1], dp[i-2]+nums[i])
        # Either rob first and second last 
        # or second and last
        # Time O(n) n = len(nums)
        # Space O(n)

        def house_robber(nums):
            n = len(nums)            
            dp = [0 for _ in range(n+1)]

            for i in range(1, n+1):
                dp[i] = max(dp[i-1], dp[i-2]+nums[i-1])

            return dp[n]

        if len(nums) == 1:
            return nums[0]
            
        return max(house_robber(nums[:-1]), house_robber(nums[1:]))</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/house-robber-ii">213. House Robber II</a> | <a href="https://neetcode.io/problems/house-robber-ii">House Robber II</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Coin Change (M)</h2>

<pre><code class="python">class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:

        # coins = [], amount = 1 => Invalid
        # coins = [1], amount = 2 => 2 (1+1)
        # coins = [2], amount = 3 => -1

        # DP
        # dp[i] = fewest number of coins to create i
        # dp[0] = 0
        # dp[1] = min(dp[1-j]+1) for j in coins 
        # dp[2] = min(dp[2-j]+1) for j in coins
        # Time O(n) n = amount
        # Space O(n)

        n = amount
        dp = [0 for _ in range(n+1)]
        dp[0] = 0

        for i in range(1, n+1):
            min_num = math.inf
            for j in coins:
                if i - j >= 0:
                    min_num = min(min_num, dp[i-j]+1)
            dp[i] = min_num

        if dp[n] == math.inf:
            return -1
            
        return dp[n]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/coin-change">322. Coin Change</a> | <a href="https://neetcode.io/problems/coin-change">Coin Change</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Min Cost Climbing Stairs (E)</h2>

<pre><code class="python">class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        
        # cost = [0, 0, 0] => 0
        # cost = [1, 2, 3] => 2
        # cost = [1, 2, 3, 4] => 1+3=4
        # cost = [] => 0
        # cost = [1] => 0
        # cost = [1, 2] => 0

        # DP
        # dp[n] = min cost to reach index n
        # dp[n] = min(dp[n-1]+cost[n-1], dp[n-2]+cost[n-2])
        # dp[1] = 0
        # dp[2] = 0
        # Time O(n) n = len(cost)
        # Space O(n)

        n = len(cost)
        dp = [0 for _ in range(n+1)]
        
        for i in range(2, n+1):
            dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])

        return dp[n]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/min-cost-climbing-stairs">746. Min Cost Climbing Stairs</a> | <a href="https://neetcode.io/problems/min-cost-climbing-stairs">Min Cost Climbing Stairs</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Maximum Profit in Job Scheduling (H)</h2>

<pre><code class="python">class Solution:
    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:

        # Sort jobs based on start time
        # At each interval, there are two choices
        #   Skip the current job and move to next job
        #   Execute current job and move to next non-conflicting job
        # Let dp[i] = profit from jobs from index i to n
        #   If skip job i, dp[i] = dp[i+1]
        #   If execute job i, dp[i] = profit at i + d[next_i]
        # Use binary search to find next_i since start time is sorted

        # Time O(nlogn)
        intervals = []
        for x, y, z in zip(startTime, endTime, profit):
            intervals.append([x,y,z])

        intervals.sort(key=lambda x: x[0])
        
        n = len(intervals)
        dp = [0] * (n+1)

        def binary_search(i, intervals):

            end_t = intervals[i][1]
            left = 0
            right = len(intervals) - 1
            next_i = len(intervals)
            
            while left <= right:
                mid = (left+right) // 2
                if intervals[mid][0] >= end_t:
                    right = mid - 1
                    next_i = mid
                else:
                    left = mid + 1
                
            return next_i

        # Time O(nlogn)
        # Space O(n)
        for i in range(n-1, -1, -1):
            next_i = binary_search(i, intervals)
            print(f"{i}, {next_i}")
            if next_i == -1:
                dp[i] = max(dp[i+1], intervals[i][2])
            else:
                dp[i] = max(dp[i+1], intervals[i][2]+dp[next_i])

        return dp[0]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/maximum-profit-in-job-scheduling">1235. Maximum Profit in Job Scheduling</a>
  </div>
</div>
<!-- Dynamic programming 1D END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>