<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax/tex-chtml.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- Dynamic programming 1D BEGIN -->
<div class="card mb-4" id="dynamicprogramming">
  <div class="card-body">
    <h2 class="card-title">Dynamic programming 1D</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#dynamic-programming-1d">Climbing Stairs</a></li>
      <li><a href="#dynamic-programming-1d">Word Break II</a></li>
      <li><a href="#dynamic-programming-1d">House Robber</a></li>
      <li><a href="#dynamic-programming-1d">Coin Change</a></li>
      <li><a href="#dynamic-programming-1d">Maximum Profit in Job Scheduling</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Climbing Stairs (E)</h2>

<pre><code class="python">class Solution(object):
    def climbStairs(self, n):
        
        # Number of ways = number of ways (n-1) + number of ways (n-2)
        # dp[i] = dp[i-1] + dp[i-2]

        if n == 1:
            return 1

        dp = [0] * (n+1)
        dp[1] = 1
        dp[2] = 2

        # Time O(n)
        # Space O(n)
        for i in range(3, n+1):
            dp[i] = dp[i-1] + dp[i-2]

        return dp[n]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/climbing-stairs">70. Climbing Stairs</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Word Break II (H)</h2>

<pre><code class="python">class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:

        # Let dp[i] = all possible outputs for s[:i+1]
        # At dp[i], scan "s" from right to left to check if
        # any substring is in "wordDict"

        word_set = set(wordDict)
        n = len(s)

        dp = [[""] for _ in range(n+1)]

        # Time O(n^2)
        # Space O(n^2)
        for i in range(n):
            for j in range(i, -1, -1):
                if s[j:i+1] in word_set:
                    for sol in dp[j-1]:
                        dp[i].append(sol+" "+s[j:i+1])

        result = []
        for string in dp[n-1]:
            if len(string.strip().replace(" ", "")) == n:
                result.append(string.strip())

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/word-break-ii">140. Word Break II</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">House Robber (M)</h2>

<pre><code class="python">class Solution:
    def rob(self, nums: List[int]) -> int:

        # Let dp[i] = money earned by robbing up to houses i
        # dp[i] = max(dp[i-1], nums[i]+dp[i-2])
        #   Because two adjacent houses cannot be robbed
        # dp[0] = 0

        n = len(nums)
        dp = [0] * (n+1)

        # Time O(n)
        #   n = len(nums)
        # Space O(n)
        for i in range(1, n+1):
            dp[i] = max(dp[i-1], nums[i-1]+dp[i-2])

        return dp[n]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/house-robber">198. House Robber</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Coin Change (M)</h2>

<pre><code class="python">class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:

        # Let dp[j] minimum number of coins to make amount j
        # dp[j] = minimum of dp[j-i] + 1 over all i's
        # Ex. [1,2,5], 11
        #   dp[8] = min(dp[7] + 1, dp[6] + 1, d[3] + 1)
        #   dp[7] = min(dp[6] + 1, dp[5] + 1, dp[2] + 1)
        #   Initially, dp[0] = 0

        dp = [inf] * (amount+1)
        dp[0] = 0

        # Time O(nm)
        #   n = amount
        #   m = len(coins)
        # Space O(n)
        for j in range(1, amount+1):
            minimum = math.inf
            for i in coins:
                # Amount must be greater than each coin
                if j - i >= 0:
                    minimum = min(minimum, dp[j-i]+1)
            dp[j] = minimum

        if dp[amount] == math.inf:
            return -1

        return dp[amount]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/coin-change">322. Coin Change</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Maximum Profit in Job Scheduling (H)</h2>

<pre><code class="python">class Solution:
    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:

        # Sort jobs based on start time
        # At each interval, there are two choices
        #   Skip the current job and move to next job
        #   Execute current job and move to next non-conflicting job
        # Let dp[i] = profit from jobs from index i to n
        #   If skip job i, dp[i] = dp[i+1]
        #   If execute job i, dp[i] = profit at i + d[next_i]
        # Use binary search to find next_i since start time is sorted

        # Time O(nlogn)
        intervals = []
        for x, y, z in zip(startTime, endTime, profit):
            intervals.append([x,y,z])

        intervals.sort(key=lambda x: x[0])
        
        n = len(intervals)
        dp = [0] * (n+1)

        def binary_search(i, intervals):

            end_t = intervals[i][1]
            left = 0
            right = len(intervals) - 1
            next_i = len(intervals)
            
            while left <= right:
                mid = (left+right) // 2
                if intervals[mid][0] >= end_t:
                    right = mid - 1
                    next_i = mid
                else:
                    left = mid + 1
                
            return next_i

        # Time O(nlogn)
        # Space O(n)
        for i in range(n-1, -1, -1):
            next_i = binary_search(i, intervals)
            print(f"{i}, {next_i}")
            if next_i == -1:
                dp[i] = max(dp[i+1], intervals[i][2])
            else:
                dp[i] = max(dp[i+1], intervals[i][2]+dp[next_i])

        return dp[0]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/maximum-profit-in-job-scheduling">1235. Maximum Profit in Job Scheduling</a>
  </div>
</div>
<!-- Dynamic programming 1D END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>