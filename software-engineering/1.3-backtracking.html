<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- Backtracking BEGIN -->
<div class="card mb-4" id="backtracking">
  <div class="card-body">
    <h2 class="card-title">Backtracking</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#backtracking-">Letter Combinations of a Phone Number</a></li>
      <li><a href="#backtracking-">Generate Parentheses</a></li>
      <li><a href="#backtracking-">N-Queens</a></li>
      <li><a href="#backtracking-">Subset</a></li>
      <li><a href="#backtracking-">Word Search</a></li>
      <li><a href="#backtracking-">Palindrome Partitioning</a></li>
      <li><a href="#backtracking-">Robot Room Cleaner</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="backtracking-">
  <div class="card-body">
    <h2 class="card-title">Letter Combinations of a Phone Number (M)</h2>

<pre><code class="python">class Solution:
    def letterCombinations(self, digits: str) -> List[str]:

        # Backtracking
        # At each digit, there are 3 choices

        if len(digits) == 0:
            return []

        # Time O(3**n)
        #   n = len(digits)
        # Space O(n)
        #   n is from recursion call stack
        #   Ignoring space for output
        def backtrack(result, digits, mapping, i, path):

            if len(path) == len(digits):
                result.append("".join(path))
                return
                
            for c in mapping[digits[i]]:
                path.append(c)
                backtrack(result, digits, mapping, i+1, path)
                path.pop()

        # Store the mapping between number and letter in a dictionary
        mapping = {
            "2":"abc",
            "3":"def",
            "4":"ghi",
            "5":"jkl",
            "6":"mno",
            "7":"pqrs",
            "8":"tuv",
            "9":"wxyz"
        }

        result = []
        backtrack(result, digits, mapping, 0, [])

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number">17. Letter Combinations of a Phone Number</a>
  </div>
</div>

<div class="card mb-4" id="backtracking-">
  <div class="card-body">
    <h2 class="card-title">Generate Parentheses (M)</h2>

<pre><code class="python">class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        
        # Backtrack
        # For each b in ["(", ")"] 
        #   We can put "(" only when number of "(" < n
        #   We can put ")" only when number of "(" > number of ")"

        # Time O(2n**n)
        # Space O(n)
        def backtrack(result, parenthesis, n):

            for b in ["(", ")"]:

                if len(parenthesis) == n * 2:
                    result.append("".join(parenthesis))
                    return
                
                open_b, close_b = 0, 0
                for c in parenthesis:
                    if c == "(":
                        open_b += 1
                    else:
                        close_b += 1

                if b == ")" and open_b > close_b:
                    parenthesis.append(b)
                    backtrack(result, parenthesis, n)
                    parenthesis.pop()
                if b == "(" and open_b < n:
                    parenthesis.append("(")
                    backtrack(result, parenthesis, n)
                    parenthesis.pop()

        result = []
        backtrack(result, [], n)
        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/generate-parentheses">22. Generate Parentheses</a>
  </div>
</div>

<div class="card mb-4" id="backtracking-">
  <div class="card-body">
    <h2 class="card-title">N-Queens (H)</h2>

<pre><code class="python">class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:

        # Backtracking
        # In each cell, there are 2 choices
        #   Place a queen or not
        # To place a queen, there should be no queen
        # in the same row, column, diag, antidiag

        rows, columns, diags, antidiags = set(), set(), set(), set()

        def backtrack(result, board, n, i, columns, diags, antidiags):

            if i == n:
                new_board = []
                for row in board:
                    new_board.append("".join(row))
                # if new_board not in result:
                result.append(new_board)
                print(result)

            for j in range(n):
                if j not in columns \
                    and i + j not in diags \
                    and i - j not in antidiags:
                    board[i][j] = "Q"
                    # rows.add(i)
                    columns.add(j)
                    diags.add(i+j)
                    antidiags.add(i-j)
                    backtrack(result, board, n, i+1, columns, diags, antidiags)
                    board[i][j] = "."
                    # rows.remove(i)
                    columns.remove(j)
                    diags.remove(i+j)
                    antidiags.remove(i-j)

        result = []
        board = [["."] * n for _ in range(n)]
        backtrack(result, board, n, 0, columns, diags, antidiags)
        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/n-queens">51. N-Queens</a>
  </div>
</div>

<div class="card mb-4" id="binary-">
  <div class="card-body">
    <h2 class="card-title">Subset (M)</h2>

<pre><code class="python">class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:

        # Backtracking
        #   j is the index of first element to add to current combination

        # Time O(n*(2**n))
        #   n = len(nums)
        # Space O(n)
        def backtrack(j, current, nums, result):
            result.append(current[:])            
            for i in range(j, len(nums)):
                current.append(nums[i])
                backtrack(i+1, current, nums, result)
                current.pop()

        result = []
        backtrack(0, [], nums, result)
        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/subsets">78. Subsets</a>
  </div>
</div>

<div class="card mb-4" id="backtracking-">
  <div class="card-body">
    <h2 class="card-title">Word Search (M)</h2>

<pre><code class="python">class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:

        # Backtrack
        # At each index, there are 4 directional choices
        # Return when the path equals to word

        # Time O(m*(3**n))
        #   n = len(word)
        #   m = number of cells in board
        #   At each position, there are 4 different path to take 
        #   But, because we can't go back to previous position,
        #   this reduces to 3 
        # Space O(n)
        def backtrack(board, word, path, explored, dirs, i, j, k, n, m, result):

            if len(path) == len(word):
                result.append("".join(path))
                return
                
            for x, y in dirs:
                if 0 <= i + x < n \
                    and 0 <= j + y < m \
                    and board[i+x][j+y] == word[k] \
                    and (i+x, j+y) not in explored:
                    explored.add((i+x, j+y))
                    path.append(board[i+x][j+y])
                    backtrack(board, word, path, explored, dirs, i+x, j+y, k+1, n, m, result)
                    path.pop()
                    explored.remove((i+x, j+y))

        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        result = []
        n, m = len(board), len(board[0])
        for i in range(n):
            for j in range(m):
                if board[i][j] == word[0]:
                    explored = set()
                    explored.add((i,j))
                    backtrack(board, word, [word[0]], explored, dirs, i, j, 1, n, m, result)
                    if result:
                        return True
                    
        return False</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/word-search">79. Word Search</a>
  </div>
</div>

<div class="card mb-4" id="backtracking-">
  <div class="card-body">
    <h2 class="card-title">Palindrome Partitioning (M)</h2>

<pre><code class="python">class Solution:
    def partition(self, s: str) -> List[List[str]]:

        # Backtracking
        #   For every possible substring, check palindrome

        def is_palindrome(s):
            return s == s[::-1]

        # Time O(n*(2**n))
        #   n = len(s)
        #   O(n) to check if substring is palindrom
        #   O(2**n) possible substrings
        # Space O(n)
        #   Recursion stack
        def backtrack(s, i, result, partitions):

            if i == len(s):
                result.append(list(partitions))
                
            for j in range(i, len(s)):
                if is_palindrome(s[i:j+1]):
                    partitions.append(s[i:j+1])
                    # After appending substring s[i:j+1],
                    # Start scannign from index j + 1
                    backtrack(s, j+1, result, partitions)
                    partitions.pop()

        result = []
        backtrack(s, 0, result, [])
        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/palindrome-partitioning">131. Palindrome Partitioning</a>
  </div>
</div>

<div class="card mb-4" id="backtracking-">
  <div class="card-body">
    <h2 class="card-title">Robot Room Cleaner (H)</h2>

<pre><code class="python"># """
# This is the robot's control interface.
# You should not implement it, or speculate about its implementation
# """
#class Robot:
#    def move(self):
#        """
#        Returns true if the cell in front is open and robot moves into the cell.
#        Returns false if the cell in front is blocked and robot stays in the current cell.
#        :rtype bool
#        """
#
#    def turnLeft(self):
#        """
#        Robot will stay in the same cell after calling turnLeft/turnRight.
#        Each turn will be 90 degrees.
#        :rtype void
#        """
#
#    def turnRight(self):
#        """
#        Robot will stay in the same cell after calling turnLeft/turnRight.
#        Each turn will be 90 degrees.
#        :rtype void
#        """
#
#    def clean(self):
#        """
#        Clean the current cell.
#        :rtype void
#        """

class Solution:
    def cleanRoom(self, robot):
        """
        :type robot: Robot
        :rtype: None
        """

        # Backtracking
        # Always turn right
        # Consider visited cell as obstacle
        # Explore up, right, down, left in order
        #   if no obstacle
        #     Move
        #     Explore the next cell
        #     Backtrack 
        #   Else
        #     Turn right    

        # Up, down, right, left
        dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        visited = set()

        def move_back():
            robot.turnRight()
            robot.turnRight()
            robot.move()
            robot.turnRight()
            robot.turnRight()

        # Time O(n-m)
        #   n = number of cells
        #   m = number of obstacles
        # Space O(n-m)
        def backtrack(p, d):

            visited.add(p)
            # Clean the current cell
            robot.clean()

            # Explore up, right, down, left in order
            # Let up = 0, right = 1, down = 2, left = 3
            for i in range(4):
                new_d = (d+i) % 4
                new_p = (p[0]+dirs[new_d][0], p[1]+dirs[new_d][1])
                
                # If no obstacle, move and explore the next cell
                if new_p not in visited and robot.move():
                    backtrack(new_p, new_d)
                    move_back()
                robot.turnRight()

        # Initial direction of the robot will be facing up
        backtrack((0, 0), 0)</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/robot-room-cleaner">489. Robot Room Cleaner</a>
  </div>
</div>
<!-- Backtracking END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>