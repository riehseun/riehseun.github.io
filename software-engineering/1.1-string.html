<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax/tex-chtml.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- String BEGIN -->
<div class="card mb-4" id="string">
  <div class="card-body">
    <h2 class="card-title">String</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#string-">Zigzag Conversion</a></li>
      <li><a href="#string-">Roman to integer</a></li>
      <li><a href="#string-">Longest common prefix</a></li>
      <li><a href="#string-">Letter Combinations of a Phone Number</a></li>
      <li><a href="#string-">Find the Index of the First Occurrence in a String</a></li>
      <!-- <li><a href="#string-">Length of last word</a></li> -->
      <li><a href="#string-">Count and say</a></li>
      <li><a href="#string-">Group Anagrams</a></li>
      <li><a href="#string-">Valid number</a></li>
      <li><a href="#string-">Simplify path</a></li>
      <li><a href="#string-">Isomorphic Strings</a></li>
      <!-- <li><a href="#string-">Palindrome permutation</a></li> -->
      <li><a href="#string-">Valid Anagram</a></li>
      <li><a href="#string-">Integer to english words</a></li>
      <li><a href="#string-">Valid Word Abbreviation</a></li>
      <!-- <li><a href="#string-">Longest palindrome</a></li> -->
      <li><a href="#string-">Custom Sort String</a></li>
      <li><a href="#string-">Merge Strings Alternately</a></li>
      <li><a href="#string-">Minimum Add to Make Parentheses Valid</a></li>
      <li><a href="#string-">Verifying an Alien Dictionary</a></li>
      <li><a href="#string-">Find Common Characters</a></li>
      <li><a href="#string-">Reverse Substrings Between Each Pair of Parentheses</a></li>
      <li><a href="#string-">Minimum Deletions to Make String Balanced</a></li>
      <li><a href="#string-">Number of Senior Citizens</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Zigzag Conversion (M) (G)</h2>

<pre><code class="python">class Solution:
    def convert(self, s: str, numRows: int) -> str:

        # Place each char into different rows
        #   Increment rows until hitting the last row
        #   Decremetn rows until hitting the first row

        if numRows == 1:
            return s

        rows = [""] * numRows
        index = 0
        direction = -1

        # Time O(n) n = len(s)
        # Space O(n)
        for char in s:
            rows[index] += char

            if index == 0 or index == numRows - 1:
                if direction == 1:
                    direction = -1
                elif direction == -1:
                    direction = 1

            if direction == 1:
                index += 1
            elif direction == -1:
                index -= 1

        return "".join(rows)</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/zigzag-conversion">6. Zigzag Conversion</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Roman to integer (E) (G/F/A)</h2>

<pre><code class="python">class Solution:
    def romanToInt(self, s: str) -> int:
        """
        :type s: str
        :rtype: int
        """

        # Dictionary to store symbol-value mapping

        roman = {'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000, "IV":4, "IX":9, "XL":40, "XC":90, "CD":400, "CM":900}
        # roman["I"] = 1
        # roman["V"] = 5
        # roman["X"] = 10
        # roman["L"] = 50
        # roman["C"] = 100
        # roman["D"] = 500
        # roman["M"] = 1000
        # roman["IV"] = 4
        # roman["IX"] = 9
        # roman["XL"] = 40
        # roman["XC"] = 90
        # roman["CD"] = 400
        # roman["CM"] = 900

        tokenize = []

        i = 0

        # Time O(n) n = len(s)
        # Space O(n)
        while i < len(s):
            if s[i] == "I" and i < len(s)-1:
                if s[i+1] == "V" or s[i+1] == "X":
                    tokenize.append(s[i:i+2])
                    i += 2
                    continue

            elif s[i] == "X" and i < len(s)-1:
                if s[i+1] == "L" or s[i+1] == "C":
                    tokenize.append(s[i:i+2])
                    i += 2
                    continue

            elif s[i] == "C" and i < len(s)-1:
                if s[i+1] == "D" or s[i+1] == "M":
                    tokenize.append(s[i:i+2])
                    i += 2
                    continue

            tokenize.append(s[i])
            i += 1

        result = 0
        for token in tokenize:
            result += roman[token]

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/roman-to-integer">13. Roman to Integer</a>
  </div>
</div>


<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Longest common prefix (M) (G/F/A) !</h2>

<pre><code class="python">class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:

        longest_common_prefix = ""

        # Time O(n*m) n = len(strs) m = shortest length of word
        # Space O(1)
        for chars in zip(*strs):
            if all(char == chars[0] for char in chars[1:]):
                longest_common_prefix += chars[0]
            else:
                break

        return longest_common_prefix</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/longest-common-prefix">14. Longest Common Prefix</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Letter Combinations of a Phone Number (M) (F/A)</h2>

<pre><code class="python">class Solution:
    def letterCombinations(self, digits: str) -> List[str]:

        # Recursively compute all possible combinations
        # Add each letter matching the current digit to allw
        # existing items in the resulting array

        # Example
        # a b c
        # ad bd cd ae be ce af bf cf

        # Store the mapping between number and letter in a dictionary
        mapping = {
            "2":"abc",
            "3":"def",
            "4":"ghi",
            "5":"jkl",
            "6":"mno",
            "7":"pqrs",
            "8":"tuv",
            "9":"wxyz"
        }

        # Edge case
        if len(digits) == 0:
            return []

        result = []
        for char in mapping[digits[0]]:
            result.append(char)

        for digit in digits[1:]:
            result_old = result[:]
            for char in mapping[digit]:
                for item in result_old:
                    result.append(item+char)
            for item in result_old:
                result.remove(item)

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number">17. Letter Combinations of a Phone Number</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Find the Index of the First Occurrence in a String (E) (G)</h2>

<pre><code class="python">class Solution:
    def strStr(self, haystack: str, needle: str) -> int:

        if haystack == needle:
            return 0

        # Time O(n) n = len(haystack)
        # Space O(1)
        for i in range(len(haystack)-len(needle)+1):
            print(haystack[i:i+len(needle)])
            print(needle)
            if haystack[i:i+len(needle)] == needle:
                return i

        return -1</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string">28. Find the Index of the First Occurrence in a String</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Count and say (M) (F)</h2>

<pre><code class="python">class Solution:
    def countAndSay(self, n: int) -> str:

        # The meaning of countAndSay(n) = run length of countAndSay(n-1)
        # 1 -> 1
        # 2 -> 11
        # 3 -> 21
        # 4 -> 1211
        # 5 -> 111221
        # 6 -> 312211
        # 7 -> 13112221

        # Loop through 1 to n
        #   Remember the value of countAndSay(n-1)
        #   Compute run length of countAndSay(n-1) to figure out
        #   the value of countAndSay(n)
        #   Recurse

        # Base case
        if n == 1:
            return "1"

        previous_value = "1"
        result = ""

        # Time O(?)
        # Space O(1) if ignoring space for output
        for i in range(1, n):
            count = 1
            for j in range(len(previous_value)-1):
                if previous_value[j] == previous_value[j+1]:
                    count += 1
                else:
                    result += (str(count)+previous_value[j])
                    count = 1

            result += (str(count)+previous_value[-1])
            previous_value = result
            result = ""

        return previous_value</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/count-and-say">38. Cound and Say</a>
  </div>
</div>

<!-- <div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Length of last word (E)</h2>

<pre><code class="python">class Solution:
    def lengthOfLastWord(self, s: str) -> int:

        # Time O(n) n = len(s)
        # Space O(n) n = len(s)
        return len(s.strip().split()[-1])</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/length-of-last-word">58. Length of Last Word</a>
  </div>
</div>
-->

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Group Anagrams (M) (G/A)</h2>

<pre><code class="python">class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:

        # Use hash table to store sorted version of each string

        anagrams_dict = defaultdict(list)

        # Time O(nlogm) n = len(strs), m = max length of each string
        # Space O(n)
        for string in strs:
            string_sorted = ''.join(sorted(string))
            anagrams_dict[string_sorted].append(string)

        result = []

        for k,v in anagrams_dict.items():
            result.append(v)

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/group-anagrams">49. Group Anagrams</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Valid number (H) (F) !</h2>

<pre><code class="python">class Solution:
    def isNumber(self, s: str) -> bool:

        # Each char must be digit, sign, exponent, dot
        # Input cannot end with a sign or an exponent
        # There must be at least one digit in the input
        # If there is a sign, it must be either
        #   First character in the input
        #   First character after an exponent
        # There cannot be more than one exponent in the input
        # If an exponent exists, a digit must have existed beforehand
        # There cannot be more than one dot in the input
        # If a dot exists, there should be no exponent beforehand

        digit_exist = False
        exponent_exist = False
        dot_exist = False

        # Time O(n) n = len(s)
        # Space O(1)
        for i, c in enumerate(s):
            if c.isdigit():
                digit_exist = True
            elif c == "-" or c == "+":
                if i > 0 \
                    and (s[i-1] != "e" and s[i-1] != "E"):
                    return False
                if i == len(s) - 1:
                    return False
            elif c == "e" or c == "E":
                if exponent_exist:
                    return False
                if not digit_exist:
                    return False
                if i == len(s) - 1:
                    return False
                exponent_exist = True
            elif c == ".":
                if dot_exist:
                    return False
                if exponent_exist:
                    return False
                dot_exist = True
            else:
                return False

        if not digit_exist:
            return False

        return True</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/valid-number">65. Valid Number</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Simplify path (M) (F) !</h2>

<pre><code class="python">class Solution:
    def simplifyPath(self, path: str) -> str:

        # Split the input by delimiter "/"
        # Read the tokens from right to left
        #   If empty string or ".", skip
        #   If "..", skip the current and next token

        # Ex. "/.../a/../b/c/../d/./"
        #  => "...", "a", "..", "b", "c", "..", "d", "."

        result = ""
        tokens = path.split("/")
        i = len(tokens) - 1
        to_skip = 0

        # Time O(n) n = len(path)
        # Space O(n)
        while i > 0:

            if tokens[i] == "" or tokens[i] == ".":
                i -= 1
                continue

            elif tokens[i] == "..":
                to_skip += 1
                i -= 1
                continue

            if to_skip > 0:
                to_skip -= 1
                i -= 1
                continue

            else:
                result = "/" + tokens[i] + result
                i -= 1

        if not result:
            return "/"

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/simplify-path">71. Simplify Path</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Isomorphic Strings (E) (A)</h2>

<pre><code class="python">class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:

        # Count the unique number of chars in both string

        # Time O(n) n = len(s) = len(t)
        # Space O(1)
        return len(set(s)) == len(set(t)) == len(set(zip(s,t)))</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/isomorphic-strings">205. Isomorphic Strings</a>
  </div>
</div>

<!-- <div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Palindrome permutation (E)</h2>

<pre><code class="python">class Solution:
    def canPermutePalindrome(self, s: str) -> bool:

        # Just one char should have odd number of counts
        # Rest of chars should have even number of counts

        counts = defaultdict(int)

        # Time O(n) n = len(s)
        # Space O(n)
        for c in s:
            counts[c] += 1

        odd_count = 0
        for count in counts.values():
            if count % 2 != 0:
                odd_count += 1

        if odd_count > 1:
            return False

        return True</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/palindrome-permutation">266. Palindrome Permutation</a>
  </div>
</div> -->

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Valid Anagram (E) (A)</h2>

<pre><code class="python">class Solution:
    def isAnagram(self, s: str, t: str) -> bool:

        # Hash table

        # Time O(max(n,m)) n = len(s), m = len(t)
        # Space O(max(n,m))
        count_s = defaultdict(int)

        for char in s:
            count_s[char] += 1

        count_t = defaultdict(int)

        for char in t:
            count_t[char] += 1

        if count_s == count_t:
            return True

        return False</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/valid-anagram">242. Valid Anagram</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Integer to english words (H) (G/F/A)</h2>

<pre><code class="python"></code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/integer-to-english-words">273. Integer to English Words</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Valid Word Abbreviation (E) (F) !</h2>

<pre><code class="python">class Solution:
    def validWordAbbreviation(self, word: str, abbr: str) -> bool:

        # Tokenize "abbr" by letters and numbers
        # If any token is 0, return False
        # Go through "word" by tokens

        # Ex. word = "hi", abbr = "hi1"
        if len(abbr) > len(word):
            return False

        # Ex. word = "a", abbr = "2"
        if abbr.isdigit() and not abbr.startswith("0"):
            return int(abbr) == len(word)

        tokens = re.findall(r'\D+|\d+', abbr)
        i = 0
        seen_digit = False

        # Time O(n) where n = max(len(word), len(abbr))
        # Space O(1)
        for token in tokens:
            if token.isdigit():
                # Leading zeros are not allowed
                if token.startswith("0") and not seen_digit:
                    return False
                seen_digit = True
                i += int(token)
            else:
                for char in token:
                    # Ex. word = "hi", abbr = "2i"
                    if i < len(word):
                        if word[i] != char:
                            return False
                        i += 1
                    else:
                        return False

        # Ex. word = "hi", abbr = "h2"
        # Ex. word = "word", abbr = "2r0"
        if i != len(word):
            return False

        return True</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/valid-word-abbreviation">408. Valid Word Abbreviation</a>
  </div>
</div>

<!-- <div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Longest palindrome (E)</h2>

<pre><code class="python">class Solution:
    def longestPalindrome(self, s: str) -> int:

        # If every letter has even count, then count(s)
        # Else, round down count for each char + 1

        count = {}

        for char in s:
            if char not in count:
                count[char] = 1
            else:
                count[char] += 1

        max_length = 0
        is_all_count_even_number = True
        for key,val in count.items():
            if val % 2 == 0:
                max_length += val
            else:
                is_all_count_even_number = False
                max_length += (val-1)

        if is_all_count_even_number:
            return max_length
        else:
            return max_length + 1</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/longest-palindrome">409. Longest Palindrome</a>
  </div>
</div> -->

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Custom Sort String (M) (F) !</h2>

<pre><code class="python">class Solution:
    def customSortString(self, order: str, s: str) -> str:

        # Create hash table for string "order"
        # Create another hash table whose key is order number
        # First sort the second dictionary by key and concatenate values

        orderings = defaultdict(int)
        indexes = defaultdict(list)

        # Time O(n) n = max(len(order), len(s))
        # Time O(n)
        for i, c in enumerate(order):
            orderings[c] = i

        for c in s:
            indexes[orderings[c]].append(c)

        indexes = dict(sorted(indexes.items()))

        result = ""
        for key,val in indexes.items():
            for c in val:
                result += c

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/custom-sort-string">791. Custom Sort String</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Merge Strings Alternately (E) (G/F/A)</h2>

<pre><code class="python">class Solution:
    def mergeAlternately(self, word1: str, word2: str) -> str:

        result = ""
        i = 0
        j = 0

        # Time O(max(n,m)) n = len(word1), m = len(word2)
        # Space O(n+m)
        while i < len(word1) and j < len(word2):
            result += word1[i]
            result += word2[j]
            i += 1
            j += 1

        if i < len(word1):
            result += word1[i:len(word1)]

        if j < len(word2):
            result += word2[j:len(word2)]

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/merge-strings-alternately">768. Merge Strings Alternately</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Minimum Add to Make Parentheses Valid (M) (F) !</h2>

<pre><code class="python">class Solution:
    def minAddToMakeValid(self, s: str) -> int:

        # Track number of matching opening and closing open_brackets

        open_brackets = 0
        add_needed = 0

        # Time O(n) n = len(s)
        # Space O(1)
        for c in s:
            if c == "(":
                open_brackets += 1
            if c == ")":
                if open_brackets > 0:
                    open_brackets -= 1
                else:
                    add_needed += 1

        return add_needed + open_brackets</code></pre>
  </div>
  <div class="card-footer text-muted">
    <a href="https://leetcode.com/problems/minimum-add-to-make-parentheses-valid">921. Minimum Add to Make Parentheses Valid</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Verifying an Alien Dictionary (E) (F)</h2>

<pre><code class="python">class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:

        # Use hash table to store ordering
        # Compare ordering between a word and its next word

        ordering_map = defaultdict(int)
        for i, char in enumerate(order):
            ordering_map[char] = i

        # Time O(n) n = total number of chars in words array
        # Space O(1) hash table will have max 26 keys
        for i in range(len(words)-1):
            for j in range(len(words[i])):

                # Ex. word[i] == "apple", word[i+1] == "app"
                if j >= len(words[i+1]):
                    return False

                if words[i][j] != words[i+1][j]:
                    if ordering_map[words[i][j]] > ordering_map[words[i+1][j]]:
                        print(ordering_map[words[i][j]])
                        print(ordering_map[words[i+1][j]])
                        return False
                    break

        return True</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/verifying-an-alien-dictionary">953. Verifying an Alien Dictionary</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Find Common Characters (E)</h2>

<pre><code class="python">class Solution:
    def commonChars(self, words: List[str]) -> List[str]:

        # Use two hash tables

        first_chars = defaultdict(int)
        keys_to_delete = set()
        for char in words[0]:
            first_chars[char] += 1

        # Time O(n) n = length of chars in a string times len(words)
        # Space O(1) only 26 keys in dictionary
        for i in range(1, len(words)):
            other_chars = defaultdict(int)
            for char in words[i]:
                other_chars[char] += 1
            # Reconciliate
            for key, val in first_chars.items():
                if key not in other_chars:
                    keys_to_delete.add(key)
            for key, val in other_chars.items():
                if key in first_chars:
                    first_chars[key] = min(first_chars[key], val)

        for key in keys_to_delete:
            del first_chars[key]

        result = []
        for key, val in first_chars.items():
            for _ in range(val):
                result.append(key)

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/find-common-characters">1002. Find Common Characters</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Reverse Substrings Between Each Pair of Parentheses (M)</h2>

<pre><code class="python">class Solution:
    def reverseParentheses(self, s: str) -> str:

        # Stack
        # Find indices of opening and its matching closing parenthesis
        # How to build string
        #   Traverse string
        #   When seeing opening or closing parenthesis
        #     Jump to its matching parenthesis and reverse reading direction

        stack = []
        index_pairs = defaultdict(int)

        # Time O(n) n = len(s)
        # Space O(n)
        for i,c in enumerate(s):
            if c == "(":
                stack.append((i,c))
            elif c == ")":
                if stack[-1][1] == "(":
                    index, char = stack.pop()
                    index_pairs[index] = i
                    index_pairs[i] = index

        result = ""
        i = 0
        direction = 1

        while i < len(s):
            if s[i] == "(" or s[i] == ")":
                i = index_pairs[i]
                direction = -direction
            else:
                result += s[i]
            i += direction

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses">1190. Reverse Substrings Between Each Pair of Parentheses</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Minimum Deletions to Make String Balanced (M)</h2>

<pre><code class="python">class Solution:
    def minimumDeletions(self, s: str) -> int:

        # Assume we want to build string like aaaaabbbbb
        # Then, at index i
        #   a's that is right of i must be converted to b
        #   b's that is left of i must be converted to a

        a_count = 0
        b_count = 0

        # Time O(n) n = len(s)
        # Space O(1)
        for c in s:
            if c == "a":
                a_count += 1

        min_deletion = len(s)
        for c in s:
            if c == "a":
                a_count -= 1
            min_deletion = min(min_deletion, a_count+b_count)
            if c == "b":
                b_count += 1

        return min_deletion</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/minimum-deletions-to-make-string-balanced">1653. Minimum Deletions to Make String Balanced</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Number of Senior Citizens (E)</h2>

<pre><code class="python">class Solution:
    def countSeniors(self, details: List[str]) -> int:

        count = 0

        # Time O(n) n = len(details)
        # Space O(1)
        for detail in details:
            age = detail[11:13]
            if int(age) > 60:
                count += 1

        return count</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/number-of-senior-citizens">2678. Number of Senior Citizens</a>
  </div>
</div>
<!-- String END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>