<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax/tex-chtml.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- System design BEGIN -->
<div class="card mb-4" id="system-design">
  <div class="card-body">
    <h2 class="card-title">System design</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#system-design-">System design</a></li>
      <li><a href="#system-design-">Building blocks</a></li>
      <ul>
        <li><a href="#system-design-">DNS</a></li>
        <li><a href="#system-design-">CDN</a></li>
        <li><a href="#system-design-">Load balancer</a></li>
        <li><a href="#system-design-">Database</a></li>
        <li><a href="#system-design-">Cache</a></li>
        <li><a href="#system-design-">Message queue</a></li>
      </ul>
      <li><a href="#system-design-">Non-functional requirements</a></li>
      <ul>
        <li><a href="#system-design-">Availability</a></li>
        <li><a href="#system-design-">Reliability</a></li>
        <li><a href="#system-design-">Scalability</a></li>
        <li><a href="#system-design-">Performance</a></li>
        <li><a href="#system-design-">Consistency</a></li>
      </ul>
      <li><a href="#system-design-">Distributed system</a></li>
      <li><a href="#system-design-">Data intensive application</a></li>
      <li><a href="#system-design-">Deployment</a></li>
      <li><a href="#system-design-">Network</a></li>
      <li><a href="#system-design-">Security</a></li>
      <li><a href="#system-design-">Back-of-the-envelop</a></li>
      <li><a href="#system-design-">Resource estimation</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">System design</h2>
    <ul>
      <li>Communicate</li>
      <ul>
        <li>Do not jump into a solution</li>
        <li>Ask to clarify the requirement, make proper assumption, gather information to understand the scale and constraints</li>
        <ul>
          <li>What specific features are we building?</li>
          <li>How many users?</li>
          <li>How fast does the system scale? 3 months, 6 months, etc?</li>
          <li>What existing services are there to leaverage?</li>
        </ul>
        <li>Do a recap of design</li>
        <li>Be open to feedbacks</li>
      </ul>
      <li>Talking points</li>
      <ul>
        <li>Discuss trade-off and user experience</li>
        <ul>
          <li>Consider 2-3 solutions</li>
          <li>Justify chosen decision</li>
        </ul>
        <li>Describe components and their interactions</li>
        <li>Describe complete lifecycle of a request</li>
        <li>Discuss potential bottlenecks</li>
        <li>Dicusss future problems as system scales</li>
        <li>Describe failover</li>
        <li>Discuss user experience when failure happens</li>
        <li>Discuss peak load</li>
      </ul>
      <li>REHASDE</li>
      <ul>
        <li>Requirement</li>
        <li>Estimation</li>
        <li>High-level design</li>
        <li>API</li>
        <li>Database</li>
        <li>Detailed design</li>
        <li>Evaluation</li>
      </ul>
    </ul>

    <!-- <h3 class="card-title">High level design</h3>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/sd-cicd.png" alt="Card image cap">

    <h3 class="card-title">Component design</h3> -->

  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/system-design-interview-handbook">The System Design Interview Prep Handbook</a>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Building blocks</h2>

    <img class="img-fluid" class="card-img-top" src="/software-engineering/system-design/system-design1.png" alt="Card image cap">

    <ul>
      <li>Search system</li>
      <ul>
        <li>Crawler</li>
        <li>Indexer</li>
        <li>Searcher</li>
      </ul>
      <li>Load balancer</li>
      <li>CDN</li>
      <li>Cache</li>
      <li>Front-end (web) servers</li>
      <ul>
        <li>Serves static content</li>
      </ul>
      <li>Analytics</li>
      <li>Storage</li>
      <ul>
        <li>Relational DB</li>
        <li>Non-relational DB</li>
        <li>Blob store</li>
      </ul>
      <li>Task queue</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: System Design Interview, Alex Xu
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">DNS</h2>
    <ul>
      <li>Maps domain names to IP addresses</li>
      <li>Router or ISP tells which DNS server to contact for IP lookup</li>
      <li>Resource record</li>
      <ul>
        <li>A - hostname to IP address mapping</li>
        <li>CNAME - alias to hostname (canonical) mapping</li>
        <ul>
          <table>
            <tr>
              <td>NAME</td>
              <td>TYPE</td>
              <td>VALUE</td>
            </tr>
            <tr>
              <td>bar.example.com</td>
              <td>CNAME</td>
              <td>foo.example.com</td>
            </tr>
            <tr>
              <td>foo.example.com</td>
              <td>A</td>
              <td>192.0.2.23</td>
            </tr>
          </table>
          <li>The canonical (true) name of "bar.example.com" is "foo.example.com"</li>
          <li>"foo.example.com" has A record pointing to IP address 192.0.2.23</li>
        </ul>
      </ul>
      <li>Ex. CloudFlare, Route 53</li>
    </ul>

    <h3 class="card-title">FQDN (Fully Qualified Domain Name)</h3>
    <ul>
      <li>Complete domain name of computer, host, or internet</li>
      <li>When connecting to a host, FQDN must be specified</li>
      <li>Then, DNS server finds IP address from the hostname</li>
      <li>Ex. www.github.com - [hostname].[domain].[tld] (tld - top-level domain)</li>
    </ul>

    <h3 class="card-title">DNS server</h3>
    <ul>
      <li>DNS resolver - forward requests to the other DNS name servers</li>
      <ul>
        <li>For example, <code>/etc/resolv.conf</code> in Linux contains DNS resolver's IP address</li>
      </ul>
      <li>Root-level name servers - return a list of top-level domain (TLD) servers that hold the IP addresses of the domain</li>
      <ul>
        <li>Domain examples - .com, .org, .io</li>
      </ul>
      <li>Top-level domain (TLD) name servers - hold IP addresses of authoritative name servers</li>
      <li>Authoritative name servers - provide IP addresses of the web or application servers</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: System Design Interview, Alex Xu
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">CDN</h2>
    <ul>
      <li>Geographically distributed proxy servers, that are placed on the network edge, close to end users</li>
      <li>Generally serves static contents like image, video, CSS, JS</li>
      <li>Ex. Amazon CloudFront</li>
    </ul>

    <h3 class="card-title">Push CDN</h3>
    <ul>
      <li>Content gets sent automatically to CDN proxy servers from the origin server</li>
      <li>Appropriate for static content delivery and low traffic</li>
    </ul>

    <h3 class="card-title">Pull CDN</h3>
    <ul>
      <li>CDN pulls the unavailable data from origin servers when requested by users</li>
      <li>TTL determines how long content is cached on CDN</li>
      <li>Appropriate for dynamic content delivery and heavy traffic</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: System Design Interview, Alex Xu
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Load balancer</h2>
    <ul>
      <li>GSLB (Global Server Load Balancing) distributes traffic across different geographical regions</li>
      <li>Private IP is used to communitcate between servers (reachable only within the same network, unreachable over internet)</li>
      <li>Redundancy</li>
      <ul>
        <li>Use multiple LBs so that they can't be single point of failure</li>
        <li>They monitor health of each other</li>
        <li>In case primary fails, the secondary takes over</li>
      </ul>
      <li>Ex. NGINX, HAProxy</li>
    </ul>

    <h3 class="card-text">Benefites</h3>
    <ul>
      <li>Throughput is improved by parallel processing</li>
      <li>Yield higher availability</li>
      <li>SSL offload - client connects to load balancer via SSL, but redirect requests to servers are made via unencrypted HTTP to reduce load on the servers</li>
      <ul>
        <li>No need to install X.509 certificates on each server</li>
      </ul>
      <li>Caching - load balancer can cache popular requests</li>
    </ul>

    <h3 class="card-text">Serving response back</h3>
    <ul>
      <li>Proxing - load balancer receives response from backend and relays it back to the client</li>
      <li>TCP Handoff - server sends response directly to the client</li>
    </ul>

    <h3 class="card-text">Types</h3>
    <ul>
      <li>Equitable dispatching - uses simple round-robin algorithm to distribute traffic evenly between all nodes</li>
      <ul>
        <li>Ex. AWS Elastic Load Balancer (ELB)</li>
      </ul>
      <li>Hash-based distribution - requests from the same client for the duration of session are directed to the same server every time by hashing metadata</li>
      <ul>
        <li>Ex. Azure Load Balancer</li>
        <li>Pros - store session data in memory rather than shared data storage like Redis cache</li>
        <li>Cons - caching work causes small latency</li>
      </ul>
    </ul>

    <h3 class="card-title">Reverse proxy</h3>
    <ul>
      <li>Proxy hides identity of clients. Reverse proxy hides identity of servers</li>
      <li>Proxy sits on top of clients - used for blocking certain contents (servers are freely accessible through internet)</li>
      <li>Reverse proxy sit on top of servers - used for protection from attacks and SSL encrypting (clients can freely connect to internet)</li>
      <li>Can act as load-balancing but is also useful when there is a single server to increase security</li>
      <li>Ex. NGINX, HAProxy (These are load balancers but they can serve as reverse proxy too</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: System Design Interview, Alex Xu
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Database</h2>
    <ul>
      <li>Performance and scalability - separate read and write server so that queries can be procesed in parallel</li>
      <li>Reliability - queries can still be served when some servers are down</li>
    </ul>

    <h3 class="card-title">Data types</h3>
    <ul>
      <li>Structured - relational data</li>
      <li>Semi-structured - ymal, json, xml</li>
      <li>Unstructured - photo, video, audio, text</li>
    </ul>

    <h3 class="card-title">When to choose what</h3>
    <ul>
      <li>SQL - ACID, data is unchanging</li>
      <li>NoSQL - large amount of data with no structure, rapid development</li>
    </ul>

    <h3 class="card-title">Relational model (SQL)</h3>
    <ul>
      <li>Attribute - a column</li>
      <li>Tuple - a row</li>
      <li>Degree - number of columns</li>
      <li>Cardinality - number of rows</li>
      <li>Ex. Oracle, DB2, Microsoft SQL Server, PostgreSQL, and MySQL</li>
    </ul>

    <h4 class="card-title">Transaction (ACID)</h4>
    <ul>
      <li>Atomicity - either all is done or none is done</li>
      <li>Consistency - data is consistent before and after transaction</li>
      <li>Isolation - trasaction doesn't get affected by other transactions</li>
      <li>Durablility - transactions are permanently saved</li>
    </ul>

    <h4 class="card-title">Delete Vs. Truncate</h4>
    <ul>
      <li>Truncate - DDL (Data Definition Language)</li>
      <ul>
        <li>Does not require commit to make the change permanent</li>
        <li>Deleted rows cannot be rolled back</li>
        <li>Always removes all rows from the table (Table structure remains intact)</li>
      </ul>
      <li>Delete - DML (Data Manipulation Language)</li>
      <ul>
        <li>Requires commit to make the change permanent</li>
        <li><strong>where</strong> clause can be used</li>
      </ul>
    </ul>

    <h4 class="card-title">DB indexing</h4>
    <ul>
      <li>Applying indexing on a field creates a data structure holding field value and pointer</li>
      <li>Data structure gets sorted so that search time can be O(logn) with binary search</li>
      <li>Fields with lots of duplicate values degrade benefits of indexing</li>
      <li>Degrade write performance having to index data each time write happens</li>
    </ul>

    <h4 class="card-title">Key</h4>
    <ul>
      <li>Primary key - unique identifier which consists of a single attribute. Cannot be NULL</li>
      <li>Candidate key - columns together can uniquely identify a row</li>
      <li>Super key - colums together can uniquely identify all columns</li>
      <li>Foreign key - primary key from another table</li>
      <ul>
        <li>Cannot insert foreign key (which is primary key in the original table) in reference table that does not actually exist in the original table</li>
        <li>Cannot delete primary key in the original table if it is used in the reference table</li>
      </ul>
    </ul>

    <h4 class="card-title">Functional dependency</h4>
    <ul>
      <li>Partial dependency - non-key attribute depends on subset of a composite primary key</li>
      <li>Transitive dependency - non-key attribute depends on another non-key attribute</li>
    </ul>

    <h4 class="card-title">Normalization</h4>
    <ul>
      <li>Process of determining how much redundancy exists in a table</li>
      <li>First normal form - attributes must have single value, not a set of values</li>
      <li>Second normal form - must not have partial dependency</li>
      <li>Third normal form - must not have transitive dependency</li>
      <li>Boyce-Codd normal form - If A->B and B is primary key, then A must also be primary key</li>
    </ul>

    <h3 class="card-title">NoSQL</h3>
    <ul>
      <li>Key-value store</li>
      <ul>
        <li>Array of key-value pairs</li>
        <li>Efficient for session-oriented applications like web applications, cache</li>
        <li>Ex. Redis, Voldemort, Amazon Dynamo DB, Memcached DB</li>
      </ul>
      <li>Document DB</li>
      <ul>
        <li>Documents (XML, JSON) are grouped into collections</li>
        <li>Suitable for unstructured catalog data</li>
        <li>Ex. CouchDB, MongoDB</li>
      </ul>
      <li>Column DB</li>
      <ul>
        <li>Columns instead of tables, no need to know columns up front, best for large datasets</li>
        <li>Ex. Cassandra, HBase</li>
      </ul>
      <li>Graph DB</li>
      <ul>
        <li>When relations are best represented in graphs</li>
        <li>Can be used in social applications</li>
        <li>Ex. Neo4J, OrientDB, InfiniteGraph</li>
      </ul>
      <li>Search engines</li>
      <ul>
        <li>Ex. Solr, ElasticSearch, Splunk</li>
      </ul>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: System Design Interview, Alex Xu
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Cache</h2>
    <ul>
      <li>When receiving requests, servers check if cache has the responses</li>
      <li>Cache-aside</li>
      <ul>
        <li>Cache does not interact with database</li>
        <li>If cache miss, client fetches data from database. Then, client updates the cache</li>
        <li>Cache miss causes three trips</li>
        <li>Ex. Memcached</li>
      </ul>
      <li>Write-through</li>
      <ul>
        <li>Client write to cache, then cache synchronously write to database</li>
        <li>Write operation is slow (Read is fast)</li>
      </ul>
      <li>Write-back</li>
      <ul>
        <li>Client write to cache, then cache asynchronously write to database</li>
        <li>Data loss if cache goes down (Both read and write is fast)</li>
      </ul>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: System Design Interview, Alex Xu
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Message queue</h2>
    <ul>
      <li>Decoupling producer and consumer makes system scalable and reliable</li>
      <li>Ex. Redis, RabbitMQ, Amazon SQS</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: System Design Interview, Alex Xu
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Non-functional requirements</h2>
    <ul>
      <li>Availability</li>
      <li>Reliability</li>
      <li>Scalability</li>
      <li>Performance</li>
      <li>Consistency</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: System Design Interview, Alex Xu
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Availability</h2>
    <ul>
      <li>Percentage of time that the service is accessible to clients (Associated with time loss)</li>
      <li>Ability of the system to remain functional despite failures</li>
      <li>Achieved by replication (Keep multiple copies of data at preferrably different geographic location)</li>
      <li>Reliability means availability, but the opposite is not true</li>
    </ul>

    <h3 class="card-title">Replication</h3>
    <ul>
      <li>Single-master replication (primary-backup replication)</li>
      <ul>
        <li>Primary processes writes locally and propagates to backups</li>
        <li>Scalable for read-heavy (read can happen from any backups) but not so for write-heavy (only primary can handle writes)</li>
        <li>Statement based replication</li>
        <ul>
          <li>Problem - non-deterministic functions such as NOW() or RAND() lead to different values on different nodes</li>
        </ul>
        <li>Write-ahead log (WAL) shipping</li>
        <ul>
          <li>Primary node saves the query before executing it in a log file</li>
          <li>Then, it uses these logs to copy data into the backup nodes</li>
        </ul>
        <li>Logical (row-based) log replication</li>
        <ul>
          <li>All backup nodes replicate the actual data changes</li>
        </ul>
      </ul>
      <li>Multi-master replication (multi-primary replication)</li>
      <ul>
        <li>Multiple primary nodes that process the writes and send them to all other primary and backup nodes to replicate</li>
        <li>Conflict can happen where mutiple nodes modify the same data</li>
      </ul>
      <li>Leaderless replication</li>
      <ul>
        <li>Always write or read from a majority (more than half) of the number of nodes in the system</li>
        <li>The latest value is written to at least one of the nodes in the system</li>
      </ul>
    </ul>

    <h3 class="card-title">Fail over</h3>
    <ul>
      <li>Acive-passive</li>
      <ul>
        <li>Heartbeats are sent from active to passive</li>
        <li>If heartbeats are stopping, passive takes over IP address of active and resumes service</li>
      </ul>
      <li>Acive-active</li>
      <ul>
        <li>Both servers are managing traffic, spreading load between them</li>
      </ul>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: System Design Interview, Alex Xu
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Reliability</h2>
    <ul>
      <li>Probability that the service will perform its functions (Associated with frequency and impact of failure)</li>
      <li>Metrics are mean time between failures and mean time to repair</li>
      <li>Redunduncy of both software components and data, to prevent particularly the data loss</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: System Design Interview, Alex Xu
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Scalability</h2>
    <ul>
      <li>Capability to manage increased demand (For example, number of requests or amounts of data)</li>
      <ul>
        <li>Performance problem - system is slow for a single user</li>
        <li>Scailability problem - system is fast for a single user but slow under heavy load</li>
      </ul>
      <li>Compute load patterns</li>
      <ul>
        <li>Consistent growth</li>
        <li>Constantly fluctuating loads</li>
        <li>Cyclical loads</li>
        <li>Unpredictable bursts</li>
      </ul>
    </ul>

    <h3 class="card-title">Horizontal scaling</h3>
    <ul>
      <li>Vertical scaling or scaling up - adds more resources to a single instance</li>
      <li>Horizontal scaling or scaling out - addition more instances</li>
    </ul>

    <h3 class="card-title">Data partitioning</h3>
    <ul>
      <li>Vertical partitioning</li>
      <ul>
        <li>Divides tables into different servers based on features of data (Split columns)</li>
        <li>Problem when data experiences additional growth</li>
        <li>Queries must hit multiple servers and join operations are needed</li>
      </ul>
      <li>Horizontal partitioning (Sharding)</li>
      <ul>
        <li>Puts different rows to different tables</li>
        <li>Atomic operation is hard to achieve</li>
        <li>It is cheaper to add more servers than growing the existing server as data increases</li>
        <li>Range partitioning</li>
        <ul>
          <li>Split dataset based on specific attribute</li>
          <li>Range based query is easy to implement</li>
          <li>May result in unbalanced servers</li>
        </ul>
        <li>Hash partitioning</li>
        <ul>
          <li>Apply hash function to some attribute of data and mod that hash value by the number of paritions</li>
          <li>Uniform allocation of data across servers</li>
          <li>Range based query is hard to implement</li>
          <li>Adding new servers mean changing hash function and redistribution of data</li>
        </ul>
        <li>Consistent hashing</li>
        <ul>
          <li>Create conceptual ring of hashes from 0 to n−1, where n is the number of available hash values</li>
          <li>Each node and request are put into the ring based on its hash value</li>
          <li>Each request is served by the next node in the ring</li>
          <li>When a new node is added to the ring, its next node need to share keys with the newly added node</li>
          <li>Some node could be heavily loaded compared to others</li>
          <li>Virtual node</li>
          <ul>
            <li>Each node is put into multiple positions in the ring based on multiple hash functions</li>
            <li>Each node can have different number of virtual nodes based on hardware capability</li>
            <li>Load is more uniform</li>
            <li>Ex. Dynamo, Cassandra</li>
          </ul>
          <li>Fixed number of partitions</li>
          <ul>
            <li>Number of partitions is fixed when DB is setup</li>
            <li>Higher number of partitions are created than the nodes</li>
            <li>Paritions are assigned to nodes</li>
            <li>If partition is too small, results in overhead. If partition is too large, rebalancing the nodes will be expensive</li>
            <li>Ex. Elasticsearch</li>
          </ul>
          <li>Dynamic partitioning</li>
          <ul>
            <li>When the size of a partition reaches the threshold, it is split into two partitions</li>
            <li>Difficult to apply dynamic rebalancing while serving the reads and writes</li>
            <li>Ex. HBase, MongoDB</li>
          </ul>
          <li>Partition proportionally to nodes</li>
          <ul>
            <li>Number of partitions is proportionate to the number of nodes, so that every node has fixed partitions</li>
            <li>As the number of nodes increases, the partitions shrink. Rebalancing between paritions may result in unfair split</li>
            <li>Ex. Cassandra</li>
          </ul>
        </ul>
      </ul>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: System Design Interview, Alex Xu
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Performance</h2>

    <h3 class="card-title">Caching</h3>
    <ul>
      <li>Store frequently used data for fast retrieval</li>
    </ul>

    <h3 class="card-title">Autoscaling</h3>
    <ul>
      <li>Dynamically allocate resources to match performance requirements</li>
    </ul>

    <h3 class="card-title">Background jobs</h3>
    <ul>
      <li>Tasks such as batch jobs, intensive processing tasks, and long-running processes should run as background jobs, decoupled from application UI to minimize load</li>
    </ul>

    <h3 class="card-title">Messaging</h3>
    <ul>
      <li>Requests can continue to flow-in without error if application can’t keep up</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: System Design Interview, Alex Xu
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Consistency</h2>
    <ul>
      <li>Considers single object operations</li>
    </ul>

    <h3 class="card-title">Strong consistency (linearizability)</h3>
    <ul>
      <li>Synchronous replication technique (Acknowledgment is not sent to the client until the new value is written to all replicas)</li>
      <li>Once an operation is complete and the ack is delivered to client, it is visible to all other clients</li>
      <li>Ex. updating account password</li>
    </ul>

    <h3 class="card-title">Sequential consistency</h3>
    <ul>
      <li>Preserves the ordering specified by each client’s program</li>
      <li>For example, we don't care what’s the ordering of posts between our friends. But, the posts from a single friend has to be displayed in the right order</li>
    </ul>

    <h3 class="card-title">Causal consistency</h3>
    <ul>
      <li>Operations that are not causally related can be seen in different orders</li>
      <li>For example, comments and their sub-comments must appear in the right order</li>
    </ul>

    <h3 class="card-title">Eventual consistency</h3>
    <ul>
      <li>Do not need to return the latest write as long as the system eventually arrives at a stable state</li>
      <li>Can achieve high availability</li>
      <li>Ex. DNS, Cassandra</li>
    </ul>

    <h3 class="card-title">Weak consistency</h3>
    <ul>
      <li>Read may or may not see the written data</li>
      <li>Ex. Memcached</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: System Design Interview, Alex Xu
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Distributed System</h2>

    <h3 class="card-title">Distributed system challenges</h3>
    <ul>
      <li>Network asynchrony - messages take long to deliver, deliver out of order, or not deliver at all</li>
      <li>Partial failures - only some components fail</li>
      <li>Concurrency - execution of multiple computations intervene each other</li>
    </ul>

    <h3 class="card-title">Failure types</h3>
    <ul>
      <li>Fail-stop - a node halts and remains halted permanently (Easiest scenario)</li>
      <li>Crash - a node halts, but silently</li>
      <li>Omission - a node fails to respond to incoming requests</li>
      <li>Byzantine - a node exhibits arbitrary behavior</li>
    </ul>

    <h3 class="card-title">State</h3>
    <ul>
      <li>Stateless - maintains no state. Performs purely based on the inputs</li>
      <li>Stateful - maintains and updates states. Results depend on this state</li>
    </ul>

    <h3 class="card-title">Quorum</h3>
    <ul>
      <li>We write data to the nodes that are only resposible for write operations. We read data from all nodes and return the latest value</li>
      <ul>
        <li>Write is successful when w-1 nodes respond (Coordinator writes to itself first, so we get w writes in total)</li>
        <li>Wait for r answers before returning the results to the client</li>
      </ul>
      <li>Quorum is achieved when R + W > N. At least one node should be both read and write so that readers could get the latest-written value</li>
      <li>If w > r, fast write but slow read because need to go to many nodes for a value</li>
      <li>If r > w, fast read but slow write because need to write to many nodes synchronously</li>
    </ul>

    <h3 class="card-title">CAP theorem</h3>
    <ul>
      <li>It is impossible to acheive all three at the same time. We can only have two out of three</li>
      <ul>
        <li>Consistency - all nodes see the same data at the same time, every read received the most recent write</li>
        <li>Availability - system must be accessible even when nodes fail, every request receives a response</li>
        <li>Partition tolerance - system must operate even when communications between nodes break</li>
      </ul>
      <li>Network is not reliable, thus we need to support partition tolerance</li>
      <li>We can only choose between consistency or availability in distributed system</li>
      <ul>
        <li>CA - RDBMS (Non-distributed system)</li>
        <li>AP - Dynamo, Cassandra, CouchDB</li>
        <ul>
          <li>BASE DBs choose availability - respond with local data w/o ensuring its the latest with peers</li>
          <li>Good choice if system can live with eventual consistency</li>
        </ul>
        <li>CP - BigTable, HBase</li>
        <ul>
          <li>ACID DBs choose consistency - refuse to respond if cannot check peers</li>
        </ul>
      </ul>
    </ul>

    <h3 class="card-title">PACELC theorem</h3>
    <ul>
      <li>When there is no network partition during normal operation, then choose between latency or consistency</li>
      <li>To guarantee data consistency, the system will have to delay write operations until the data has been propagated across the system successfully, taking a latency hit</li>
      <li>PA system would go for L (latency) and PC system would go for C (consistency)</li>
    </ul>

    <p class="card-text"><strong>Systems that choose A over C can still support eventual consistency but no strong/sequential/casual!</strong></p>

    <h3 class="card-title">Isolation level</h3>
    <ul>
      <li>Considers multi object operations</li>
      <li>Serializability</li>
      <ul>
        <li>Two transactions executed concurrently should give same result</li>
        <li>Prevents all anomalies</li>
      </ul>
      <li>Repeatable read</li>
      <ul>
        <li>Data once read by a transaction will not change throughout its course</li>
      </ul>
      <li>Snapshot isolation</li>
      <ul>
        <li>All reads made in a transaction see a consistent snapshot of the database</li>
      </ul>
      <li>Read committed</li>
      <ul>
        <li>Does not allows a transaction to read a data that has not yet been committed by other transaction</li>
      </ul>
    </ul>

    <h3 class="card-title">Anomaly</h3>
    <ul>
      <li>Dirty write</li>
      <ul>
        <li>Transaction overwrites a value that was written by another transaction that is not committed yet</li>
      </ul>
      <li>Dirty read</li>
      <ul>
        <li>Transaction reads a value that was written by another transaction that is not committed yet</li>
      </ul>
      <li>Fuzzy or non-repeatable read</li>
      <ul>
        <li>Value is retrieved twice during a transaction and the value is different</li>
      </ul>
      <li>Phantom read</li>
      <ul>
        <li>For example, transaction of two queries runs to calculate the maximum and the average. However, another transaction intervenes to insert lots of record, thus making the first transaction return an average that is larger than the maximum</li>
      </ul>
      <li>Lost update</li>
      <ul>
        <li>Two transactions read the same value and then try to update it to two different values</li>
      </ul>
      <li>Read skew</li>
      <ul>
        <li>A transaction can only see partial results of another transaction</li>
      </ul>
      <li>Dirty write</li>
      <ul>
        <li>Two transactions read the same data, but then modify disjoint sets of data</li>
      </ul>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Data intensive application</h2>

    <h3 class="card-text">Data ingestion and preprocessing</h3>
    <ul>
      <li></li>
    </ul>

    <h3 class="card-text">ETL</h3>
    <ul>
      <li></li>
    </ul>

    <h3 class="card-text">Spark</h3>
    <ul>
      <li></li>
    </ul>

    <h3 class="card-text">Kafka</h3>
    <ul>
      <li></li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference:
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Deployment</h2>

    <h3 class="card-text">Release strategy</h3>
    <ul>
      <li>Avoid downtown during deployment</li>
    </ul>

    <h4 class="card-text">Blue-Green</h4>
    <ul>
      <li>Existing production instance is <strong>Blue</strong></li>
      <li>Deploy new instance <strong>Green</strong></li>
      <li>Run tests on <strong>Green</strong> instance</li>
      <li>Make <strong>Green</strong> the production instance</li>
      <ul>
        <li>Re-map DNS to <strong>Green</strong>'s IP address</li>
        <li>Remove <strong>Blue</strong> from load-balancer and add <strong>Green</strong></li>
      </ul>
    </ul>

    <h4 class="card-text">Carnary</h4>
    <ul>
      <li>Similar to Blue-Green but redirect only subset of users instead of all users</li>
      <ul>
        <li>Choose users who are more active, etc</li>
      </ul>
      <li>Both <strong>Blue</strong> and <strong>Green</strong> would be up during this time</li>
      <li>Great way to do capacity testing on new instance</li>
      <ul>
        <li>Can always roll-back by redirecting users to old instance</li>
      </ul>
      <li>Managing multiple versions of software is required</li>
    </ul>

    <h4 class="card-text">Dark-launching</h4>
    <ul>
      <li>Releasing production-ready features to subset of users prior to full release</li>
      <li>Feature toggle - run specific part of code based on configuration stored online</li>
      <li>Turn on features only for subset of users before releasing features to everybody</li>
    </ul>

    <h3 class="card-text">Edge deployment</h3>
    <ul>
      <li>Client data is analyzed as close to the source as possible</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference:
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Network</h2>

    <h3 class="card-title">Network Basics</h3>
    <ul>
      <li>Computers can connect to themselves via 127.0.0.1 (localhost)</li>
      <li>"ipconfig" file provides very useful information</li>
      <li>TCP allows multiple services to share the same physical computer via port</li>
      <ul>
        <li>21 - file transfer (FTP)</li>
        <li>22 - secure shell (SSH)</li>
        <li>25, 110 - email (SMTP, POP3)</li>
        <li>80 - web (HTTP)</li>
        <li>443 - secure web (HTTPS)</li>
        <li>993, 995 - secure email</li>
      </ul>
      <li>UDP is better suited for streaming media and online games</li>
    </ul>

    <h3 class="card-title">TCP/IP</h3>
    <ul>
      <li>Application layer - where end-user applications live</li>
      <ul>
        <li>Presentation - encoding, encryption, compression</li>
        <li>Session - manages user session</li>
      </ul>
      <li>Transport layer - segments data into smaller chunks (Also, add checksum to these chunks)</li>
      <li>Network layer - transports packets</li>
      <li>Data link layer - error detection/correction</li>
      <li>Physical layer - hardware</li>
    </ul>

    <h3 class="card-title">CIDR</h3>
    <ul>
      <li>Classless Inter-Domain Routing (CIDR) is a range of IP addresses a network uses</li>
    </ul>

    <h3 class="card-title">IPv4</h3>
    <ul>
      <li>32-bit address space</li>
      <li>Example: 192.0.2.0/24 (24 means 8-bits / 256 addresses after 192.0.2.0)</li>
    </ul>
    <ul>
      <li>Class A - 10.0.0.0/8 - 16 Million Hosts</li>
      <li>Class B - 10.0.0.0/16 - 65,000 Hosts</li>
      <li>Class C - 10.0.0.0/24 - 254 Hosts</li>
    </ul>

    <h3 class="card-title">IPv6</h3>
    <ul>
      <li>128-bit address space</li>
      <li>Example: 2001:db8::/32 (32 means 96-bits / 76 octillion addresses after 2001:db8::)</li>
    </ul>

    <h3 class="card-text">AJAX polling</h3>
    <ul>
      <li>Client repeatedly polls the server</li>
      <li>A lot of response could be empty, causing HTTP overhead</li>
    </ul>

    <h3 class="card-text">Long-polling</h3>
    <ul>
      <li>Client sends request to server</li>
      <li>Server holds the request rather than sending empty response</li>
      <li>Server pushes information to client only when there is new data</li>
    </ul>

    <h3 class="card-text">WebSocket</h3>
    <ul>
      <li>Persistent connection between client and server</li>
    </ul>

    <h3 class="card-title">Communication</h3>
    <ul>
      <li>Hypertext transfer protocol (HTTP)</li>
      <ul>
        <li>GET, POST, PUT, PATCH, DELETE</li>
        <li>Application layer protocal relying on TCP or UDP</li>
      </ul>
      <li>Transmission control protocol (TCP)</li>
      <ul>
        <li>Guarantees that packets arrive on destination in the correct order and without corruption</li>
      </ul>
      <li>User datagram protocol (UDP)</li>
      <ul>
        <li>Lower latency but packages may arrive on destination out of order or not at all</li>
        <li>Used in video streaming, voice chat, multiplayer game</li>
      </ul>
      <li>Remote procedure call (RPC)</li>
      <ul>
        <li>Client initiates client stub process by giving parameters</li>
        <li>Client stub converts the parameters into standardized format and packs them into a message</li>
        <li>Client RPC runtime delivers the message to the server over the network</li>
        <li>Server RPC runtime receives the message and passes it to the server stub</li>
        <li>Server stub unpacks the message to retrieve the parameters and calls the desired server routine</li>
        <li>Server stub packs the returned result into a message and sends it to RPC runtime at the server</li>
        <li>Server RPC runtime returns the packed result to Client RPC runtime over the network</li>
        <li>Client RPC runtime sends the result to the client stub</li>
        <li>Client stub unpacks the result</li>
        <li>Ex. Protobuf, Thrift, Avro</li>
      </ul>
      <li>Representational State Transfer (REST)</li>
      <ul>
        <li>Architecture for design network applications</li>
        <li>Stateless, client-server, cacheable communcation</li>
        <li>HTTP protocol is used</li>
        <li>Simpler than RPC, Web Services (SOAP, WSDL)</li>
        <li>Ex. www</li>
      </ul>
    </ul>

    <h3 class="card-title">namp</h3>
    <ul>
      <li>What machines are on our network</li>
      <li>What ports are open on those machines</li>
      <li>What operating systems are running on those machines</li>
    </ul>

    <pre><code class="bash">nmap -A &lt;CIDR&gt;  # For example, 192.168.0.0/24</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://docs.rackspace.com/support/how-to/using-cidr-notation-in-cloud-networks">Using CIDR notation in Cloud Networks</a> | <a href="https://techlibrary.hpe.com/docs/otlink-wo/CIDR-Conversion-Table.html">CIDR Conversion Table</a> | <a href="https://www.ipqualityscore.com/free-ip-lookup-proxy-vpn-test/lookup/block">IPv4 CIDR Address Blocks</a>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Security</h2>

    <h3 class="card-title">A layered approach to security</h3>
    <ul>
      <li>Data - attackers are always after this</li>
      <li>Application - free of vulnerabilities, application secrets in a secure storage medium</li>
      <li>Compute - secure access to VMs, implement endpoint protection, keep systems patched and current</li>
      <li>Networking - deny by default, implement secure connectivity to on-premises networks, restrict inbound internet access</li>
      <li>Perimeter - use distributed denial of service (DDoS) protection, use perimeter firewalls to identify malicious attacks</li>
      <li>Identity and access - use SSO and multi-factor authentication</li>
      <li>Physical security - access to physical data centre with compute machines</li>
    </ul>

    <h3 class="card-title">Examples of security breaches and attacks</h3>
    <ul>
      <li>Data - exposing an encryption key or using weak encryption</li>
      <li>Application - malicious code injection and execution. For example, SQL injection and cross-site scripting (XSS)</li>
      <li>Compute - malware executing malicious code to compromise system</li>
      <li>Networking - unnecessary open ports to the internet. For example, leaving SSH or RDP open to virtual machines to leading brute-force attacks against your systems</li>
      <li>Perimeter - denial-of-service (DoS) attacks</li>
      <li>Identity and access - Exposed credentials and toxic combinations of permissions and authorization</li>
      <li>Physical security - unauthorized access to facilities</li>
    </ul>

    <h3 class="card-title">Authentication vs Authorization</h3>
    <ul>
      <li>Authentication - process of establishing identity of a person</li>
      <li>Authorization - process of establishing what level of access an authenticated person has</li>
    </ul>

    <h3 class="card-title">Authentication strategy</h3>
    <ul>
      <li>Single sign-on - access across applications is granted to a single identity/user, simplifying security model</li>
      <li>Multi-factor authentication - requires two or more elements for full authentication</li>
    </ul>

    <h3 class="card-title">Encryption</h3>
    <ul>
      <li>Encryption - process of making data unreadable and unusable to unauthorized viewers</li>
      <li>Symmetric encryption - uses the same key to encrypt and decrypt the data</li>
      <li>Asymmetric encryption - uses public key and private key pair. Can use one key to encrypt but need both keys to decrypt. Ex. Transport Layer Security (TLS) used in HTTPS</li>
    </ul>

    <h3 class="card-title">Security concerns</h3>
    <ul>
      <li>Input and outputs - always validate input. Always use parameterized queries. Always encode your output</li>
      <li>Key Vault - store connection strings, secrets, passwords, certificates, access policies, file locks, and automation scripts</li>
      <li>Framework - for example, Java/Javascript. Keep them updated</li>
      <li>Dependencies - track vulnerabilities on your 3rd party dependencies</li>
    </ul>

    <h3 class="card-title">SSL (Secure Sockets Layer)</h3>
    <ul>
      <li>Ensure that all data passed between web server and browsers remain private</li>
      <li>Web server creates private and public Key</li>
      <li>User submits CSR (Certificate Signing Request), which includes public key, to Certification Authority</li>
      <li>Then, CA will issue SSL certificate</li>
      <li>Web server will match user's SSL certificate to its private Key</li>
      <li>When broswer connects to secure site, it will check whether SSL certificate is not expired, and it is isseud by Certification Authority that browser trusts, and it is being used by the website for which it has been issued</li>
    </ul>

    <h3>SSL handshake</h3>
    <ul>
      <li>Client hello - client to server with TLS version</li>
      <li>Server hello - server to client with configuration it picked</li>
      <li>Server key exchange message - server to client with required information to generate pre-master secret</li>
      <li>Certificate request - server to client with certificate type, algorithm, and authorities</li>
      <li>Client certificate - client to server with certificate chain</li>
      <li>Client key exchange message - client to server so that a common key can be generated. Both sides then generate a master secret using pre-master secret, which is then used to generate symmetric key to encrypt session data</li>
    </ul>

    <h3 class="card-title">Active directory</h3>
    <ul>
      <li>Directory service implementation that provide authentication, group and user management, policy administration, etc</li>
      <li>It supports both Kerberos and LDAP</li>
      <li>It also provides SSO</li>
    </ul>

    <h3 class="card-title">LDAP (LightWeight Directory Acess Protocol)</h3>
    <ul>
      <li>Open protocol used for directory service authentication</li>
      <li>Relationship between AD and LDAP is similar to Apache and HTTP</li>
    </ul>

    <h3 class="card-title">Encoding</h3>
    <ul>
      <li>base36 - [a-z ,0-9]</li>
      <li>base62 - [A-Z, a-z, 0-9]</li>
      <li>base64 - [A-Z, a-z ,0-9] plus '+' and '-'</li>
    </ul>

    <h3>OpenSSL (Generate JKS from SSL certificates)</h3>
<pre><code class="bash">openssl pkcs12 -export -in &lt;your_cert&gt;.crt -inkey &lt;your_cert&gt;.key -out &lt;your_cert&gt;.p12
keytool -importkeystore -srckeystore &lt;your_cert&gt;.p12 -srcstoretype PKCS12 -destkeystore &lt;your_cert&gt;.jks -deststoretype JKS -dname "CN:&lt;your_hostname&gt;"</code></pre>

    <h3>OpenSSL command</h3>
<pre><code class="bash"># Check common name.
openssl x509 -noout -subject -in &lt;your_cert&gt;.crt

# Check expiry date.
openssl x509 -noout -enddate -in &lt;your_cert&gt;.crt

# Check all subject alternative names.
for i in $(openssl x509 -in &lt;your_cert&gt;.crt -noout -text | grep -A1 'Subject Alternative Name' | tail -n1 | tr -d ','); { echo $i | cut -f2 -d:; }</code></pre>

    <h3 class="card-title">Tokenization vs Encryption</h3>
    <ul>
      <li>Tokenized data is irreversible (Detokenization can only be done by the original tokenization system)</li>
      <li>Encryption is reversible with the key</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    <a href="https://medium.com/@kasunpdh/ssl-handshake-explained-4dabb87cdce">SSL Handshake explained</a> | <a href="https://www.varonis.com/blog/the-difference-between-active-directory-and-ldap/">The Difference Between Active Directory and LDAP</a>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Back-of-the-envelop</h2>

    <h3 class="card-title">Web servers</h3>
    <ul>
      <li>Typically serve static content to client (Web browser)</li>
      <li>Usually handle API calls from clients</li>
    </ul>

    <h3 class="card-title">App servers</h3>
    <ul>
      <li>Typically serve dynamic content to client</li>
      <li>Core business logic</li>
    </ul>

    <h3 class="card-title">Important latencies (in nanoseconds)</h3>
    <table>
      <tr>
        <td>L1 cache reference</td>
        <td>0.9</td>
      </tr>
      <tr>
        <td>L2 cache reference</td>
        <td>2.8</td>
      </tr>
      <tr>
        <td>L3 cache reference</td>
        <td>12.9</td>
      </tr>
      <tr>
        <td>Main memory reference</td>
        <td>100</td>
      </tr>
      <tr>
        <td>Compress 1KB with Snzip</td>
        <td>3,000 (3 microseconds)</td>
      </tr>
      <tr>
        <td>Read 1 MB sequentially from memory</td>
        <td>9,000 (9 microseconds)</td>
      </tr>
      <tr>
        <td>Read 1 MB sequentially from SSD</td>
        <td>200,000 (200 microseconds)</td>
      </tr>
      <tr>
        <td>Round trip within same datacenter</td>
        <td>500,000 (500 microseconds)</td>
      </tr>
      <tr>
        <td>Read 1 MB sequentially from SSD with speed ~1GB/sec SSD</td>
        <td>1,000,000 (1 milliseconds)</td>
      </tr>
      <tr>
        <td>Disk seek</td>
        <td>4,000,000 (4 milliseconds)</td>
      </tr>
      <tr>
        <td>Read 1 MB sequentially from disk</td>
        <td>2,000,000 (2 milliseconds)</td>
      </tr>
      <tr>
        <td>Send packet SF->NYC</td>
        <td>71,000,000 (71 milliseconds)</td>
      </tr>
    </table>

    <h3 class="card-title">Important rates</h3>
    <table>
      <tr>
        <td>QPS handled by MySQL</td>
        <td>1000</td>
      </tr>
      <tr>
        <td>QPS handled by key-value store</td>
        <td>10,000</td>
      </tr>
      <tr>
        <td>QPS handled by cache server</td>
        <td>100,000–1 M</td>
      </tr>
    </table>

    <h3 class="card-title">Availability numbers</h3>
    <table>
      <tr>
        <th>Availability</th>
        <th>Downtime per day</th>
        <th>Downtime per year</th>
      </tr>
      <tr>
        <td>99%</td>
        <td>14.40 minutes</td>
        <td>3.65 days</td>
      </tr>
      <tr>
        <td>99.9%</td>
        <td>1.44 minutes</td>
        <td>8.77 hours</td>
      </tr>
      <tr>
        <td>99.99%</td>
        <td>8.64 seconds</td>
        <td>52.6 minutes</td>
      </tr>
      <tr>
        <td>99.99%</td>
        <td>0.864 seconds</td>
        <td>5.26 minutes</td>
      </tr>
      <tr>
        <td>99.99%</td>
        <td>0.0864 seconds</td>
        <td>31.56 seconds</td>
      </tr>
    </table>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Resource estimation</h2>

    <h3 class="card-title">Request per second</h3>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Server has 36 cores (72 threads), 256GB RAM</li>
        <li>OS and other processes consumed 16GB RAM</li>
        <li>Each worker consumes 300MB RAM to complte a request</li>
        <li>Each CPU-bound request takes 200 millisecond</li>
        <li>Each memory-bound request takes 50 milliseconds</li>
      </ul>
      <li>RPS (CPU) = number of thread / time each task takes = 72 / 200ms = 360 RPS</li>
      <li>RPS (RAM) = Available memory / (time each task takes * worker memory comsumption) = 240GB / (50ms * 300MB)= 16,000 RPS</li>
      <li>Assume half requests are CPU bound and half requests are memory bound: 360 / 2 + 16,000 / 2 = 8,000 RPS</li>
    </ul>

    <h3 class="card-title">Estimate number of servers</h3>
    <ul>
      <li>Assume 500M daily users and 20 request per day on average</li>
      <ul>
        <li>Then, it is 500M * 20 = 10B requests per day, which is 115K requests per seconds (RPS)</li>
        <li>But if all users make a request at the same time, it is 500M * 1 = 500M requests per second (RPS)</li>
      </ul>
      <li>Assume a server can handle 8,000 RPS</li>
      <ul>
        <li>It looks like 15 servers can handle 500M users if load is evenly spread throughout the day</li>
        <li>However, at the peak, 500M / 8,000 = 62,000 servers are needed</li>
      </ul>
    </ul>

    <h3 class="card-title">Estimate storage</h3>
    <ul>
      <li>Assume 250M daily active users and each user makes 3 write requests per day</li>
      <li>Assume 10% contains images, 5% contains videos, 85% contain just text</li>
      <li>Assume each image is 200KB, video is 3MB, and text is 250 bytes</li>
      <li>Storage required - (250M * 3) * (0.1 * 200KB + 0.05 * 3MB + 0.85 * 250 bytes) = 128MB per day</li>
    </ul>

    <h3 class="card-title">Estimate bandwitdth</h3>
    <ul>
      <li>Incoming traffic - (128 MB per day / 86400 seconds per day) * 8 bits per byte = 11.8Kbps</li>
      <li>Assume each user make 50 read requests per day</li>
      <li>Outgoing traffic - (12Kbps / 3) * 50 = 197.5Kbps</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>
<!-- System design END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>