<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax/tex-chtml.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- binary search BEGIN -->
<div class="card mb-4" id="binary-search">
  <div class="card-body">
    <h2 class="card-title">Binary search</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#binary-search-">Median of Two Sorted Arrays</a></li>
      <li><a href="#binary-search-">Search in Rotated Sorted Array</a></li>
      <li><a href="#binary-search-">Find First and Last Position of Element in Sorted Array<</a></li>
      <li><a href="#binary-search-">Search a 2D Matrix</a></li>
      <li><a href="#binary-search-">Find Peak Element</a></li>
      <li><a href="#binary-search-">Split Array Largest Sum</a></li>
      <li><a href="#binary-search-">Find K Closest Elements</a></li>
      <li><a href="#binary-search-">Binary Search</a></li>
      <li><a href="#binary-search-">Koko Eating Bananas</a></li>
      <li><a href="#binary-search-">House Robber IV</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Median of Two Sorted Arrays (H)</h2>

<pre><code class="python"></code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/median-of-two-sorted-arrays">4. Median of Two Sorted Arrays</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Search in Rotated Sorted Array (M)</h2>

<pre><code class="python">class Solution:
    def search(self, nums: List[int], target: int) -> int:

        # Binary search
        #   Think of cases
        #   If left < mid
        #     [2,4,5,6,7,0,1] left side is sorted
        #     If left <= target < mid, search on left
        #     Else, search on right
        #   If left > mid
        #     [6,7,0,1,2,4,5] right side is sorted
        #     If mid < target <= right, search on right
        #     Else, search on left

        left, right = 0, len(nums) - 1

        # Time O(logn)
        #   n = len(nums)
        # Space O(1)
        while left <= right:

            mid = (left+right) // 2

            if nums[mid] == target:
                return mid
            
            if nums[left] <= nums[mid]:
                if nums[left] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                if nums[mid] < target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1

        return -1</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/search-in-rotated-sorted-array">33. Search in Rotated Sorted Array</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Find First and Last Position of Element in Sorted Array (M)</h2>

<pre><code class="python">class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:

        # Binary search

        left = 0
        right = len(nums) - 1

        # Time O(logn) 
        #   n = len(nums)
        # Space O(1)
        while left <= right:
            mid = (left+right) // 2
            if target > nums[mid]:
                left = mid + 1
            elif target < nums[mid]:
                right = mid - 1
            else:
                start = mid
                while nums[mid] == nums[start]:
                    start -= 1
                    if start < 0:
                        break
                start += 1

                end = mid
                while nums[mid] == nums[end]:
                    end += 1
                    if end >= len(nums):
                        break
                end -= 1

                return [start, end]

        return [-1, -1]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array">34. Find First and Last Position of Element in Sorted Array</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Search a 2D Matrix (M)</h2>

<pre><code class="python">class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:

        # Binary search to find the row that target belongs
        # If target < first number in mid row
        #   Search upper row
        # Elif target > last number in mid row
        #   Search lower row
        # Else
        #   Return current row
        # Then, binary search on the row

        left, right = 0, len(matrix) - 1

        # Time O(log(mn))
        #   n = number of rows
        #   m = number of cols
        # Space O(1)
        def binary_search_row(left, right, matrix, target):

            while left <= right:
                mid = (left+right) // 2
                print(f"{left},{mid},{right}")
                if target < matrix[mid][0]:
                    right = mid - 1
                    continue
                if target > matrix[mid][len(matrix[mid])-1]:
                    left = mid + 1
                    continue  
                return mid

            return -1

        index = binary_search_row(left, right, matrix, target)
        
        def binary_search(left, right, row, target):

            while left <= right:
                mid = (left+right) // 2

                if target < row[mid]:
                    right = mid - 1
                elif target > row[mid]:
                    left = mid + 1
                else:  
                    return True

            return False

        left, right = 0, len(matrix[index]) - 1
        return binary_search(left, right, matrix[index], target)</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/search-a-2d-matrix">74. Search a 2D Matrix</a> | <a href="https://neetcode.io/problems/search-2d-matrix">Search a 2D Matrix</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Find Peak Element (M)</h2>

<pre><code class="python">class Solution:
    def findPeakElement(self, nums: List[int]) -> int:

        # Binary search
        # If nums[mid] > nums[mid+1], peak must exist on left
        # If nums[mid] < nums[mid+1], peak must exist on right

        # Time O(logn)
        #   n = len(nums)
        # Space O(1)
        left = 0
        right = len(nums) - 1

        while left < right:
            mid = (left+right) // 2

            if nums[mid] > nums[mid+1]:
                right = mid
            else:
                left = mid + 1

        return left</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/find-peak-element">162. Find Peak Element</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Split Array Largest Sum (H)</h2>

<pre><code class="python"></code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/split-array-largest-sum">410. Split Array Largest Sum</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Find K Closest Elements (M)</h2>

<pre><code class="python">class Solution:
    def findClosestElements(self, nums: List[int], k: int, num: int) -> List[int]:

        # Because nums is sorted, k closest integers will be in
        # consecutive array
        # Find a number that is closest to x
        #   Then, expand left and right from that number
        #   to gather k closest numbers
        # Run binary seach to find closest number of x
        #   If mid > x, search on left side
        #   If mid < x, search on right side
        #   If mid == x, return mid
        #   Remember the last left and right pointer, 
        #   and return it when right >= left
        # Expand
        #   Initialize k' = 1
        #   Compare left and right numbers
        #   If k' + 2 <= k
        #     Then, include both numbers
        #   Else
        #     Compare left and right number and
        #     pick number that is closer to the 
        #     cloest number   

        # Time O(logn+k)
        #   n = len(nums)
        # Space O(1)

        def binary_search(nums, left, right, target):

            while left <= right:
                mid = (left + right) // 2
                if target > nums[mid]:
                    left = mid + 1
                elif target < nums[mid]:
                    right = mid - 1
                else:
                    return mid
                
            return left

        index = binary_search(nums, 0, len(nums)-1, num)
        
        left = index - 1
        right = index

        while right - left - 1 < k:
            # check for out of bounds
            if left == -1:
                right += 1
                continue

            if right == len(nums) \
                or abs(nums[left]-num) <= abs(nums[right]-num):
                left -= 1
            else:
                right += 1

        return nums[left+1:right]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/find-k-closest-elements">658. Find K Closest Elements</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Binary Search (E)</h2>

<pre><code class="python"></code>class Solution:
    def search(self, nums: List[int], target: int) -> int:
        
        left, right = 0, len(nums) - 1

        # Time O(logn)
        #   n = len(nums)
        # Space O(1)
        while left <= right:
            mid = (left+right) // 2

            if nums[mid] < target:
                left = mid + 1
            elif nums[mid] > target:
                right = mid - 1
            else:
                return mid

        return -1</pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/binary-search">704. Binary Search</a> | <a href="https://neetcode.io/problems/binary-search">Binary Search</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Koko Eating Bananas (M)</h2>

<pre><code class="python">class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:

        # Binary search
        # Consider the minimum and maximun eating speed
        # Min = 1, Max = max(piles)
        # Try eat with mid speed
        # If eat too fast (h' < h)
        #   Decrease eating speed
        # Elif eat too slow (h' > h)
        #   Increase eating speed
        # Else
        #   Speed is good enough
        #   Try further lowering eating speed

        left, right = 1, max(piles)

        # Time O(nlogm)
        #   n = len(piles)
        #   m = max(piles)
        # Space O(1)
        while left <= right:
            mid = (left+right) // 2

            h_prime = 0
            for p in piles:
                h_prime += p // mid
                if p % mid != 0:
                    h_prime += 1 

            if h_prime < h:
                right = mid - 1
            elif h_prime > h:
                left = mid + 1
            else:
                right = mid - 1

        return left</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/kth-missing-positive-number">875. Koko Eating Bananas</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">House Robber IV (M)</h2>

<pre><code class="python">class Solution:
    def minCapability(self, nums: List[int], k: int) -> int:
        
        # Binary search
        # Find max steal and min steal from any one house
        # Compute mid value
        # Check if at least k houses can be robbed 
        # (but no house whose value is greater than mid value can be robbed) 
        
        left, right, n = min(nums), max(nums), len(nums)

        # Time O(nlogm)
        #   n = len(nums)
        #   m = difference between min and max number in nums
        # Space O(1)
        while left < right:
            mid = (left+right) // 2

            i, num_robbed = 0, 0
            while i < n:
                if nums[i] <= mid:
                    num_robbed += 1
                    i += 2
                else:
                    i += 1

            # If feasible, decrease next value to check
            if num_robbed >= k:
                right = mid
            # If not feasible, increase next value to check
            else:
                left = mid + 1

        return left</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/house-robber-iv">2560. House Robber IV</a>
  </div>
</div>
<!-- Binary search END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>