<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax/tex-chtml.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- binary search BEGIN -->
<div class="card mb-4" id="binary-search">
  <div class="card-body">
    <h2 class="card-title">Binary search</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#binary-search-">Median of Two Sorted Arrays</a></li>
      <li><a href="#binary-search-">Search in Rotated Sorted Array</a></li>
      <li><a href="#binary-search-">Find First and Last Position of Element in Sorted Array<</a></li>
      <li><a href="#binary-search-">Search a 2D Matrix</a></li>
      <li><a href="#binary-search-">Find Minimum in Rotated Sorted Array</a></li>
      <li><a href="#binary-search-">Find Peak Element</a></li>
      <li><a href="#binary-search-">Split Array Largest Sum</a></li>
      <li><a href="#binary-search-">Find K Closest Elements</a></li>
      <li><a href="#binary-search-">Binary Search</a></li>
      <li><a href="#binary-search-">Koko Eating Bananas</a></li>
      <li><a href="#binary-search-">Time Based Key-Value Store </a></li>
      <li><a href="#binary-search-">House Robber IV</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Median of Two Sorted Arrays (H)</h2>

<pre><code class="python">class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:

        # Compute mid of nums1 and nums2 (mid1, mid2)
        # Assume mid1 < mid2
        # Try splitting nums1
        #   Let left num of split = max_left_1
        #   Let right num of split = min_right_1
        #.  Let split point = mid1  
        # Try splitting nums2
        #   max_left_2, min_right_2, mid2 = (n+m+1) // 2 - mid1
        # If max_left_1 <= min_right_2 and max_left_2 <= min_right_1
        #   Return 
        # If max_left_1 > min_right_2
        #   max_left_1 is too big, right = split point - 1
        # If min_right_1 < max_left_2
        #   min_right_1 is too small, left = split spoint + 1

        if len(nums1) > len(nums2):
            nums1, nums2 = nums2, nums1

        n, m = len(nums1), len(nums2)
        left, right = 0, n

        # Time O(log(min(n,m)))
        #   n = len(nums1)
        #   m = len(nums2)
        # Space O(1)
        while left <= right:
            mid1 = (left+right) // 2
            mid2 = (n+m+1) // 2 - mid1

            if mid1 == 0:
                max_left_1 = -math.inf
            else:
                max_left_1 = nums1[mid1-1] 
            if mid1 == n:
                min_right_1 = math.inf
            else:
                min_right_1 = nums1[mid1] 
            if mid2 == 0:
                max_left_2 = -math.inf
            else:
                max_left_2 = nums2[mid2-1]
            if mid2 == m:
                min_right_2 = math.inf
            else:
                min_right_2 = nums2[mid2]

            if max_left_1 > min_right_2:
                right = mid1 - 1
                continue
            if min_right_1 < max_left_2:
                left = mid1 + 1
                continue
            if max_left_1 <= min_right_2 and max_left_2 <= min_right_1:
                if (m+n) % 2 == 0:
                    return (max(max_left_1, max_left_2) + min(min_right_1, min_right_2)) / 2
                else:
                    return max(max_left_1, max_left_2)  </code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/median-of-two-sorted-arrays">4. Median of Two Sorted Arrays</a> | <a href="https://neetcode.io/problems/median-of-two-sorted-arrays">Median of Two Sorted Arrays</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Search in Rotated Sorted Array (M)</h2>

<pre><code class="python">class Solution:
    def search(self, nums: List[int], target: int) -> int:

        # Ex. [1,2,3,4,5,6]
        # Ex. [6,1,2,3,4,5]
        # Ex. [5,6,1,2,3,4]
        # Ex. [4,5,6,1,2,3]
        # Ex. [3,4,5,6,1,2]
        # Ex. [2,3,4,5,6,1]

        # If mid > left, left side is sorted
        #   If left <= target < mid, search on left
        #   Else, search on right
        # If mid < left, right side is sorted 
        #   If left < mid <= right, search on right
        #   Else, search on left

        left, right = 0, len(nums) - 1

        # Time O(logn)
        #   n = len(nums)
        # Space O(1)
        while left <= right:
            mid = (left+right) // 2

            if nums[mid] == target:
                return mid
            
            if nums[left] <= nums[mid]:
                if nums[left] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                if nums[mid] < target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1

        return -1</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/search-in-rotated-sorted-array">33. Search in Rotated Sorted Array</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Find First and Last Position of Element in Sorted Array (M)</h2>

<pre><code class="python">class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:

        # Binary search

        left = 0
        right = len(nums) - 1

        # Time O(logn) 
        #   n = len(nums)
        # Space O(1)
        while left <= right:
            mid = (left+right) // 2
            if target > nums[mid]:
                left = mid + 1
            elif target < nums[mid]:
                right = mid - 1
            else:
                start = mid
                while nums[mid] == nums[start]:
                    start -= 1
                    if start < 0:
                        break
                start += 1

                end = mid
                while nums[mid] == nums[end]:
                    end += 1
                    if end >= len(nums):
                        break
                end -= 1

                return [start, end]

        return [-1, -1]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array">34. Find First and Last Position of Element in Sorted Array</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Search a 2D Matrix (M)</h2>

<pre><code class="python">class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:

        # Binary search to find the row that target belongs
        # If target < first number in mid row
        #   Search upper row
        # Elif target > last number in mid row
        #   Search lower row
        # Else
        #   Return current row
        # Then, binary search on the row

        left, right = 0, len(matrix) - 1

        # Time O(log(mn))
        #   n = number of rows
        #   m = number of cols
        # Space O(1)
        def binary_search_row(left, right, matrix, target):

            while left <= right:
                mid = (left+right) // 2
                print(f"{left},{mid},{right}")
                if target < matrix[mid][0]:
                    right = mid - 1
                    continue
                if target > matrix[mid][len(matrix[mid])-1]:
                    left = mid + 1
                    continue  
                return mid

            return -1

        index = binary_search_row(left, right, matrix, target)
        
        def binary_search(left, right, row, target):

            while left <= right:
                mid = (left+right) // 2

                if target < row[mid]:
                    right = mid - 1
                elif target > row[mid]:
                    left = mid + 1
                else:  
                    return True

            return False

        left, right = 0, len(matrix[index]) - 1
        return binary_search(left, right, matrix[index], target)</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/search-a-2d-matrix">74. Search a 2D Matrix</a> | <a href="https://neetcode.io/problems/search-2d-matrix">Search a 2D Matrix</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Find Minimum in Rotated Sorted Array (M)</h2>

<pre><code class="python">class Solution:
    def findMin(self, nums: List[int]) -> int:

        # Ex. [1,2,3,4,5,6]
        # Ex. [6,1,2,3,4,5]
        # Ex. [5,6,1,2,3,4]
        # Ex. [4,5,6,1,2,3]
        # Ex. [3,4,5,6,1,2]
        # Ex. [2,3,4,5,6,1]

        # If left < right
        #   Array is in perfect order, return nums[0]
        # If nums[i] < nums[i-1], min is nums[i]
        # Pick mid element
        #   If left < mid, min in on right
        #   If left < mid, min is on left

        # Time O(logn)
        #   n = len(nums)
        # Space O(1)
        left, right = 0, len(nums) - 1
        if nums[left] <= nums[right]:
            return nums[left]

        while left <= right:
            mid = (left+right) // 2

            if nums[mid] < nums[mid-1]:
                return nums[mid]
            if nums[mid+1] < nums[mid]:
                return nums[mid+1]

            if nums[left] < nums[mid]:
                left = mid + 1
            else:
                right = mid - 1

        return nums[left]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array">153. Find Minimum in Rotated Sorted Array</a> | <a href="https://neetcode.io/problems/find-minimum-in-rotated-sorted-array">Find Minimum in Rotated Sorted Array</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Find Peak Element (M)</h2>

<pre><code class="python">class Solution:
    def findPeakElement(self, nums: List[int]) -> int:

        # Binary search
        # If nums[mid] > nums[mid+1], peak must exist on left
        # If nums[mid] < nums[mid+1], peak must exist on right

        # Time O(logn)
        #   n = len(nums)
        # Space O(1)
        left = 0
        right = len(nums) - 1

        while left < right:
            mid = (left+right) // 2

            if nums[mid] > nums[mid+1]:
                right = mid
            else:
                left = mid + 1

        return left</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/find-peak-element">162. Find Peak Element</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Split Array Largest Sum (H)</h2>

<pre><code class="python"></code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/split-array-largest-sum">410. Split Array Largest Sum</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Find K Closest Elements (M)</h2>

<pre><code class="python">class Solution:
    def findClosestElements(self, nums: List[int], k: int, num: int) -> List[int]:

        # Because nums is sorted, k closest integers will be in
        # consecutive array
        # Find a number that is closest to x
        #   Then, expand left and right from that number
        #   to gather k closest numbers
        # Run binary seach to find closest number of x
        #   If mid > x, search on left side
        #   If mid < x, search on right side
        #   If mid == x, return mid
        #   Remember the last left and right pointer, 
        #   and return it when right >= left
        # Expand
        #   Initialize k' = 1
        #   Compare left and right numbers
        #   If k' + 2 <= k
        #     Then, include both numbers
        #   Else
        #     Compare left and right number and
        #     pick number that is closer to the 
        #     cloest number   

        # Time O(logn+k)
        #   n = len(nums)
        # Space O(1)

        def binary_search(nums, left, right, target):

            while left <= right:
                mid = (left + right) // 2
                if target > nums[mid]:
                    left = mid + 1
                elif target < nums[mid]:
                    right = mid - 1
                else:
                    return mid
                
            return left

        index = binary_search(nums, 0, len(nums)-1, num)
        
        left = index - 1
        right = index

        while right - left - 1 < k:
            # check for out of bounds
            if left == -1:
                right += 1
                continue

            if right == len(nums) \
                or abs(nums[left]-num) <= abs(nums[right]-num):
                left -= 1
            else:
                right += 1

        return nums[left+1:right]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/find-k-closest-elements">658. Find K Closest Elements</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Binary Search (E)</h2>

<pre><code class="python"></code>class Solution:
    def search(self, nums: List[int], target: int) -> int:
        
        left, right = 0, len(nums) - 1

        # Time O(logn)
        #   n = len(nums)
        # Space O(1)
        while left <= right:
            mid = (left+right) // 2

            if nums[mid] < target:
                left = mid + 1
            elif nums[mid] > target:
                right = mid - 1
            else:
                return mid

        return -1</pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/binary-search">704. Binary Search</a> | <a href="https://neetcode.io/problems/binary-search">Binary Search</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Koko Eating Bananas (M)</h2>

<pre><code class="python">class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:

        # Binary search
        # Consider the minimum and maximun eating speed
        # Min = 1, Max = max(piles)
        # Try eat with mid speed
        # If eat too fast (h' < h)
        #   Decrease eating speed
        # Elif eat too slow (h' > h)
        #   Increase eating speed
        # Else
        #   Speed is good enough
        #   Try further lowering eating speed

        left, right = 1, max(piles)

        # Time O(nlogm)
        #   n = len(piles)
        #   m = max(piles)
        # Space O(1)
        while left <= right:
            mid = (left+right) // 2

            h_prime = 0
            for p in piles:
                h_prime += p // mid
                if p % mid != 0:
                    h_prime += 1 

            if h_prime < h:
                right = mid - 1
            elif h_prime > h:
                left = mid + 1
            else:
                right = mid - 1

        return left</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/kth-missing-positive-number">875. Koko Eating Bananas</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Time Based Key-Value Store (M)</h2>

<pre><code class="python">class TimeMap:

    # Use dictionary where
    #   key = key
    #   value = [timestamp, value] 

    def __init__(self):
        self.dic = defaultdict(list)

    def set(self, key: str, value: str, timestamp: int) -> None:
        self.dic[key].append([timestamp, value])
        
    def get(self, key: str, timestamp: int) -> str:
        
        if key not in self.dic:
            return ""

        left, right = 0, len(self.dic[key]) - 1

        # If given timestamp is bigger than biggest timestamp
        if timestamp > self.dic[key][right][0]:
            return self.dic[key][right][1]
        # If given timestamp is smaller than smallest timestamp
        if timestamp < self.dic[key][left][0]:
            return ""

        while left <= right:
            mid = (left+right) // 2

            if timestamp < self.dic[key][mid][0]:
                right = mid - 1
            elif timestamp > self.dic[key][mid][0]:
                left = mid + 1
            else:
                return self.dic[key][mid][1]

        return self.dic[key][right][1]
        

# Your TimeMap object will be instantiated and called as such:
# obj = TimeMap()
# obj.set(key,value,timestamp)
# param_2 = obj.get(key,timestamp)</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/time-based-key-value-store">981. Time Based Key-Value Store</a> | <a href="https://neetcode.io/problems/time-based-key-value-store">Time Based Key-Value Store</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">House Robber IV (M)</h2>

<pre><code class="python">class Solution:
    def minCapability(self, nums: List[int], k: int) -> int:
        
        # Binary search
        # Find max steal and min steal from any one house
        # Compute mid value
        # Check if at least k houses can be robbed 
        # (but no house whose value is greater than mid value can be robbed) 
        
        left, right, n = min(nums), max(nums), len(nums)

        # Time O(nlogm)
        #   n = len(nums)
        #   m = difference between min and max number in nums
        # Space O(1)
        while left < right:
            mid = (left+right) // 2

            i, num_robbed = 0, 0
            while i < n:
                if nums[i] <= mid:
                    num_robbed += 1
                    i += 2
                else:
                    i += 1

            # If feasible, decrease next value to check
            if num_robbed >= k:
                right = mid
            # If not feasible, increase next value to check
            else:
                left = mid + 1

        return left</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/house-robber-iv">2560. House Robber IV</a>
  </div>
</div>
<!-- Binary search END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>