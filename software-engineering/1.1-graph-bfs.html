<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax/tex-chtml.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- Graph BFS BEGIN -->
<div class="card mb-4" id="graph">
  <div class="card-body">
    <h2 class="card-title">Graph BFS</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#graph-bfs-">Word ladder II</a></li>
      <li><a href="#graph-bfs-">Word ladder</a></li>
      <li><a href="#graph-bfs-">Number of islands</a></li>
      <!-- <li><a href="#graph-bfs-">Remove invalid parentheses</a></li> -->
      <li><a href="#graph-bfs-">Longest increasing path in a matrix</a></li>
      <!-- <li><a href="#graph-bfs-">Water and jug problem</a></li> -->
      <!-- <li><a href="#graph-bfs-">Longest Absolute File Path</a></li> -->
      <li><a href="#graph-bfs-">Number of provinces</a></li>
      <li><a href="#graph-bfs-">Bus Routes</a></li>
      <li><a href="#graph-bfs-">Shortest Path in Binary Matrix</a></li>
      <li><a href="#graph-bfs-">Diagonal Traverse II</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="graph-bfs">
  <div class="card-body">
    <h2 class="card-title">Word ladder II (H) (A) !</h2>

<pre><code class="python">class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:

        # Construct a graph where edge consists of nodes (words differ by one char)
        # BFS to compute shrotest distance
        # Because standard BFS wouldn't go to the node that is already explored,
        # some path to solution will be missed!
        # Modify BFS such that nodes are added to the "explored",
        # AFTER all nodes in one level above are dequeued

        graph = defaultdict(list)
        words = [beginWord] + wordList
        n = len(words)

        # Construct a set that contains all words that differ by one char
        # Space O(n*s) s = length of word
        all_words_differ_by_one_char = defaultdict(set)
        for word in words:
            for i in range(len(word)):
                for c in 'abcdefghijklmnopqrstuvwxyz':
                    all_words_differ_by_one_char[word].add(word[:i]+c+word[i+1:])

        # Time O(n^2) length of each word is constant
        # Space O(n)
        for i in range(n):
            for j in range(i+1,n):
                if words[j] in all_words_differ_by_one_char[words[i]]:
                    graph[words[i]].append(words[j])
                    graph[words[j]].append(words[i])

        def bfs(graph, start, end, explored_by_level):

            explored = set()
            explored.add(start)

            explored_by_level = defaultdict(set)
            explored_by_level[0].add(start)

            queue = deque()
            queue.append((start,0,[]))

            result = []
            min_dist = 500

            while queue:
                node, dist, previous_nodes = queue.popleft()

                for next_node in graph[node]:
                    if next_node == end:
                        min_dist = min(min_dist, dist)
                        path = previous_nodes+[node]+[end]
                        if dist <= min_dist and path not in result:
                            result.append(path)

                    if next_node not in explored:
                        all_parent_nodes_dequeued = True
                        parent_nodes = explored_by_level[dist]
                        for parent_node in parent_nodes:
                            if parent_node in queue:
                                all_parent_nodes_dequeued = False
                        if all_parent_nodes_dequeued:
                            explored.add(node)
                        queue.append((next_node,dist+1,previous_nodes+[node]))

            return result

        def bfs_helper(graph, start, end):

            explored = set()
            explored.add(start)

            explored_by_level = defaultdict(set)
            explored_by_level[0].add(start)

            queue = deque()
            queue.append((start,0))

            result = []

            while queue:
                node, dist = queue.popleft()

                for next_node in graph[node]:
                    if next_node not in explored:
                        explored.add(node)
                        explored_by_level[dist+1].add(next_node)
                        queue.append((next_node,dist+1))

            return explored_by_level

        # Time O(n+m)
        # Space O(n*m) if all nodes is connected to all other nodes,
        # there are m possible distances from one node to reach another
        explored_by_level = bfs_helper(graph, beginWord, endWord)

        # Time O(n+m)
        # Space O(n)
        return bfs(graph, beginWord, endWord, explored_by_level)</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/word-ladder-ii">126. Word Ladder II</a>
  </div>
</div>

<div class="card mb-4" id="graph-bfs">
  <div class="card-body">
    <h2 class="card-title">Word ladder (H) (F/A) #!</h2>

<pre><code class="python">class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:

        # Construct a graph where nodes are 
        # words differ by one char
        # BFS to compute shrotest distance

        graph = defaultdict(set)
        words = [beginWord] + wordList
        n = len(words)

        # Time O(kl)
        #   k = number of words 
        #   l = length of each word
        # Space O(kl)
        differ_by_one_char = defaultdict(set)
        for word in words:
            for i in range(len(word)):
                for c in 'abcdefghijklmnopqrstuvwxyz':
                    differ_by_one_char[word].add(word[:i]+c+word[i+1:])

        # Time O(k**2)
        # Space O(k**2)
        for i in range(n):
            for j in range(i+1,n):
                if words[j] in differ_by_one_char[words[i]]:
                    graph[words[i]].add(words[j])
                    graph[words[j]].add(words[i])

        # Time O(n+m)
        #   n = number of nodes = k
        #   m = number of edges = k ** 2 every node can be connected
        # Space O(n)
        def bfs(graph, start, end):

            explored = set()
            explored.add(start)

            queue = deque()
            queue.append((start,0))

            while queue:
                node, dist = queue.popleft()
                for next_node in graph[node]:
                    if next_node == end:
                        return dist+2
                    if next_node not in explored:
                        explored.add(next_node)
                        queue.append((next_node,dist+1))

            return 0

        return bfs(graph, beginWord, endWord)</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/word-ladder">127. Word Ladder</a>
  </div>
</div>

<div class="card mb-4" id="graph-bfs">
  <div class="card-body">
    <h2 class="card-title">Number of islands (M) (G/F/A/100) !#!!</h2>

<pre><code class="python">class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:

        # Construct a graph
        # Two nodes are connected when node is 1 and adjacent is also 1
        # Count number of connnected component using BFS
        
        graph = defaultdict(set)
        nodes = set()
        directions = [
            (-1, 0), 
            (0, -1), 
            (0, 1), 
            (1, 0)
        ]

        # Time O(nm)
        #   n = number of rows
        #   m = number of columns
        # Space O(nm) 
        #   Worst case is that every number is 1
        n = len(grid)
        m = len(grid[0])
        for i in range(n):
            for j, num in enumerate(grid[i]):
                if num == "1":
                    if (i,j) not in nodes:
                        nodes.add((i,j))
                    for row, col in directions:
                        if 0 <= row + i < len(grid) \
                            and 0 <= col + j < len(grid[0]) \
                            and grid[row+i][col+j] == "1":
                            graph[(i,j)].add((row+i,col+j))
                            graph[(row+i,col+j)].add((i,j))
                    
        explored = set()
        count = 0

        def bfs(graph, explored, start):
            
            queue = deque()
            queue.append(start)

            while queue:
                node = queue.popleft()
                for next_node in graph[node]:
                    if next_node not in explored:
                        explored.add(next_node)
                        queue.append(next_node)

        # Time O(nm) 
        #   Worst case visit every node in graph
        # Space O(nm)
        for (i,j) in nodes:
            if (i,j) not in explored:
                bfs(graph, explored, (i,j))
                count += 1
                
        return count</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/number-of-islands">200. Number of Islands</a>
  </div>
</div>

<!-- <div class="card mb-4" id="graph-bfs">
  <div class="card-body">
    <h2 class="card-title">Remove invalid parentheses (H)</h2>

<pre><code class="python">class Solution:
    def removeInvalidParentheses(self, s: str) -> List[str]:

        # Treat "s" as root
        # If node is a valid paranthesis expression, add to result
        # Else, construcut child nodes by removing one parenthesis at a time
        # Keep distance from root to child nodes

        explored = set()
        explored.add(s)

        queue = deque()
        queue.append((s,0))

        result = []
        min_dist = len(s)

        def is_valid_bracket_expression(string):

            bracket_counts = defaultdict(int)
            count = 0

            for char in string:
                bracket_counts[char] += 1
                # Early exit because if the count of ')' > '(', s can't be valid
                if bracket_counts[")"] > bracket_counts["("]:
                    return False

            return bracket_counts[")"] == bracket_counts["("]

        # Time O(n+m)
        #   n = number of nodes
        #   Number of nodes are all possible substring that can be
        #   formed by removing one char at a time
        #   Then, it should be that n = k^2, k = len(s)
        #   Also, m = k^2
        # Space O(n)
        while queue:
            node, dist = queue.popleft()

            if is_valid_bracket_expression(node):
                # If not the shortest distance
                if dist > min_dist:
                    return result
                min_dist = min(min_dist, dist)
                result.append(node)

            else:
                for i in range(len(node)):
                    if node[i] == "(" or node[i] == ")":
                        next_node = node[:i] + node[i+1:]
                        if next_node not in explored:
                            explored.add(next_node)
                            queue.append((next_node,dist+1))

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/remove-invalid-parentheses">301. Remove Invalid Parentheses</a>
  </div>
</div> -->

<div class="card mb-4" id="graph-bfs-">
  <div class="card-body">
    <h2 class="card-title">Longest increasing path in a matrix (H) (F) #</h2>

<pre><code class="python">class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:

        # BFS 
        # Construct graph
        #   x goes to y if x < y
        # Remember depth while traversing
        n = len(matrix)
        m = len(matrix[0])

        graph = defaultdict(set)
        dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]

        # Time O(nm)
        #   n = number of rows
        #   m = number of columns
        # Space O(nm)
        for i in range(n):
            for j in range(m):
                for x,y in dirs:
                    if 0 <= i + x < n \
                        and 0 <= j + y < m \
                        and matrix[i][j] < matrix[i+x][j+y]:
                        graph[(i, j)].add((i+x, j+y))

        # Memorize solutions
        memory = defaultdict(int)

        # Time O(nm)
        #   With memory, traverse takes only once at each node
        # Space O(nm)
        #   Memory stores max path length starting at each node
        def bfs(graph, start):

            # Should not have explored set
            # because we are checking every path
            # (we know there is no cycle) 

            queue = deque()
            queue.append((start, 1))

            max_depth = 0
            
            while queue:
                node, depth = queue.popleft()

                for next_node in graph[node]:
                    if next_node in memory:
                        max_depth = max(
                            max_depth, 
                            memory[next_node]+depth
                        )
                    else:
                        queue.append((next_node, depth+1))

            return max(max_depth, depth)

        max_length = 0
        for i in range(n):
            for j in range(m):
                memory[(i,j)] = bfs(graph, (i,j))        
                max_length = max(max_length, memory[(i,j)])
                
        return max_length</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix">329. Longest Increasing Path in a Matrix</a>
  </div>
</div>

<!-- <div class="card mb-4" id="graph-bfs">
  <div class="card-body">
    <h2 class="card-title">Water and jug problem (M)</h2>

<pre><code class="python">class Solution:
    def canMeasureWater(self, x: int, y: int, target: int) -> bool:

        # BFS
        # Consider start node is (x,y)
        # For a given node (a,b) the next node can be
        #   (0,b) empty first jug
        #   (a,0) empty second jug
        #   (x,b) fill up first jug
        #   (a,y) flll up second jug
        #   (min(x,a+b), max(b-(x-a),0)) pour second jug into first jug
        #   (max(a-(x-b),0), min(y,b+a)) pour first jug unto second jug

        explored = set()
        explored.add((x,y))

        queue = deque()
        queue.append((x,y))

        # Time O(n+m) n = number of nodes, m = number of edges
        # Space O(n)
        while queue:
            a, b = queue.popleft()
            print(f"a: {a}, b: {b}")

            next_nodes = []
            next_nodes.append((0,b))
            next_nodes.append((a,0))
            next_nodes.append((x,b))
            next_nodes.append((a,y))
            next_nodes.append((min(x,a+b), max(b-(x-a),0)))
            next_nodes.append((max(a-(y-b),0), min(y,b+a)))

            for new_a, new_b in next_nodes:
                if new_a + new_b == target:
                    return True
                if (new_a, new_b) not in explored:
                    explored.add((new_a, new_b))
                    queue.append((new_a, new_b))

        return False</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/water-and-jug-problem">365. Water and Jug Problem</a>
  </div>
</div> -->

<!-- <div class="card mb-4" id="graph-bfs">
  <div class="card-body">
    <h2 class="card-title">Longest Absolute File Path (M)</h2>

<pre><code class="python">class Solution:
    def lengthLongestPath(self, input: str) -> int:

        # Consider the input as graph and find max path length of graph
        # First, split input by \n
        # then, construct graph based on the occurence of \t

        graph = defaultdict(list)
        last_string_in_each_depth = defaultdict(str)
        split_by_n = input.split("\n")
        root_nodes = []

        def is_valid_file(string):

            if "." in string:
                return True

            return False

        # Input does not have any file
        if not is_valid_file(input):
            return 0

        max_length = 0
        # There is no tab (Ex. "file1.txt\nfile2.txt\nlongfile.txt")
        if input.count("\t") == 0:
            if input.count("\n") > 0:
                for string in split_by_n:
                    max_length = max(max_length, len(string))
                return max_length
            # There is no new line (Ex. "a.txt")
            else:
                if is_valid_file(input):
                    return len(input)

        for string in split_by_n:
            count_t = string.count("\t")
            string = string[count_t:]
            last_string_in_each_depth[count_t] = string
            if count_t == 0:
                root_nodes.append(string)
            if count_t > 0:
                graph[last_string_in_each_depth[count_t-1]].append(string)

        print(graph)

        def bfs(graph, start):

            explored = set()
            explored.add(start)

            queue = deque()
            queue.append((start, len(start)))

            max_length = 0

            while queue:
                node, length = queue.popleft()

                for next_node in graph[node]:
                    if next_node not in explored:
                        explored.add(next_node)
                        queue.append((next_node, length+1+len(next_node)))
                        max_length = max(max_length, length+1+len(next_node))

            return max_length

        max_length = 0
        print(root_nodes)
        for string in root_nodes:
            max_length = max(max_length, bfs(graph, string))

        return max_length</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/longest-absolute-file-path">388. Longest Absolute File Path</a>
  </div>
</div> -->

<!-- <div class="card mb-4" id="graph-bfs">
  <div class="card-body">
    <h2 class="card-title">Number of provinces (M)</h2>

<pre><code class="python">class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:

        # Constructed an undirected graph
        # Compute connected component with BFS

        graph = defaultdict(set)
        n = len(isConnected[0])  # Number of cities

        for i in range(len(isConnected)):
            for j in range(len(isConnected[i])):
                if isConnected[i][j] == 1:
                    graph[i].add(j)
                    graph[j].add(i)

        explored_cities = set()
        num_province = 0

        def bfs(graph, start):

            explored = set()
            explored.add(start)

            queue = deque()
            queue.append(start)

            while queue:
                node = queue.popleft()
                for next_node in graph[node]:
                    if next_node not in explored:
                        explored.add(next_node)
                        queue.append(next_node)

            return explored

        # Time O(n+m)
        #   BFS will explored all nodes exactly once
        #   Worst case is that all nodes are connected
        # Space O(n)
        for i in range(n):
            if i not in explored_cities:
                explored = bfs(graph, i)
                explored_cities.update(explored)
                num_province +=1

        return num_province</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/number-of-provinces">547. Number of Provinces</a>
  </div>
</div> -->

<div class="card mb-4" id="graph-bfs">
  <div class="card-body">
    <h2 class="card-title">Bus Routes (H) (100) !</h2>

<pre><code class="python"></code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/bus-routes">815. Bus Routes</a>
  </div>
</div>

<div class="card mb-4" id="graph-bfs">
  <div class="card-body">
    <h2 class="card-title">Shortest Path in Binary Matrix (M) (F) #</h2>

<pre><code class="python">class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:

        # BFS shortest path

        if grid[len(grid)-1][len(grid[0])-1] == 1:
            return -1

        graph = defaultdict(set)
        directions = [
            (-1, -1), 
            (-1, 0), 
            (-1, 1), 
            (0, -1), 
            (0, 1), 
            (1, -1), 
            (1, 0), 
            (1, 1)
        ]

        # Time O(n) 
        #   n = number of elements in grid
        # Space O(n^2)
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 0:
                    for row, col in directions:
                        if 0 <= row + i < len(grid) \
                            and 0 <= col + j < len(grid):
                            graph[(i,j)].add((row+i,col+j))

        if not graph:
            return 1
  
        # Time O(n) 
        #   There can be maxinum of 8 edges for each node
        #   Thus, number of edges is constant
        # Space O(n)
        def bfs(graph, start, end):

            explored = set()
            explored.add(start)
            
            queue = deque()
            queue.append((start, 0))

            while queue:
                node, depth = queue.popleft()

                for next_node in graph[node]:
                    if next_node == end:
                        return depth + 2

                    if next_node not in explored:
                        explored.add(next_node)
                        queue.append((next_node, depth+1))

            return -1
        
        return bfs(graph, (0,0), (len(grid)-1, len(grid[0])-1))</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/shortest-path-in-binary-matrix">1091. Shortest Path in Binary Matrix</a>
  </div>
</div>

<div class="card mb-4" id="graph-bfs">
  <div class="card-body">
    <h2 class="card-title">Diagonal Traverse II (M) (F) #</h2>

<pre><code class="python">class Solution:
    def findDiagonalOrder(self, nums: List[List[int]]) -> List[int]:

        # BFS
        # Traverse from top-left and construct graph
        # At each node, the next node is right and bottom 

        graph = defaultdict(list)  # We need ordering!
        dirs = [(1, 0), (0, 1)]
        n = len(nums)
        
        # Time O(nm)
        # Space O(nm)
        for i in range(n):
            m = len(nums[i])
            for j in range(m):
                for x, y in dirs:
                    if 0 <= i + x < n \
                        and 0 <= j + y < len(nums[i+x]):
                        print(len(nums[i+x]))
                        graph[(i,j)].append((i+x,j+y))
        
        result = []

        # Time O(l+k) = O(nm)
        #   l = number of nodes = nm
        #   k = number of edges = max 2 edges per nodes
        # Space O(nm)
        def bfs(graph, start):

            explored = set()
            explored.add(start)

            queue = deque()
            queue.append(start)

            while queue:
                node = queue.popleft()
                result.append(nums[node[0]][node[1]])
                for next_node in graph[node]:
                    if next_node not in explored:
                        explored.add(next_node)
                        queue.append(next_node)

        bfs(graph, (0,0))
        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/diagonal-traverse-ii">1424. Diagonal Traverse II</a>
  </div>
</div>
<!-- Graph BFS END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>