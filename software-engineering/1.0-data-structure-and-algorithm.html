<!--

Plan
Implement
Runtime
Test

 -->

<!-- Leetcode

1 hash table
2 linked list
3 sliding window
4 k-way merge
5 two pointer
6 X
7 X
8 X
9 math
10 dynamic programming
11 two pointer
12 X
13 hash table
14 string
15 two pointer
16 two pointer
17 subsets
18 two pointer
19 linked list
20 stack
21 linked list
22 subsets
23 k-way merge
24 reverse linked list
25 reverse linked list
26 X
27 X
28 X
29 X
30 sliding window
31 two pointer
32 stack
33 modified binary search
34 modified binary search
35 modified binary search
36 array
37 backtracking
38 X
39 backtracking
40 backtracking
41 cyclic sort
42 two pointer
43 X
44 dynamic programming
45 greedy
46 subsets
47 backtracking
48 array
49 hash table
50 X
51 backtracking
52 backtracking
53 dynamic programming
54 array
55 greedy
56 merge interval
57 merge interval
58 string
59 array
60 math
61 linked list
62 dynamic programming
63 dynamic programming
64 dynamic programming
65 X
66 X
67 bit manipulation
68 X
69 X
70 dynamic programming
71 stack
72 dynamic programming
73 array
74 array
75 two pointer
76 sliding window
77 backtracking
78 subsets
79 backtracking
80 two pointer
81 modified binary search
82 linked list
83 linked list
84 stack
85 stack
86 linked list
87 string (recursion)
88 k-way merge
89 X
90 subset
91 dynamic programming
92 reverse linked list
93 backtracking
94 tree traversal
95 dynamic programming
96 dynamic programming
97 dynamic programming
98 tree traversal
99 tree traversal
100 tree dfs/bfs
101 tree dfs/bfs
102 tree bfs
103 tree bfs
104 tree dfs/bfs
105 tree traversal
106 tree traversal
107 tree bfs
108 tree dfs
109 tree dfs
110 tree dfs
111 tree dfs/bfs
112 tree dfs/bfs
113 tree dfs
114 tree traversal
115 dynamic programming
116 tree dfs/bfs
117 tree dfs/bfs
118 ?
119 ?
120 ?
121 greedy
122 greedy
123 dynamic programming
124 tree dfs
125 two pointer
126 graph bfs
127 graph bfs
128 array
129 tree dfs
130 graph dfs/bfs
131 backtracking
132 greedy
133 X
134 greedy
135 greedy
136 bit manipulation
137 bit manipulation
138 linked list
139 dynamic programming
140 dynamic programming
141 fast slow pointer
142 fast slow pointer
143 reverse linkfed list
144 tree traversal
145 tree traversal
146 custom data structure
147 linked list
148 linked list
149 geometry
150 stack
151 two pointer
152 array
153 modified binary search
154 modified binary search
155 custom data structure
156 LP
157 LP
158 LP
159 LP
160 fast slow pointer
161 LP
162 modified binary search
163 LP
164 sorting
165 X
166 X
167 two pointer
168 math
169 hash table
170 LP
171 math
172 math
173 custom data structure
174 dynamic programming
175 sql
176 sql
177 sql
178 sql
179 sorting
180 sql
181 sql
182 sql
183 sql
184 sql
185 sql
186 LP
187 sliding window
188 dynamic programming
189 array
190 bit manipulation
191 bit manipulation
192 bash
193 bash
194 bash
195 bash
196 sql
197 sql
198 dynamic programming
199 tree dfs/bfs
200 graph bfs | union find

207 topological sort
209 sliding window
210 topological sort
226 tree dfs/bfs
238 array
239 sliding window
297 tree dfs/bfs
301 graph bfs
310 graph
322 dynamic programming
329 graph dfs/bfs
332 X
394 stack
395 divide and conquer
399 graph dfs/bfs
416 dynamic programming
424 sliding window
438 sliding window
494 dynamic programming
523 array
543 tree dfs
547 graph bfs
680 two pointer
684 union find
685 union find
687 tree dfs
727 sliding window
743 graph
753 X
765 union find
785 graph dfs/bfs
797 graph dfs/bfs
802 graph dfs
809 X
818 dynamic programming
834 graph dfs/bfs
841 graph dfs/bfs
847 graph bfs + bitmask
871 dynamic programming
881 greedy
886 graph dfs/bfs
912 sorting
913 dynamic programming
925 two pointer
938 tree dfs/bfs
947 graph dfs | union find
959 graph dfs/bfs
973 geometry
990 graph dfs/bfs
1007 greedy
1029 greedy
1074 array
1137 dynamic programming
1146 custom data structure

-->

<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax/tex-chtml.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- Data structure and algorithm BEGIN -->
<div class="card mb-4" id="data-structure-and-algorithm">
  <div class="card-body">
    <h2 class="card-title">Data structure and algorithm</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#data-structure-and-algorithm-">Big O</a></li>
      <li><a href="#data-structure-and-algorithm-">Hash table</a></li>
      <li><a href="#data-structure-and-algorithm-">Linked list</a></li>
      <li><a href="#data-structure-and-algorithm-">Stack</a></li>
      <li><a href="#data-structure-and-algorithm-">Queue</a></li>
      <li><a href="#data-structure-and-algorithm-">Graph</a></li>
      <li><a href="#data-structure-and-algorithm-">Tree</a></li>
      <li><a href="#data-structure-and-algorithm-">Heap</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Big O</h2>

    <h3 class="card-title">Examples</h3>
    <ul>
      <li>Nested for-loop with dependant variables - \( O(n^2) \)</li>
<pre><code class="python">for i in range(n):
    for x in range(i):
        print(x)</code></pre>
      <li>Nested for-loop with index modification - \( O(n^2) \)</li>
<pre><code class="python">for i in range(n):
    i *= 2
    for x in range(i):
        print(x)</code></pre>
      <li>Loop statement that multiplies/divides the loop variable - \( O(\frac{log(n)}{log(k)}) \)</li>
<pre><code class="python">while i < n:
    i *= k
    print(i)</code></pre>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Hash table</h2>
    <ul>
      <li>There is always an underlying array</li>
      <li>Hash function maps keys to indexes of an array</li>
      <li>Large number of keys are mapped to small number of indexes, which could cause collision</li>
      <li>Each element of array holds a linked list to handle collision</li>
      <li>Search, insert, delete is \( O(1) \) on average and O\( (n) \) in the worst case</li>
    </ul>
<pre><code class="python"># Dictionary implementation of hash table
my_dict = {}

# Set implementation of hash table
my_set = set()</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Linked list</h2>
    <ul>
      <li>Access - \( O(n) \)</li>
      <li>Insert (at head) - \( O(1) \)</li>
      <li>Delete (at head) - \( O(1) \)</li>
      <li>Insert (at tail) - \( O(n) \)</li>
      <li>Delete (at tail) - \( O(n) \)</li>
    </ul>

<pre><code class="python"># Singly
class Node:
    def __init__(self, data=0, next=None):
        self.data = data
        self.next = next

# Doubly
class Node:
    def __init__(self, data=0, next=None, prev=None):
        self.data = data
        self.prev = prev
        self.next = next</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Stack</h2>

<pre><code class="python"># Initialize a stack
stack = []

# Adding elements at the end of a stack
stack.append('element')

# Removing elements from the end of a stack
stack.pop()

# Get the item at the front of a stack
stack[0]

# Get the item at the end of a stack
stack[-1]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Queue</h2>

<pre><code class="python"># "deque" implementation of queue
from collections import deque

# Initialize a queue
queue = deque()

# Adding elements at the end of a queue
queue.append('element')

# Removing elements from the front of a queue
queue.popleft()

# Removing elements from the end of a queue
queue.pop()

# Get the item at the front of a queue
queue[0]

# Get the item at the end of a queue
queue[-1]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Graph</h2>

    <h3 class="card-title">Representation</h3>
    <ul>
      <li>Adjacency list is space-wise more efficient than list of lists</li>
      <li>Dictionary can be used where key is each node and value is array of nodes</li>
    </ul>

<pre><code class="python"># Convert list of lists to adjacency list

from collections import defaultdict

# Directed graph

graph = defaultdict(set)

for edge in edges:
    graph[edge[1]].add(edge[0])

# Undirected graph

graph = {}

for edge in edges:
    graph[edge[1]].add(edge[0])
    graph[edge[0]].add(edge[1])</code></pre>

    <h3 class="card-title">DFS</h3>
    <ul>
      <li>Explore aggressively, only backtrack when necessary</li>
      <li>\( O(n+m) \) using stack</li>
    </ul>

<pre><code class="python">def dfs(graph, start):

    explored = set()
    explored.add(start)

    stack = []
    stack.append(start)

    while stack:
        node = stack.pop()
        for next_node in graph[node]:
            if next_node not in explored:
                explored.add(next_node)
                stack.append(next_node)</code></pre>

    <h4 class="card-title">Detect cycle</h4>

<pre><code class="python">def is_cycle(graph, start):

    explored = set()
    explored.add(start)

    stack = []
    stack.append(start)

    while stack:
        node = stack.pop()
        for next_node in graph[node]:
            if next_node not in explored:
                explored.add(next_node)
                stack.append(next_node)
            else:
                if next_node == start_node:
                    return True

    return False</code></pre>

    <h4 class="card-title">Topological ordering</h4>
    <ul>
      <li>Do DFS starting at each node counting the number of steps each starting node takes to finish DFS</li>
      <ul>
        <li>If starting node has only small number of children or even no children, DFS will finish quickly</li>
        <li>If starting node has lots of children, DFS will take time to finish</li>
      </ul>
    </ul>

<pre><code class="python">def topological_order(graph, num_nodes):

    ordering = []

    for i in range(num_nodes):
        count = self.dfs(i, graph)
        # If cycle.
        if count == -1:
            return []
        ordering.append([count, i])

    ordering.sort(key=lambda x:(-x[0]))

    return [item[1] for item in ordering]

def dfs(self, start_node, graph):

    explored = set()
    explored.add(start_node)

    stack = []
    stack.append(start_node)
    count = 1

    while stack:
        node = stack.pop()
        for next_node in graph[node]:
            if next_node not in explored:
                explored.add(next_node)
                stack.append(next_node)
                count += 1
            else:
                if next_node == start_node:
                    return -1

    return count</code></pre>

    <h4 class="card-title">Strongly connected components</h4>
    <ul>
      <li>There exist path u to v and v to u in graph G</li>
      <li>Kosaraju's two pass algorithm</li>
      <ul>
        <li>Compute SCC in O(m+n)</li>
        <li>Let G' = G with all arcs reversed</li>
        <li>Run DFS_loop on G' (compute magical ordering of nodes)</li>
        <li>Run DFS_loop on G (compute strongly connected component one by one)</li>
      </ul>
    </ul>

    <h4 class="card-title">Find mother vertex</h4>
    <ul>
      <li>Every node can be reached from the mother vertex</li>
      <li>Compute all connected groups in the graph</li>
      <li>The last visited node is the mother node</li>
    </ul>

<pre><code class="python">def find_mother_vertex(g):

    explored = set()
    last_vertex = 0

    for i in range(num_nodes):
        if i not in explored:
            dfs(i, graph, explored)
            last_vertex = i</code></pre>

    <h4 class="card-title">Check if graph is tree</h4>
    <ul>
      <li>Check if there is no cycle</li>
      <li>Check if all nodes are connected</li>
    </ul>

    <h3 class="card-title">BFS</h3>
    <ul>
      <li>Explore nodes in "layers"</li>
      <li>\( O(n+m) \) using queue</li>
    </ul>

<pre><code class="python">from collections import deque

def bfs(graph, starth):

    explored = set()
    explored.add(start)

    queue = deque()
    queue.append(start)

    while queue:
        node = queue.popleft()
        for next_node in graph[node]:
            if next_node not in explored:
                explored.add(next_node)
                queue.append(next_node)</code></pre>

    <h4 class="card-title">Shortest path</h4>
    <ul>
      <li>Compute dist(v), the fewest number of edges on path from s to v</li>
      <li>Assumption - every edge has length of 1</li>
      <li>Extra code to BFS</li>
    </ul>

<pre><code class="python">from collections import deque

def bfs(graph, start, end):

    explored = set()
    explored.add(start)

    queue = deque()
    queue.append((start, 0))

    while queue:
        item = queue.popleft()
        node = item[0]
        layer = item[1]
        for child_node in graph[node]:
            if child_node == end_node:
                return layer+1

            if child_node not in explored:
                queue.append((child_node, layer+1))
                explored.add(child_node)

    return -1</code></pre>

    <h4 class="card-title">Undirected connectivity</h4>
    <ul>
      <li>Let G(V,E) undirected graph</li>
      <li>Connected component = pieces of G</li>
      <li>Compute all connected components</li>
    </ul>

<pre><code class="python">explored = set()

for i in range(num_nodes):
    if i not in explored:
        bfs(i, graph, explored)</code></pre>

    <h3 class="card-title">Union-Find</h3>
    <ul>
      <li>Find - returns the sub-graph that a node belongs to</li>
      <li>Union - merge two sub-graphs into one sub-graph</li>
    </ul>

<pre><code class="python"># Key represents each node
# Value represents the leader of group that the node belongs to
group = {}

def find(group, node):
    return group[node]

def union(group, node, new_leader):

    # Save the previous leader
    previous_leader = group[group[node]]

    # The node's leader gets the new leader
    group[group[node]] = new_leader

    # All nodes that had the previous leader as leader must now have
    # the new leader as leader
    for k,v in group.items():
        if v == previous_leader:
            group[k] = new_leader</code></pre>

    <h3 class="card-title">Dijkstra</h3>
    <ul>
      <li>Find the shortest path from starting node to each node in "positive" weighted graph</li>
      <li>Add the starting node to the "visited" set</li>
      <li>Initialize the distance to each node to infinity except the starting node whose distance should be zero</li>
      <li>For all edges in the graph, consider edges (parent_node, child_node) where parent_node is visited and child_node is unvisited. Pick the edge where the distance to parent + the distance between parent and child is the minimum</li>
      <li>Add the child to "visited" set</li>
      <li>Update the distance to child such that dist[child] = dist[parent] + distance between parent and child</li>
      <li>Continue until all nodes in the graph are explored</li>
    </ul>

<pre><code class="python">def dijkstra(start_node, graph, n):

    explored = set()
    explored.add(start_node)

    # Distance from start_node to itself is 0
    # Otherwise, initialize distance to infinity
    distance = {}
    for i in range(1,n+1):
        if i == start_node:
            distance[i] = 0
        else:
            distance[i] = math.inf

    node = start_node

    while True:

        # If there is no more node to explore in the graph
        if len(explored) == n:
            return distance

        # Amongst all edges where one node exists in explored and the other
        # does not exist in explored, we will visit the node with smallest distance
        min_distance = math.inf
        next_node_to_visit = -1
        for node in explored:
            for item in graph[node]:
                child_node = item[0]
                dist = item[1]

                if distance[node] + dist < min_distance \
                    and child_node not in explored:
                    min_distance = distance[node] + dist
                    next_node_to_visit = child_node

        # If there is no unexplored node amongst all "directed" edges in graph
        if next_node_to_visit == -1:
            return distance

        # Mark the node as visited
        explored.add(next_node_to_visit)

        # Update the distance
        distance[next_node_to_visit] = min_distance

        # Visit the next node
        node = next_node_to_visit

    return distance</code></pre>

    <h3 class="card-title">Bellman-Ford</h3>
    <ul>
      <li>Consider all possible number of stops possible in the graph (It should be n-1)</li>
      <li>Consider all directed edges in graph</li>
      <li>Use dynamic programming to compute the minimum distance from the starting_node to every other node for each number of stops</li>
      <li>Update the minimum distance as dist[child][k] = min(dist[child][k], dist[parent][k-1] + distance between parent and child)</li>
    </ul>

<pre><code class="python">def bellman_ford(start_node, graph, n):

    # Initiallize 2D array
    # (number of nodes in graph, number of stops possible in graph)
    distance = {}
    for i in range(n):
        distance[i] = {}
        for j in range(n):
            distance[i][j] = math.inf

    # Distance from start_node in zero stops is 0
    distance[start_node][0] = 0

    # Consider all possible number of stops j
    # Time O(nm)
    # Space O(nm)
    for j in range(n-1):
        for item in graph:
            parent = item[0]
            child = item[1]
            dist = item[2]
            distance[child][j+1] = min(distance[child][j+1], distance[parent][j] + dist)

    return distance</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Tree</h2>

<pre><code class="python">class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right</code></pre>

    <h4 class="card-title">Pre-order traversal</h4>

<pre><code class="python">def pre_order_traversal(node):
    if node is not None:
        print(node.val)
        pre_order_traversal(node.left)
        pre_order_traversal(node.right)</code></pre>

    <h4 class="card-title">Post-order traversal</h4>

<pre><code class="python">def post_order_traversal(node):
    if node is not None:
        post_order_traversal(node.left)
        post_order_traversal(node.right)
        print(node.val)</code></pre>

    <h4 class="card-title">In-order traversal</h4>

<pre><code class="python">def in_order_traversal(node):
    if node is not None:
        in_order_traversal(node.left)
        print(node.val)
        in_order_traversal(node.right)</code></pre>

    <h3 class="card-title">Heap (priority queue)</h3>
    <ul>
      <li>Perfectly balanced tree</li>
      <li>Root element must have the minimum key</li>
      <li>Runtime</li>
      <ul>
        <li>Insert (add to heap) - \( O(nlogn) \)</li>
        <ul>
          <li>Create a new node at the end of the heap</li>
          <li>Place the new key at that node</li>
          <li>Perculate (swap values if needed) up until reaching the root and the heap property is satisfied</li>
        </ul>
        <li>Extract (remove an element with minimum key) - \( O(nlogn) \)</li>
        <ul>
          <li>Delete root</li>
          <li>Move last node to new root</li>
          <li>Bubble-down k until k's parent <= k</li>
        </ul>
        <li>Heapify (n batched inserts) - \( O(n) \)</li>
        <li>Delete - \( O(nlogn) \)</li>
        <ul>
          <li>Delete the root</li>
          <li>Move the key of the last child node to root</li>
          <li>Perculate (swap values if needed) up until reaching the last node and the heap property is satisfied</li>
        </ul>
      </ul>
    </ul>

    <h3 class="card-title">Balanced search tree</h3>
    <ul>
      <li>Sorted array with fast insert & delete</li>
      <li>Search - \( O(\text{log}n) \)</li>
      <li>Select - \( O(\text{log}n) \)</li>
      <li>Min/Max - \( O(\text{log}n) \)</li>
      <li>Pred/Succ - \( O(\text{log}n) \)</li>
      <li>Rank - \( O(\text{log}n) \)</li>
      <li>Output in sorted order - \( O(n) \)</li>
      <li>Insert/Delete - \( O(\text{log}n) \)</li>
    </ul>

    <h4 class="card-title">Red-Black tree</h4>
    <ul>
      <li>Each node red or black</li>
      <li>Root is black</li>
      <li>No 2 reds in a row (red node => only black children)</li>
      <li>Every root-NULL path (unsuccessful search) has the same number of black nodes</li>
      <li>Height guarantee</li>
      <ul>
        <li>Every red-black tree with n nodes has height less than or equal to \( 2\text{log}_{2}(n+1) \)</li>
      </ul>
      <li>Rotation</li>
      <ul>
        <li>Locally rebalance subtrees at a node in \( O(1) \) time</li>
        <li>Left rotation</li>
        <li>Right rotation</li>
      </ul>
      <li>Insert</li>
      <ul>
        <li>Insert x as usual (makes x a leaf)</li>
        <li>Try coloring x red</li>
        <li>If x's parent y is black, done</li>
        <li>Else y is red, then y has a black parent w</li>
      </ul>
    </ul>

    <h3 class="card-title">Binary tree</h3>
    <ul>
      <li>Exactly one node per key</li>
      <li>Each node has</li>
      <ul>
        <li>Left child pointer</li>
        <li>Right child pointer</li>
        <li>Parent</li>
      </ul>
      <li>All nodes left on node X are less than X</li>
      <li>All nodes right on node X are greater than X</li>
      <li>Many possible trees for a set of keys</li>
      <li>Height could be anywhere from \( \text{log}_{2}^{n} \) to \( n \)</li>
      <li>Generally operations are \( O(\text{height}) \)</li>
    </ul>

    <h3 class="card-title">Binary search tree</h3>
    <ul>
      <li>Binary tree where each node of the tree has key-value pairs</li>
    </ul>

<pre><code class="python">class Node(object):
    def __init__(self, val=0, left=None, right=None, parent=None):
        self.val = val
        self.left = left
        self.right = right
        self.parent = parent</code></pre>

    <h4 class="card-title">Insert</h4>

<pre><code class="python">def insert(self, val):
    current = self
    parent = None

    while current:
        parent = current
        if val < current.val:
            current = current.left
        else:
            current = current.right

    if val < parent.val:
        parent.left = Node(val)
    else:
        parent.right = Node(val)</code></pre>

    <h4 class="card-title">Search</h4>

<pre><code class="python">def search(self, val):
    current = self

    while current is not None:

        if val < current.val:
            current = current.left
        elif val > current.val:
            current = current.right
        else:
            return True

    return False</code></pre>

    <h4 class="card-title">Delete</h4>

<pre><code class="python">def delete(self, val):

    if val < self.val:
        if self.left:
            self.left = self.left.delete(val)
        else:
            print(str(val) + " not found in the tree")
            return self
    elif val > self.val:
        if self.right:
            self.right = self.right.delete(val)
        else:
            print(str(val) + " not found in the tree")
            return self
    else:
        # Delete node with no children
        if self.left is None and self.right is None:
            self = None
            return None

        # Delete node with right child
        elif self.left is None:
            tmp = self.right
            self = None
            return tmp

        # Delete node with left child
        elif self.right is None:
            tmp = self.left
            self = None
            return tmp

        # Delete node with two children
        else:
            current = self.right

            # Find the leftmost leaf.
            while current.left is not None:
                current = current.left
            self.val = current.val
            self.right = self.right.delete(current.val)

    return self</code></pre>

    <h3 class="card-title">AVL tree</h3>
    <ul>
      <li>Balanced binary search tree</li>
    </ul>

    <h4 class="card-title">Red-black tree</h4>
    <ul>
      <li>AVL tree where</li>
      <ul>
        <li>Root is always black</li>
        <li>Two red nodes cannot be adjacent</li>
      </ul>
    </ul>

<pre><code class="python">class Node:
    def __init__(self,val):
        self.val = val
        self.left = None
        self.right = None
        is_red = None</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>
<!-- Data structure and algorithm END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>