<!--

Plan
Implement
Runtime
Test

 -->

<!-- Leetcode

1 hash table
2 linked list
3 sliding window
4 k-way merge
5 two pointer
6 X
7 X
8 X
9 math
10 dynamic programming
11 two pointer
12 X
13 hash table
14 string
15 two pointer
16 two pointer
17 subsets
18 two pointer
19 linked list
20 stack
21 linked list
22 subsets
23 k-way merge
24 reverse linked list
25 reverse linked list
26 X
27 X
28 X
29 X
30 sliding window
31 two pointer
32 stack
33 modified binary search
34 modified binary search
35 modified binary search
36 array
37 backtracking
38 X
39 backtracking
40 backtracking
41 cyclic sort
42 two pointer
43 X
44 dynamic programming
45 greedy
46 subsets
47 backtracking
48 array
49 hash table
50 X
51 backtracking
52 backtracking
53 dynamic programming
54 array
55 greedy
56 merge interval
57 merge interval
58 string
59 array
60 math
61 linked list
62 dynamic programming
63 dynamic programming
64 dynamic programming
65 X
66 X
67 bit manipulation
68 X
69 X
70 dynamic programming
71 stack
72 dynamic programming
73 array
74 array
75 two pointer
76 sliding window
77 backtracking
78 subsets
79 backtracking
80 two pointer
81 modified binary search
82 linked list
83 linked list
84 stack
85 stack
86 linked list
87 string (recursion)
88 k-way merge
89 X
90 subset
91 dynamic programming
92 reverse linked list
93 backtracking
94 tree traversal
95 dynamic programming
96 dynamic programming
97 dynamic programming
98 tree traversal
99 tree traversal
100 tree dfs/bfs
101 tree dfs/bfs
102 tree bfs
103 tree bfs
104 tree dfs/bfs
105 tree traversal
106 tree traversal
107 tree bfs
108 tree dfs
109 tree dfs
110 tree dfs
111 tree dfs/bfs
112 tree dfs/bfs
113 tree dfs
114 tree traversal
115 dynamic programming
116 tree dfs/bfs
117 tree dfs/bfs
118 ?
119 ?
120 ?
121 greedy
122 greedy
123 dynamic programming
124 tree dfs
125 two pointer
126 graph bfs
127 graph bfs
128 array
129 tree dfs
130 graph dfs/bfs
131 backtracking
132 greedy
133 X
134 greedy
135 greedy
136 bit manipulation
137 bit manipulation
138 linked list
139 dynamic programming
140 dynamic programming
141 fast slow pointer
142 fast slow pointer
143 reverse linkfed list
144 tree traversal
145 tree traversal
146 custom data structure
147 linked list
148 linked list
149 geometry
150 stack
151 two pointer
152 array
153 modified binary search
154 modified binary search
155 custom data structure
156 LP
157 LP
158 LP
159 LP
160 fast slow pointer
161 LP
162 modified binary search
163 LP
164 sorting
165 X
166 X
167 two pointer
168 math
169 hash table
170 LP
171 math
172 math
173 custom data structure
174 dynamic programming
175 sql
176 sql
177 sql
178 sql
179 sorting
180 sql
181 sql
182 sql
183 sql
184 sql
185 sql
186 LP
187 sliding window
188 dynamic programming
189 array
190 bit manipulation
191 bit manipulation
192 bash
193 bash
194 bash
195 bash
196 sql
197 sql
198 dynamic programming
199 tree dfs/bfs
200 graph bfs | union find

207 topological sort
209 sliding window
210 topological sort
226 tree dfs/bfs
238 array
239 sliding window
297 tree dfs/bfs
301 graph bfs
310 graph
322 dynamic programming
329 graph dfs/bfs
332 X
394 stack
395 divide and conquer
399 graph dfs/bfs
416 dynamic programming
424 sliding window
438 sliding window
494 dynamic programming
523 array
543 tree dfs
547 graph bfs
680 two pointer
684 union find
685 union find
687 tree dfs
727 sliding window
743 graph
753 X
765 union find
785 graph dfs/bfs
797 graph dfs/bfs
802 graph dfs
809 X
818 dynamic programming
834 graph dfs/bfs
841 graph dfs/bfs
847 graph bfs + bitmask
871 dynamic programming
881 greedy
886 graph dfs/bfs
912 sorting
913 dynamic programming
925 two pointer
938 tree dfs/bfs
947 graph dfs | union find
959 graph dfs/bfs
973 geometry
990 graph dfs/bfs
1007 greedy
1029 greedy
1074 array
1137 dynamic programming
1146 custom data structure

-->

<!-- Google & Meta 1 year, all time (a)

G1-100 ✅
G2a-100
3-100
4-100
5-100
7-100
9-100
F10a
11-100
12-100
13-100
14-100
F15-100 ✅
F17-100 ✅
20-100
21-100
22-100
F23-100 ✅
F29a
F31-100 ✅
F34a
36-100
F38 ✅
41-100
G42aF42a-100
48-100
49-100
F50-100 ✅
G56aF56-100 ✅
53-100
54-100
F65 ✅
F67a
G68a-100
70-100
F71-100 ✅
F76 ✅
G85-100 ✅
F88-100 ✅
F91a
121-100
F124a
F125-100 ✅
128-100
F129 ✅
F133 ✅
F138 ✅
F139a
F140 ✅
G146F146-100 ✅
G157aF157a
G158aF158a
G159a
F161a
F162-100 ✅
G163F163 ✅
169-100
F173 ✅
198-100
F199 ✅
G200F200-100 ✅
F207 ✅
F211a
F215-100 ✅
217-100
G218a
224-100
F227-100 ❌
F236-100 ✅
F238a-100
G246aF246a
G247a
F249 ❌
G253F253-100 ✅
F266 ✅
G269aF269 ✅
F270 ✅
G271a
F273a-100
F277a
F278a
279-100
G280a
G281a
F282 ❌
F283-100
G284a
G288a
G294a
G296aF296 ✅
F297a
G298a
G299a
F301 ✅
G302a
F304 ✅
G305a
G308a
F311a
F314-100 ✅
G315 ❌
F317 ❌
G320a
F325a
G329a
F339-100 ✅
G340a
G346aF346-100 ✅
F347-100 ✅
F348 ✅
349-100
G351a
G353a
G359-100 ✅
G360a
G361a
G362a-100
G365 ✅
G366 ✅
380-100
G388 ✅
G393a
G394a
G399a
F398 ✅
G406a
F408-100 ✅
G410a
F415 ✅
G418 ❌
412-100
G425a
F426 ✅
F438a
G444 ❌
446-100
G447a
G465a
G471a
G482a
G489F489 ❌
F490 ❌
G497a
F498 ✅
F523 ✅
G524a
525-100
G527a
G528aF528-100 ✅
G539a
F543 ✅
G544a
G552a
F560-100 ✅
G562a
G568a
588-100
F597a
G616aF616a
F621a
F636-100 ❌
G642a
G652a
G655 ❌
G659a
F670 ✅
G679 ❌
F680-100 ✅
G681 ✅
G683a
G686a
F689 ❌
G690 ✅
F691 ❌
F708 ❌
713-100
G715 ❌
716-100
F721 ✅
G727a
G729a
G734a
G737a
739-100
G753a
G759 ❌
F766 ❌
767-100
G774a
G777a
F791-100 ❌
G792a
G803a
G808 ❌
G809a
G818a
F825 ❌
F827 ❌
G833 ❌
G837a
G843 ❌
G844a
G849a
G857a-100
F863 ❌
881-100
G900 ❌
G904a
G913a
F921 ❌
G929a
F938-100 ❌
G939 ❌
948-100
G951a
F953 ❌
G963 ❌
F973 ❌
G975 ❌
981-100
F986-100 ❌
F987 ❌
1002-100
F1004 ❌
G1007a
G1032a
G1036 ❌
F1047 ❌
G1048a
G1055a
G1057a
F1060 ❌
G1062 ❌
G1066a
G1087a
G1088a
F1091 ❌
G1096a
G1101 ❌
G1110 ❌
G1136 ❌
G1138a
G1146 ❌
G1153a
G1168a
G1170a
G1197a
F1209 ❌
F1216 ❌
G1231a
1235-100
G1240a
G1244a
F1249-100 ❌
G1254 ❌
1268-100
G1277a
G1284a
1291-100
G1293a
1347-100
G1376a
G1401 ❌
F1424 ❌
F1428a
F1443 ❌
G1477a
G1499a
G1509 ❌
1531-100
F1539 ❌
F1541 ❌
F1570-100
G1610a
1642-100
F1650-100 ❌
G1706a
1757-100
F1762-100 ❌
1768-100
G1825 ❌
G1834 ❌
F1868 ❌
F1891a
G1937a
G2007 ❌
G2013 ❌
G2029 ❌
G2034a
F2060 ❌
G2088 ❌
G2096a
G2101 ❌
G2115a
G2128a
G2158a
G2162a
G2178a
G2184 ❌
G2265 ❌
G2235-100 ❌
G2316 ❌
2340-100
G2369 ❌
G2366 ❌
G2402-100 ❌
G2437 ❌
G2458 ❌
2513-100
G2667-100 ❌
G2700 ❌
G2713
2759-100
2781-100
G2842 ❌
2851-100
G2863 ❌
2870-100
G2973 ❌
-->

<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax/tex-chtml.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- Data structure and algorithm BEGIN -->
<div class="card mb-4" id="data-structure-and-algorithm">
  <div class="card-body">
    <h2 class="card-title">Data structure and algorithm</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#data-structure-and-algorithm-">Big O</a></li>
      <li><a href="#data-structure-and-algorithm-">Hash table</a></li>
      <li><a href="#data-structure-and-algorithm-">Graph</a></li>
      <ul>
        <li><a href="#data-structure-and-algorithm-">DFS</a></li>
        <li><a href="#data-structure-and-algorithm-">BFS</a></li>
        <li><a href="#data-structure-and-algorithm-">Union-Find</a></li>
        <li><a href="#data-structure-and-algorithm-">Dijkstra</a></li>
        <li><a href="#data-structure-and-algorithm-">Bellman-Ford</a></li>
      </ul>
      <li><a href="#data-structure-and-algorithm-">Tree</a></li>
      <ul>
        <li><a href="#data-structure-and-algorithm-">DFS</a></li>
        <li><a href="#data-structure-and-algorithm-">BFS</a></li>
        <li><a href="#data-structure-and-algorithm-">Heap (priority queue)</a></li>
        <li><a href="#data-structure-and-algorithm-">Balanced search tree</a></li>
        <li><a href="#data-structure-and-algorithm-">Binary tree</a></li>
      </ul>
      <li><a href="#data-structure-and-algorithm-">Divide and conquer</a></li>
      <li><a href="#data-structure-and-algorithm-">Dynamic programming</a></li>
      <li><a href="#data-structure-and-algorithm-">Sort</a></li>
      <li><a href="#data-structure-and-algorithm-">Linked list</a></li>
      <li><a href="#data-structure-and-algorithm-">Stack</a></li>
      <li><a href="#data-structure-and-algorithm-">Queue</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Big O</h2>
    <!-- <ul>
      <li>\( T(n) = O(f(n)) \) iff there exists \( c, n_{0} \) such that \( T(n) \le cf(n) \) for all \( n \ge n_{0} \)</li>
      <li>\( T(n) = \Omega(f(n)) \) iff there exists \( c, n_{0} \) such that \( T(n) \ge cf(n) \) for all \( n \ge n_{0} \)</li>
      <li>\( T(n) = \Theta(f(n)) \) iff \( T(n) = O(f(n)) \) and \( T(n) = \Omega(f(n)) \)</li>
    </ul>

    <h3 class="card-title">Master's method</h3>
    <ul>
      <li>\( T(n) \le aT\left(\dfrac{n}{b}\right) + O(n^{d}) \)</li>
      <ul>
        <li>\( a \) = number of recursive step</li>
        <li>\( b \) = input size factor</li>
        <li>\( d \) = running time of "combine step"</li>
      </ul>
      <li>Examples</li>
      <ul>
        <li>\( T(n) = O(n^{d}\log{n}) \) if \( a = b^{d} \)</li>
        <li>\( T(n) = O(n^{d}) \) if \( a \lt b^{d} \)</li>
        <li>\( T(n) = O(n^{\log_{b}{a}}) \) if \( a \gt b^{d} \)</li>
      </ul>
    </ul> -->

    <h3 class="card-title">Examples</h3>
    <ul>
      <li>Nested for-loop with dependant variables - \( O(n^2) \)</li>
<pre><code class="python">for i in range(n):
    for x in range(i):
        print(x)</code></pre>
      <li>Nested for-loop with index modification - \( O(n^2) \)</li>
<pre><code class="python">for i in range(n):
    i *= 2
    for x in range(i):
        print(x)</code></pre>
      <li>Loop statement that multiplies/divides the loop variable - \( O(\frac{log(n)}{log(k)}) \)</li>
<pre><code class="python">while i < n:
    i *= k
    print(i)</code></pre>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Hash table</h2>
    <ul>
      <li>There is always an underlying array</li>
      <li>Hash function maps keys to indexes of an array</li>
      <li>Large number of keys are mapped to small number of indexes, which could cause collision</li>
      <li>Each element of array holds a linked list to handle collision</li>
    </ul>

    <h3 class="card-title">Runtime</h3>
    <ul>
      <li>Search</li>
      <ul>
        <li>On average - \( O(1) \)</li>
        <li>Worst case - \( O(n) \)</li>
      </ul>
      <li>Insert</li>
      <ul>
        <li>On average - \( O(1) \)</li>
        <li>Worst case - \( O(n) \)</li>
      </ul>
      <li>Delete</li>
      <ul>
        <li>On average - \( O(1) \)</li>
        <li>Worst case - \( O(n) \)</li>
      </ul>
    </ul>

    <h3 class="card-title">Representation</h3>

<pre><code class="python"># Dictionary implementation of hash table
my_dict = {}

# Set implementation of hash table
my_set = set()</code></pre>

    <!-- <h3 class="card-title">High level idea</h3>
    <ul>
      <li>Setup - universe \( U \)</li>
      <li>Goal - want to maintain evolving set \( S \subseteq U \)</li>
      <li>Pick \( n \) = number of "buckets"</li>
      <li>Choose a hash function \( h: U \rightarrow \{0,1,2 \dots n-1\} \)</li>
      <li>Use array \( A \) of length \( n \), store \( x \) in \( A[h(x)] \)</li>
    </ul>

    <h3 class="card-title">Resolving collisions</h3>
    <ul>
      <li>Collision - distinct \( x,y \in U \) such that \( h(x) = h(y) \)</li>
      <li>Solution #1 - (separate) chaining</li>
      <ul>
        <li>Keep linked list in each bucket</li>
        <li>Given a key/object \( x \), perform insert/delete/lookup in the list in \( A[h(x)] \)</li>
        <ul>
          <li>\( A \) = linked list for \( x \)</li>
          <li>\( h(x) \) = bucket for \( x \)</li>
        </ul>
      </ul>
      <li>Solution #2 - open addressing (only one object per bucket)</li>
      <ul>
        <li>Hash function now specifies probe sequence \( h_{1}(x), h_{2}(x) \dots \) (keep trying till finding an open slot)</li>
        <li>Ex. linear probing (look consecutively), double hashing</li>
      </ul>
    </ul>

    <h3 class="card-title">Good hash function</h3>
    <ul>
      <li>Spread data out</li>
      <li>Easy to store</li>
      <li>Fast to evaluate</li>
    </ul>

    <h3 class="card-title">Universal hash function</h3>
    <ul>
      <li>The load of a hash table \( \alpha \) = (number of objects in hash table) / (number of buckets of hash table)</li>
      <ul>
        <li>\( \alpha = O(1) \) is necessary condition for operations to run in constant time</li>
        <li>With open addressing, need \( \alpha << 1 \)</li>
      </ul>
      <li>Good hash table performance</li>
      <ul>
        <li>Need to control load</li>
        <li>Need a good hash function</li>
      </ul>
      <li>Ideally we want hash function that guarantees to spread every data set out evenly, however for every hash function, there is a pathological data set</li>
      <ul>
        <li>Use a cryptographic hash function (Ex. SHA-2)</li>
        <ul>
          <li>Infeasible to reverse engineer a pathological data set</li>
        </ul>
      </ul>
      <ul>
        <li>Use randomization</li>
        <ul>
          <li>Design a family \( H \) of hash functions such that for all data sets \( S \), "almost all" functions \( h \in H \) spread \( S \) out "pretty evenly"</li>
        </ul>
      </ul>
      <li>Definition</li>
      <ul>
        <li>Let \( H \) be a set of hash functions from \( U \) to \( \{0,1,2 \dots n-1\} \)</li>
        <li>\( H \) is universal iff for all \( x,y \) in \( U \) (with \( x != y \))</li>
        <li>\( \text{Prob}_{h \in H}[h(x) = h(y)] \le \dfrac{1}{n} \)</li>
        <ul>
          <li>\( n \) = number of buckets</li>
          <li>\( h \) is chosen uniformly at random from \( H \)</li>
        </ul>
      </ul>
    </ul>

    <h3 class="card-title">Hashing IP addresses</h3>
    <ul>
      <li>Let \( U \) = IP addresses of the form \( (x_{1}, x_{2}, x_{3}, x_{4}) \) with each \( x_{i} \in \{0,1,2 \dots 255\} \)</li>
      <li>Let \( n \) = a prime (Ex. small multiple of number of objects in hash table)</li>
      <li>Define one hash function \( h_{a} \) per 4-tuple \( a = (a_{1}, a_{2}, a_{3}, a_{4}) \) with each \( a_{i} \in \{0,1,2 \dots n-1\} \)</li>
      <li>\( h_{a} \) - IP addresses -> buckets by</li>
      <ul>
        <li>\( h_{a}(x_{1}, x_{2}, x_{3}, x_{4}) = (a_{1}x_{1} + a_{2}x_{2} + a_{3}x_{3} + a_{4}x_{4}) \) mod \( n \)</li>
        <li>\( H = \{h_{a} | a_{1}, a_{2}, a_{3}, a_{4} \in \{0,1,2 \dots n-1\} \} \)</li>
      </ul>
      <li>Claim - this family is universal</li>
      <li>Proof</li>
      <ul>
        <li>Consider distinct IP addresses \( (x_{1}, x_{2}, x_{3}, x_{4}), (y_{1}, y_{2}, y_{3}, y_{4}) \)</li>
        <li>Assume \( x_{4} != y_{4} \)</li>
        <li>Collision <=> \( a_{1}x_{1} + a_{2} + x_{2} + a_{3} + x_{3} + a_{4}x_{4} = a_{1}y_{1} + a_{2} + y_{2} + a_{3} + y_{3} + a_{4} + y_{4} \) <=> \( a_{4}(x_{4} - y_{4}) = \displaystyle\sum_{i=1}^{3}a_{i}(y_{i} - x_{i}) \) mod \( n \)</li>
        <li>With \( a_{1}, a_{2}, a_{3} \) fixed arbitrarily, how many choices of \( a_{4} \) satisfy</li>
        <ul>
          <li>\( a_{4}(x_{4} - y_{4}) = \displaystyle\sum_{i=1}^{3}a_{i}(y_{i} - x_{i}) \) mod \( n \)</li>
        </ul>
        <li>Notice that LHS is equally likely to be any of \( \{0,1,2 \dots n-1\} \) (\(x_{4} != y_{4}\), \( n \) is prime, \( a_{4} \) uniform at random)</li>
      </ul>
    </ul>

    <h3 class="card-title">Chaining (constant-time guarantee)</h3>
    <ul>
      <li>Scenario - hash table implemented with chaining. Hash function \( h \) chosen uniformly at random from universal family \( H \)</li>
      <li>Theorem - all operations run in \( O(1) \) for every data set \( S \)</li>
      <li>Caveats</li>
      <ul>
        <li>In expectation over the random choice of the hash function \( h \)</li>
        <li>Assumes \( |S| = O(n) \) (Ex. load \( \alpha = \dfrac{|S|}{n} = O(1) \))</li>
        <li>Assumes \( O(1) \) to evaluate hash function</li>
      </ul>
      <li>Proof - only analyze an unsuccessful lookup because other operations are faster</li>
      <ul>
        <li>Let \( S \) = data set with \( |S| = O(n) \)</li>
        <li>Consider lookup for \( X \notin S \)</li>
        <li>Runtime - \( O(1) + O \) (list length in \( A[h(x)]) \) (compute \( h(x) \) + traverse list)</li>
        <li>Let \( L \) = list length in \( A[h(x)] \)</li>
        <li>For \( y \in S \) (so \( y != x \)) define \( z_{y} = 1 \) if \( h(y) = h(x) \), \( 0 \) otherwise</li>
        <li>Note \( L = \displaystyle\sum_{y \in S}A_{y} \)</li>
        <li>So \( E[L] = \displaystyle\sum_{y \in S}E[z_{y}] \)</li>
        <li>\( E[z_{y}] = 0 * \text{Prob}[z_{y} = 0] + 1 * \text{Prob}[z_{y} = 1] = \text{Prob}[h(y) = h(x)] \)</li>
        <li>\( E[L] = \displaystyle\sum_{y \in S}E[z_{y}] = \displaystyle\sum_{y \in S}\text{Prob}[h(y) = h(x)] \le \displaystyle\sum_{y \in S}\dfrac{1}{n} \) (because \( H \) is universal and by definition of universal hash function) = \(\dfrac{|S|}{n} = \alpha = O(1) \)</li>
      </ul>
    </ul>

    <h3 class="card-title">Open addressing</h3>
    <ul>
      <li>One object per slot, hash function produces a probe sequence for each possible key \( x \)</li>
      <li>Difficult to analyze rigorousely</li>
      <li>Heuristic assumption - all \( n! \) probe sequences equally</li>
      <li>Claim - under heuristic assumption, expected insertion time is \( \dfrac{1}{1-\alpha} \), where \( \alpha \) = load</li>
      <li>Proof</li>
      <ul>
        <li>A random probe finds an empty slot with probability \( 1-\alpha \)</li>
        <li>Thus, insertion time is approximately equals to the number \( N \) of coin flips to get "heads", where \( \text{Prob}[\text{heads}] = 1-\alpha \)</li>
        <li>Note \( E[N] \) = (1st coin flip) + (probability of tails)(expected number of further coin flip needed) = \( 1 + \alpha E[N] \)</li>
        <li>Thus \( E[N] = \dfrac{1}{1-\alpha} \)</li>
      </ul>
    </ul>

    <h3 class="card-title">Linear probing</h3>
    <ul>
      <li>Heuristic assumption is completely false</li>
      <li>Assume instead - initial probes uniform at random independent for different keys</li>
      <li>Theorem - expected insertion time = \( \dfrac{1}{(1-\alpha)^{2}} \)</li>
    </ul>

    <h3 class="card-title">Bloom filters</h3>
    <ul>
      <li>Fast insert and lookup</li>
      <li>Compare to hash table</li>
      <ul>
        <li>More space efficient (pro)</li>
        <li>Can't store an associated object (con)</li>
        <li>No delete (con)</li>
        <li>Small false positive probability (con)</li>
        <ul>
          <li>Might say \( x \) has been inserted although it hasn't</li>
        </ul>
      </ul>
      <li>No false negative (if \( x \) was inserted, lookup(x) guaranteed to succeed)</li>
      <li>False positive if all \( k, h_{i}(x) \)'s are already set to \( 1 \) by other insertions</li>
      <li>Applications</li>
      <ul>
        <li>Early spellcheckers</li>
        <li>List of forbidden passwords</li>
        <li>Network routers (limited memory, so need to be super fast)</li>
      </ul>
      <li>Ingredients</li>
      <ul>
        <li>Array of \( n \) bits (\( \dfrac{n}{|S|} \) = number of bits per object in data set \( S \))</li>
        <li>\( k \) hash functions \( h_{1} \dots h_{k} \), where \( k \) is a small constant</li>
      </ul>
      <li>Insert(x)</li>
      <ul>
        <li>For \( i = 1,2 \dots k \) (whether or not bit already set to \( 1 \))</li>
        <ul>
          <li>Set \( A[h_{i}(x)] = 1 \)</li>
        </ul>
      </ul>
      <li>Lookup(x)</li>
      <ul>
        <li>Return True <=> \( A[h_{i}(x)] = 1 \) for every \( i = 1,2 \dots k \)</li>
      </ul>
    </ul>

    <h3 class="card-title">Heuristic analysis</h3>
    <ul>
      <li>Intuition - should be a trade-off between space and error (false positive) probability</li>
      <li>Assume - all \( h_{i}(x) \)'s uniformly random and independent (across different \( i \)'s and \( x \)'s)</li>
      <li>Setup - \( n \) bits, insert data set \( S \) into bloom filter</li>
      <li>Note - for each bit of \( A \), the probability it's been set to \( 1 \) is</li>
      <ul>
        <li>\( 1-(1-\dfrac{1}{n})^{k|S|} \le 1 - e^{-k|S|/n} = 1 - e^{-k/b} \), \( b \) = number of bits per object \( \dfrac{n}{|S|} \)</li>
      </ul>
      <li>Thus, false positive probability is \( \le [1-e^{-k/b}]^{k} = \epsilon \)</li>
      <li>For fixed \( b, \epsilon \) is minimized by setting</li>
      <ul>
        <li>\( \epsilon \approx \dfrac{1}{2}^{(ln2)b} \)</li>
      </ul>
    </ul> -->
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Graph</h2>

    <h3 class="card-title">Representation</h3>
    <ul>
      <li>Adjacency list is space-wise more efficient than list of lists</li>
      <li>Dictionary can be used where key is each node and value is array of nodes</li>
    </ul>

<pre><code class="python"># Convert list of lists to adjacency list

from collections import defaultdict

# Directed graph

graph = defaultdict(set)

for edge in edges:
    graph[edge[1]].add(edge[0])

# Undirected graph

graph = {}

for edge in edges:
    graph[edge[1]].add(edge[0])
    graph[edge[0]].add(edge[1])</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">DFS</h2>
    <ul>
      <li>Explore aggressively, only backtrack when necessary</li>
      <li>\( O(n+m) \) using stack</li>
    </ul>

<pre><code class="python">def dfs(graph, start):

    explored = set()
    explored.add(start)

    stack = []
    stack.append(start)

    while stack:
        node = stack.pop()
        for next_node in graph[node]:
            if next_node not in explored:
                explored.add(next_node)
                stack.append(next_node)</code></pre>

    <h3 class="card-title">Detect cycle</h3>

<pre><code class="python">def dfs(graph, start):

    explored = set()
    explored.add(start)

    stack = []
    stack.append(start)

    while stack:
        node = stack.pop()
        for next_node in graph[node]:
            if next_node not in explored:
                explored.add(next_node)
                stack.append(next_node)
            else:
                if next_node == start_node:
                    return True

    return False</code></pre>

    <h3 class="card-title">Topological ordering</h3>
    <ul>
      <li>Do DFS starting at each node counting the number of steps each starting node takes to finish DFS</li>
      <ul>
        <li>If starting node has only small number of children or even no children, DFS will finish quickly</li>
        <li>If starting node has lots of children, DFS will take time to finish</li>
      </ul>
    </ul>

<pre><code class="python">def topological_order(graph, num_nodes):

    def dfs(graph, start):

      explored = set()
      explored.add(start)

      stack = []
      stack.append(start)
      count = 1

      while stack:
          node = stack.pop()
          for next_node in graph[node]:
              if next_node not in explored:
                  explored.add(next_node)
                  stack.append(next_node)
                  count += 1
              else:
                  if next_node == start_node:
                      return -1

      return count

    ordering = []

    for i in range(num_nodes):
        count = dfs(i, graph)
        # If cycle
        if count == -1:
            return []
        ordering.append([count, i])

    ordering.sort(key=lambda x:(-x[0]))

    return [item[1] for item in ordering]

</code></pre>

    <h3 class="card-title">Strongly connected components</h3>
    <ul>
      <li>There exist path u to v and v to u in graph G</li>
      <li>Kosaraju's two pass algorithm</li>
      <ul>
        <li>Compute SCC in \( O(m+n) \)</li>
        <li>Let G' = G with all arcs reversed</li>
        <li>Run DFS_loop on G' (compute magical ordering of nodes)</li>
        <li>Run DFS_loop on G (compute strongly connected component one by one)</li>
      </ul>
    </ul>

    <h3 class="card-title">Find mother vertex</h3>
    <ul>
      <li>Every node can be reached from the mother vertex</li>
      <li>Compute all connected groups in the graph</li>
      <li>The last visited node is the mother node</li>
    </ul>

<pre><code class="python">def find_mother_vertex(g):

    explored = set()
    last_vertex = 0

    for i in range(num_nodes):
        if i not in explored:
            dfs(i, graph, explored)
            last_vertex = i</code></pre>

    <h3 class="card-title">Check if graph is tree</h3>
    <ul>
      <li>Check if there is no cycle</li>
      <li>Check if all nodes are connected</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">BFS</h2>
    <ul>
      <li>Explore nodes in layers</li>
      <li>\( O(n+m) \) using queue</li>
    </ul>

<pre><code class="python">from collections import deque

def bfs(graph, start):

    explored = set()
    explored.add(start)

    queue = deque()
    queue.append(start)

    while queue:
        node = queue.popleft()
        for next_node in graph[node]:
            if next_node not in explored:
                explored.add(next_node)
                queue.append(next_node)</code></pre>

    <h3 class="card-title">Shortest path</h3>
    <ul>
      <li>Compute dist(v), the fewest number of edges on path from s to v</li>
      <li>Assumption - every edge has length of 1</li>
      <li>Extra code to BFS</li>
    </ul>

<pre><code class="python">from collections import deque

def bfs(graph, start, end):

    explored = set()
    explored.add(start)

    queue = deque()
    queue.append((start, 0))

    while queue:
        node, layer = queue.popleft()

        for next_node in graph[node]:
            if next_node == end_node:
                return layer + 1

            if next_node not in explored:
                queue.append((next_node, layer+1))
                explored.add(next_node)

    return -1</code></pre>

    <h3 class="card-title">Undirected connectivity</h3>
    <ul>
      <li>Let G(V,E) undirected graph</li>
      <li>Connected component = pieces of G</li>
      <li>Compute all connected components</li>
    </ul>

<pre><code class="python">explored = set()

for i in range(num_nodes):
    if i not in explored:
        bfs(i, graph, explored)</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Union-Find</h2>
    <ul>
      <li>Find - returns the sub-graph that a node belongs to</li>
      <li>Union - merge two sub-graphs into one sub-graph</li>
    </ul>

<pre><code class="python"># Key represents each node
# Value represents the leader of group that the node belongs to
group = {}

def find(group, node):
    return group[node]

def union(group, node, new_leader):

    # Save the previous leader
    previous_leader = group[group[node]]

    # The node's leader gets the new leader
    group[group[node]] = new_leader

    # All nodes that had the previous leader as leader must now have
    # the new leader as leader
    for k,v in group.items():
        if v == previous_leader:
            group[k] = new_leader</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Dijkstra</h2>
    <ul>
      <li>Find the shortest path from starting node to each node in "positive" weighted graph</li>
      <li>Add the starting node to the "visited" set</li>
      <li>Initialize the distance to each node to infinity except the starting node whose distance should be zero</li>
      <li>For all edges in the graph, consider edges (parent_node, child_node) where parent_node is visited and child_node is unvisited. Pick the edge where the distance to parent + the distance between parent and child is the minimum</li>
      <li>Add the child to "visited" set</li>
      <li>Update the distance to child such that dist[child] = dist[parent] + distance between parent and child</li>
      <li>Continue until all nodes in the graph are explored</li>
    </ul>

<pre><code class="python">def dijkstra(start_node, graph, n):

    explored = set()
    explored.add(start_node)

    # Distance from start_node to itself is 0
    # Otherwise, initialize distance to infinity
    distance = {}
    for i in range(1,n+1):
        if i == start_node:
            distance[i] = 0
        else:
            distance[i] = math.inf

    node = start_node

    while True:

        # If there is no more node to explore in the graph
        if len(explored) == n:
            return distance

        # Amongst all edges where one node exists in explored and the other
        # does not exist in explored, we will visit the node with smallest distance
        min_distance = math.inf
        next_node_to_visit = -1
        for node in explored:
            for item in graph[node]:
                child_node = item[0]
                dist = item[1]

                if distance[node] + dist < min_distance \
                    and child_node not in explored:
                    min_distance = distance[node] + dist
                    next_node_to_visit = child_node

        # If there is no unexplored node amongst all "directed" edges in graph
        if next_node_to_visit == -1:
            return distance

        # Mark the node as visited
        explored.add(next_node_to_visit)

        # Update the distance
        distance[next_node_to_visit] = min_distance

        # Visit the next node
        node = next_node_to_visit

    return distance</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Bellman-Ford</h2>
    <ul>
      <li>Consider all possible number of stops possible in the graph (It should be n-1)</li>
      <li>Consider all directed edges in graph</li>
      <li>Use dynamic programming to compute the minimum distance from the starting_node to every other node for each number of stops</li>
      <li>Update the minimum distance as dist[child][k] = min(dist[child][k], dist[parent][k-1] + distance between parent and child)</li>
    </ul>

<pre><code class="python">def bellman_ford(start_node, graph, n):

    # Initiallize 2D array
    # (number of nodes in graph, number of stops possible in graph)
    distance = {}
    for i in range(n):
        distance[i] = {}
        for j in range(n):
            distance[i][j] = math.inf

    # Distance from start_node in zero stops is 0
    distance[start_node][0] = 0

    # Consider all possible number of stops j
    # Time O(nm)
    # Space O(nm)
    for j in range(n-1):
        for item in graph:
            parent = item[0]
            child = item[1]
            dist = item[2]
            distance[child][j+1] = min(distance[child][j+1], distance[parent][j] + dist)

    return distance</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Tree</h2>

    <h3 class="card-title">Representation</h3>

<pre><code class="python">class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">DFS</h2>

    <h3 class="card-title">Pre-order traversal</h3>

<pre><code class="python">def pre_order_traversal(node):
    if node is not None:
        print(node.val)
        pre_order_traversal(node.left)
        pre_order_traversal(node.right)</code></pre>

    <h3 class="card-title">Post-order traversal</h3>

<pre><code class="python">def post_order_traversal(node):
    if node is not None:
        post_order_traversal(node.left)
        post_order_traversal(node.right)
        print(node.val)</code></pre>

    <h3 class="card-title">In-order traversal</h3>

<pre><code class="python">def in_order_traversal(node):
    if node is not None:
        in_order_traversal(node.left)
        print(node.val)
        in_order_traversal(node.right)</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">BFS</h2>

<pre><code class="python"></code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Heap (priority queue)</h2>
    <ul>
      <li>Perfectly balanced tree</li>
      <li>Root element must have the minimum key</li>
      <li>Runtime</li>
      <ul>
        <li>Heapify (n batched inserts) - \( O(n) \)</li>
        <li>Extract (remove an element with minimum key) - \( O(?) \)</li>
        <ul>
          <li>Delete root</li>
          <li>Move last node to new root</li>
          <li>Bubble-down k until k's parent <= k</li>
        </ul>
        <li>Insert (add to heap) - \( O(?) \)</li>
        <ul>
          <li>Create a new node at the end of the heap</li>
          <li>Place the new key at that node</li>
          <li>Perculate (swap values if needed) up until reaching the root and the heap property is satisfied</li>
        </ul>
        <li>Delete - \( O(?) \)</li>
        <ul>
          <li>Delete the root</li>
          <li>Move the key of the last child node to root</li>
          <li>Perculate (swap values if needed) up until reaching the last node and the heap property is satisfied</li>
        </ul>
      </ul>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Balanced search tree</h2>
    <ul>
      <li>Sorted array with fast insert & delete</li>
      <li>Search - \( O(\log{n}) \)</li>
      <li>Insert/Delete - \( O(\log{n}) \)</li>
      <li>Select - \( O(\log{n}) \)</li>
      <li>Min/Max - \( O(\log{n}) \)</li>
      <li>Pred/Succ - \( O(\log{n}) \)</li>
      <li>Rank - \( O(\log{n}) \)</li>
      <li>Output in sorted order - \( O(n) \)</li>
    </ul>

    <h3 class="card-title">Red-Black tree</h3>
    <ul>
      <li>Each node red or black</li>
      <li>Root is black</li>
      <li>No 2 reds in a row (red node => only black children)</li>
      <li>Every root-NULL path (unsuccessful search) has the same number of black nodes</li>
      <li>Height guarantee</li>
      <ul>
        <li>Every red-black tree with n nodes has height less than or equal to \( 2\text{log}_{2}(n+1) \)</li>
      </ul>
      <li>Rotation</li>
      <ul>
        <li>Locally rebalance subtrees at a node in \( O(1) \) time</li>
        <li>Left rotation</li>
        <li>Right rotation</li>
      </ul>
      <li>Insert</li>
      <ul>
        <li>Insert x as usual (makes x a leaf)</li>
        <li>Try coloring x red</li>
        <li>If x's parent y is black, done</li>
        <li>Else y is red, then y has a black parent w</li>
      </ul>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Binary tree</h2>
    <ul>
      <li>Exactly one node per key</li>
      <li>Each node has</li>
      <ul>
        <li>Left child pointer</li>
        <li>Right child pointer</li>
        <li>Parent</li>
      </ul>
      <li>All nodes left on node X are less than X</li>
      <li>All nodes right on node X are greater than X</li>
      <li>Many possible trees for a set of keys</li>
      <li>Height could be anywhere from \( \text{log}_{2}^{n} \) to \( n \)</li>
      <li>Generally operations are \( O(\text{height}) \)</li>
    </ul>

    <h3 class="card-title">Binary search tree</h3>
    <ul>
      <li>Binary tree where each node of the tree has key-value pairs</li>
    </ul>

<pre><code class="python">class Node(object):
    def __init__(self, val=0, left=None, right=None, parent=None):
        self.val = val
        self.left = left
        self.right = right
        self.parent = parent</code></pre>

    <h4 class="card-title">Search</h4>

<pre><code class="python">def search(self, val):
    current = self

    while current is not None:

        if val < current.val:
            current = current.left
        elif val > current.val:
            current = current.right
        else:
            return True

    return False</code></pre>

    <h4 class="card-title">Insert</h4>

<pre><code class="python">def insert(self, val):
    current = self
    parent = None

    while current:
        parent = current
        if val < current.val:
            current = current.left
        else:
            current = current.right

    if val < parent.val:
        parent.left = Node(val)
    else:
        parent.right = Node(val)</code></pre>

    <h4 class="card-title">Delete</h4>

<pre><code class="python">def delete(self, val):

    if val < self.val:
        if self.left:
            self.left = self.left.delete(val)
        else:
            print(str(val) + " not found in the tree")
            return self
    elif val > self.val:
        if self.right:
            self.right = self.right.delete(val)
        else:
            print(str(val) + " not found in the tree")
            return self
    else:
        # Delete node with no children
        if self.left is None and self.right is None:
            self = None
            return None

        # Delete node with right child
        elif self.left is None:
            tmp = self.right
            self = None
            return tmp

        # Delete node with left child
        elif self.right is None:
            tmp = self.left
            self = None
            return tmp

        # Delete node with two children
        else:
            current = self.right

            # Find the leftmost leaf.
            while current.left is not None:
                current = current.left
            self.val = current.val
            self.right = self.right.delete(current.val)

    return self</code></pre>

    <h3 class="card-title">AVL tree</h3>
    <ul>
      <li>Balanced binary search tree</li>
    </ul>

    <h4 class="card-title">Red-black tree</h4>
    <ul>
      <li>AVL tree where</li>
      <ul>
        <li>Root is always black</li>
        <li>Two red nodes cannot be adjacent</li>
      </ul>
    </ul>

<pre><code class="python">class Node:
    def __init__(self,val):
        self.val = val
        self.left = None
        self.right = None
        is_red = None</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Divide and conquer</h2>

    <h3 class="card-title">Closest pair</h3>
    <ul>
      <li>Input</li>
      <ul>
        <li>Let \( P = \{p_{1} \dots p_{n}\} \) points in \( {\rm I\!R^{2}} \)</li>
        <li>Let \( d(p_{i}, p_{j}) \) be Eucliean distance of \( p_{i}, p_{j} \)</li>
      </ul>
      <li>Output</li>
      <ul>
        <li>\( p, q \) such that $\( d(p,q) \) is the minumum</li>
      </ul>
      <li>Naive approach</li>
      <ul>
        <li>Sort points - \( O(n\log{n}) \)</li>
        <li>Return the closest pair of adjacent points - \( O(n) \)</li>
        <li>In total - \( O(n^{2}) \)</li>
      </ul>
      <li>Divide-and-conquer</li>
      <ul>
        <li>Let \( Q \) = left half of \( P \) and \( R \) = right half of \( P \)</li>
        <li>Form \( Q_{x}, Q_{y}, R_{x}, R_{y} \)</li>
        <li>\( (p_{1}, q_{1}) \) = closest_pair \( (Q_{x}, Q_{y}) \)</li>
        <li>\( (p_{2}, q_{2}) \) = closest_pair \( (R_{x}, R_{y}) \)</li>
        <li>Let \( \delta = min\left[d(p_{1}, q_{1}), d(p_{2}, q_{2})\right] \)</li>
        <li>\( (p_{3}, q_{3}) \) = closest_split_pair \( (p_{x}, p_{y}, \delta) \)</li>
        <li>Return the best of \( (p_{1}, q_{1}), (p_{2}, q_{2}), (p_{3}, q_{3}) \)</li>
      </ul>
      <li>closest_split_pair</li>
      <ul>
        <li>Let \( \bar{x} \) = the biggest x-coordinate in left of \( P \)</li>
        <li>Let \( S_{y} \) = points of \( P \) with x-coordinates in sorted by y-coordinate</li>
        <li>Initialize best = \( \delta \), best_pair = None</li>
        <li>For \( i = 1 \) to \( |S_{y}| - 7 \)</li>
        <ul>
          <li>For \( j = 1 \) to \( 7 \)</li>
          <ul>
            <li>Let \( p \) = \( i \)th point of \( S_{y} \)</li>
            <li>Let \( q \) = \( (i+j) \)th point of \( S_{y} \)</li>
            <li>If \( d(p,q) \) < best</li>
            <ul>
              <li>best_pair = \( (p,q) \)</li>
              <li>best = \( d(p,q) \)</li>
            </ul>
          </ul>
        </ul>
      </ul>
    </ul>

    <!-- <h3 class="card-title">Correctness</h3>
    <ul>
      <li>Let \( p \in Q, q \in R \) be a split pair with \( d(p,q) \lt \delta \)</li>
      <li>(A) \( p \) and \( q \) are members of \( S_{y} \)</li>
      <li>(B) \( p \) and \( q \) are at most 7 positions apart of \( S_{y} \)</li>
      <li>Corollary - if the closest pair of \( P \) is a split pair, then the closest_split_pair finds it</li>
    </ul>

    <h4 class="card-title">Proof of (A)</h4>
    <ul>
      <li>Let \( p = (x_{1}, y_{1}) \in Q \)</li>
      <li>Let \( q = (x_{2}, y_{2}) \in R \)</li>
      <li>Let \( d(p,q) \le \delta \)</li>
      <li>Since \( (p,q) \le \delta \), \( |x_{1} - x_{2}| \le \delta \) and \( |y_{1} - y_{2}| \le \delta \)</li>
      <li>\( p \in Q \) => \( x_{1} \le \bar{x}, q \in R \) => \( x_{2} \ge \bar{x} \)</li>
      <li>Thus, \( x_{1}, x_{2} \in [\bar{x} - \delta, \bar{x} + \delta] \)</li>
    </ul>

    <h4 class="card-title">Proof of (B)</h4>
    <ul>
      <li>Consider \( \delta / 2 \) by \( \delta / 2 \) boxes with center \( \bar{x} \) and bottom \( min\{y_{1}, y_{2}\} \)</li>
      <li>Lemma 1 - all points of \( S_{y} \) with y-coordinate between those of \( p \) and \( q \) lie in one of 8 boxes</li>
      <ul>
        <li>Proof - y-coordinates of \( p,q \) differ by less than \( \delta \) and x-coordinates are between \( \bar{x} - \delta, \bar{x} + \delta \)</li>
      </ul>
      <li>Lemma 2 - at most one point of \( P \) in each box</li>
      <ul>
        <li>proof - suppose \( a,b \) lie in the same box. Then, \( a,b \) are either both in \( Q \) or both in \( R \). Then, \( d(a,b) \le \dfrac{\delta}{2}\sqrt{2} \le \delta \). But, this contradicts the definition of \( \delta \)</li>
      </ul>
    </ul> -->
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Dynamic programming</h2>
    <ul>
      <li>Identify a small number of sub-problems</li>
      <li>Can quickly + correctly solve "larger" sub-problems given the solutions to "smaller sub-problems"</li>
      <li>Solving all sub-problems computes final solution</li>
    </ul>

    <h3 class="card-title">Weighted independent sets</h3>
    <ul>
      <li>Input - a path graph \( G = (V,E) \) with non-negative weights on vertices</li>
      <li>Desired output - subset of nonadjacent vertices (an independent set of maximum total weight)</li>
      <li>Brute force - exponential time</li>
      <li>Optimal structure</li>
      <ul>
        <li>Reason about structure of an optimal solution</li>
        <li>Let \( S \le V \) be a max-weight independent set (IS)</li>
        <li>Let \( v_{n} \) = last vertex of path</li>
      </ul>
      <li>A case analysis</li>
      <ul>
        <li>Case #1 - suppose \( v_{n} \in S \). let \( G^{'} = G \) with \( v_{n} \) deleted</li>
        <ul>
          <li>Note - \( S \) also an IS of \( G^{'} \)</li>
          <li>Note - \( S \) must be a max-weight IS of \( G^{'} \) - if \( S^{*} \) was better, it would also be better than \( S \) in \( G \) (contradiction)</li>
        </ul>
        <li>Case #2 - suppose \( v_{n} \in S \)</li>
        <ul>
          <li>Note - previous vertex \( v_{n-1} \notin S \) (by definition of IS). Let \( G^{''} = G \) with \( v_{n-1}, v_{n} \) deleted</li>
          <li>Note - \( S-\{v_{n}\} \) is an IS of \( G^{''} \)</li>
          <li>Note - must in fact be a max-weight IS of \( G^{''} \) - if \( S{*} \) is better than \( S \) in \( G^{''} \), then \( S^{*}\cup\{v_{n}\} \) is better than \( S \) in \( G \) (contradiction)</li>
        </ul>
      </ul>
      <li>Optimal solution</li>
      <ul>
        <li>Reformulate as a bottom-up iterative algorithm. Let \( G_{i} \) = 1st vertices of \( G \)</li>
        <li>Populate array \( A \) left to right with \( A[i] \) = value of max-weight IS of \( G_{i} \)</li>
        <li>Initialize \( A[0] = 0, A[1] = w_{1} \)</li>
        <li>For \( i = 2,3 \dots n \)</li>
        <ul>
          <li>\( A[i] = max{A[i-1], A[i-2]+w_{i}} \)</li>
        </ul>
        <li>Runs in \( O(n) \)</li>
        <li>Trace back through filled-in array to reconstruct optimal solution</li>
        <li>Key point - we know that a vertex \( v_{i} \) belongs to a max-weight IS of \( G_{i} \) <=> \( w_{i} \) + max-weight IS of \( G_{i-2} \ge \) max-weight IS of \( G_{i-1} \)</li>
      </ul>
      <li>A reconstruction algorithm - trace back through filled-in array to reconstruct optimal solution</li>
      <ul>
        <li>Let \( A \) = filled-in array</li>
        <li>Let \( S \) = empty set</li>
        <li>While \( i \ge 1 \)</li>
        <ul>
          <li>If \( A[i-1] \ge A[i-2] + w_{i} \) (case 1 wins)</li>
          <ul>
            <li>Decrease i by 1</li>
          </ul>
          <li>Else (case 2 wins)</li>
          <ul>
            <li>Add \( v_{i} \) to \( S \)</li>
            <li>Decrease \( i \) by 2</li>
          </ul>
        </ul>
        <li>Return \( S \)</li>
      </ul>
    </ul>

    <h3 class="card-title">Knapsack problem</h3>
    <ul>
      <li>Input - \( n \) items</li>
      <ul>
        <li>Value \( v_{i} \) (non-negative)</li>
        <li>Size \( w_{i} \) (non-negative and integral)</li>
        <li>Capacity \( W \) (non-negative integer)</li>
      </ul>
      <li>Output - subset \( S \in \{1 \dots n\} \) that maximizes \( \displaystyle\sum_{i}v_{i} \) subject to \( \displaystyle\sum_{i}w_{i} \le W \)</li>
      <li>Step #1</li>
      <ul>
        <li>Let \( S \) = a max-value solution</li>
        <li>Suppose item \( n \notin S \). \( S \) must be optimal with first \( n-1 \) items with capacity \( W \)</li>
        <ul>
          <li>If \( S^{*} \) were better than \( S \) with respect to 1st \( n-1 \) items, then this equally true with respect to all \( n \) items -> contradiction</li>
        </ul>
        <li>Suppose item \( n \in S \). \( S-\{n\} \) must be optimal with first \( n-1 \) items with capacity \( W-w_{n} \)</li>
        <ul>
          <li>If \( S^{*} \) has higher value than \( S-\{n\} \) + totla size \( \le W-w_{n} \), then \( S\cup\{n\} \) has size \( \le W \) and value more than \( S \) -> contradiction</li>
        </ul>
      </ul>
      <li>Step #2</li>
      <ul>
        <li>Let \( v_{i,x} \) = value of the best solution that</li>
        <ul>
          <li>Uses only the first \( i \) items</li>
          <li>Has total size \( \le x \)</li>
        </ul>
        <li>For i = 1 to n and any x</li>
        <ul>
          <li>\( v_{i,x} = \text{max}\{v_{i-1,x}\} \) (case when item \( i \) in excluded), \( v_{i} + v_{i-1,x-w_{i}} \) (case when item \( i \) in included)}</li>
        </ul>
        <li>If \( w_{i} > x \), then \( v_{i,x} = v_{i-1,x} \)</li>
      </ul>
      <li>Step #3</li>
      <ul>
        <li>Let \( A \) = 2D array</li>
        <li>Init \( A[0,x] = 0 \) for \( x = 0 \dots W \)</li>
        <li>For \( i = 1 \dots n \)</li>
        <ul>
          <li>For \( x = 0 \dots W \)</li>
          <ul>
            <li>\( A[i,x] = \text{max}\{A[i-1, x], A[i-1, x-w_{i}] + v_{i}\} \) (ignore second term if \( w_{i} \gt x \))</li>
          </ul>
        </ul>
        <li>Return \( A[n,W] \)</li>
        <li>Runs in \( \theta(nW) \)</li>
      </ul>
    </ul>

    <h3 class="card-title">Sequence alignment</h3>
    <ul>
      <li>Input - strings \( X = x_{1} \dots x_{m}, Y = y_{1} \dots y_{m} \) over some alphabet (like \( \{A,C,G,T\} \))</li>
      <ul>
        <li>Penalty \( \alpha_{gap} \ge 0 \) for inserting a gap, \( \alpha_{ab} \) for matching \( a \) and \( b \)</li>
      </ul>
      <li>Alignment - insert gaps to equalize length of string</li>
      <li>Goal - alignment with minimum possible total penalty</li>
      <li>Final position of string can be one of</li>
      <ul>
        <li>Case1 - \( x_{m} \) and \( y_{n} \) matched</li>
        <li>Case2 - \( x_{m} \) is matched with a gap</li>
        <li>Case3 - \( y_{n} \) is matched with a gap</li>
      </ul>
      <li>Let \( X^{'} = X - x_{m} \) and \( Y^{'} = Y - y_{m} \)</li>
      <ul>
        <li>Case1 - alignment of \( X^{'} \) and \( Y^{'} \) is optimal</li>
        <li>Case2 - alignment of \( X^{'} \) and \( Y \) is optimal</li>
        <li>Case3 - alignment of \( X \) and \( Y^{'} \) is optimal</li>
      </ul>
      <li>Subproblem \( (X_{i}m Y_{j}) \)</li>
      <ul>
        <li>\( X_{i} \) = 1st \( i \) letters of \( X \)</li>
        <li>\( Y_{j} \) = 1st \( j \) letters of \( Y \)</li>
      </ul>
      <li>Recurrence</li>
      <ul>
        <li>Let \( P_{ij} \) = penalty of optimal alignment of \( X_{i} \) and \( Y_{j} \)</li>
        <li>For all i = 1 to n and j = 1 to n, \( P_{ij} \) is the <strong>minimun</strong> of the following three cases</li>
        <li>Case1 - \( \alpha_{x_{i}y_{j}} + P_{i-1,j-1} \)</li>
        <li>Case2 - \( \alpha_{gap} + P_{i-1,j} \)</li>
        <li>Case3 - \( \alpha_{gap} + P_{i,j-1} \)</li>
      </ul>
      <li>Algorithm</li>
      <ul>
        <li>Let \( A \) = 2D array</li>
        <li>\( A[i,0] = A[0,j] = i * \alpha_{gap} \forall i \ge 0 \)</li>
        <li>For \( i = 1 \dots m \)</li>
        <ul>
          <li>For \( j = 1 \dots n \)</li>
          <ul>
            <li>\( A[i,j] = min\{A[i-1,j-1]+\alpha_{x_{i}y_{j}}, A[i-1,j]+\alpha_{gap}, A[i,j-1]+\alpha_{gap}\} \)</li>
          </ul>
        </ul>
        <li>Runs in \( O(mn) \)</li>
      </ul>
      <li>Reconstructing a solution</li>
      <ul>
        <li>Trace back through filled-in table \( A_{i} \) starting at \( A[m,n] \)</li>
        <li>When reaching subproblem \( A[i,j] \)</li>
        <ul>
          <li>If \( A[i,j] \) filled using case1, match \( x_{i} \) and \( y_{j} \), and go to \( A[i-1, j-1] \)</li>
          <li>If \( A[i,j] \) filled using case2, match \( x_{i} \) and a gap, and go to \( A[i-1, j] \)</li>
          <li>If \( A[i,j] \) filled using case3, match \( y_{j} \) and a gap, and go to \( A[i, j-1] \)</li>
        </ul>
        <li>If \( i=0 \) or \( j=0 \), match remaining substring with gaps</li>
        <li>Runs in \( O(m+n) \)</li>
      </ul>
    </ul>

    <h3 class="card-title">Optimal binary search tree</h3>
    <ul>
      <li>What is the best search tree for a given set of keys?</li>
      <li>Input - frequencies \( p_{1} \dots p_{n} \) for items \( 1 \dots n \) (assume items in sorted order \( 1 \lt \dots \lt n \))</li>
      <li>Goal - compute a valid search tree that minimizes weighted search time</li>
      <ul>
        <li>\( C(T) = \displaystyle\sum_{i}P_{i}* \) [search time for \( i \) in \( T \)]</li>
        <li>Ex. if \( T \) is a red-black tree, then \( C(T) = O(logn) \) (assuming \( \displaystyle\sum_{i}P_{i} = 1 \))</li>
      </ul>
      <li>Optimal structure</li>
      <ul>
        <li>Suppose an optimal BST for keys \( \{1,2 \dots n\} \) has root \( r \), left subtree \( T_{1} \), right subtree \( T_{2} \)</li>
        <li>Then, subtrees \( T_{1} \) and \( T_{2} \) are optimal BSTs for the keys \( \{1 \dots r-1\} \) and \( \{r+1 \dots n\} \)</li>
        <li>Proof</li>
        <ul>
          <li>Let \( T \) be an optimal BST for keys \( \{1 \dots n\} \) with frequencies \( p_{1} \dots p_{n} \)</li>
          <li>Suppose \( T \) has root \( r \)</li>
          <li>Suppose for contradiction that \( T_{1} \) is not optimal for \( \{1,2 \dots r-1\} \) (other case is similar) with \( C(T^{*}_{1}) \lt C(T_{1}) \)</li>
          <li>Obtain \( T^{*} \) from \( T \) by "cutting + pasting" \( T^{*}_{1} \) in for \( T_{1} \)</li>
          <li>Need to show \( C(T^{*}) \lt C(T) \)</li>
          <li>\( C(T) = \displaystyle\sum_{i=1}^{n}p_{i} [\text{search time for } i \text{ in } T] = p_{r} + \displaystyle\sum_{i=1}^{r-1}p_{i} [\text{search time for } i \text{ in } T] + \displaystyle\sum_{i=r+1}^{n}p_{i} [\text{search time for } i \text{ in } T] = \displaystyle\sum_{i=1}^{n}p_{i} + \displaystyle\sum_{i=1}^{r-1}p_{i} [\text{search time for } i \text{ in } T_{1}] + \displaystyle\sum_{i=r+1}^{n}p_{i} [\text{search time for } i \text{ in } T_{2}] \) = a constant (independent of \( T \)) + \( C(T_{1}) + C(T_{2}) \)</li>
          <li>\( C(T^{*}_{1}) \lt C(T_{1}) \) implies \( C(T^{*}) \lt C(T) \), contradicting optimality of \( T \)</li>
        </ul>
      </ul>
      <li>Relevant subproblems</li>
      <ul>
        <li>Key \( \{1 \dots n\} \) = original items. For which subsets \( S \in \{1 \dots n\} \) might we need to compute the optimal BST for \( S \)?</li>
        <ul>
          <li>Continuous interval (\(S = \{i, i+1 \dots j-1, j\}\)) for every \( i \le j \)</li>
        </ul>
      </ul>
      <li>Recurrence</li>
      <ul>
        <li>For \( 1 \ge i \ge j \ge n \), let \( C_{ij} \) = weighted search cost of optimal BST for items \( \{i, i+1 \dots j-1, j\} \) with properties \( \{p_{i}, p_{i+1} \dots p_{j}\} \)</li>
        <li>For every \( 1 \ge i \ge j \ge n \)</li>
        <ul>
          <li>\( C_{ij} = \underset{r=i}{\text{min}}\left[\displaystyle\sum_{k=1}^{j}P_{k}+C_{i,r-1}+C_{r+1,j}\right] \) where \( C_{i,r-1}, C_{r+1,j} = 0 \text{if} x>y \)</li>
        </ul>
        <li>Correctness - optimal substructure narrows candidates down to \( (j-i+1) \) possibilities, recurrence picks the best by brute force</li>
      </ul>
      <li>Algorithm</li>
      <ul>
        <li>Let \( A \) = 2D array</li>
        <li>For \( s = 0 \dots n-1 \) (\( s \) represent \( j-i \))</li>
        <ul>
          <li>for \( i = 1 \dots n \) (so \( i+s \) plays role of \( j \))</li>
          <ul>
            <li>\( A[i, i+s] \) = \( \underset{r=i}{\text{min}}\left[\displaystyle\sum_{k=i}^{i+s}P_{k}+A[i,r-1]+A[r+1,i+s]\right] \) where \( A[i,r-1]+A[r+1,i+s] = 0 \) if first index \( \ge \) second index</li>
          </ul>
        </ul>
        <li>Return \( A[1,n] \)</li>
        <li>Runs in \( \theta({n^{3}}) \) - (\( \theta({n^{2}}) \) subproblems, \( \theta(j-i) \) time to compute \( A[i,j] \))</li>
      </ul>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Sort</h2>

    <h3 class="card-title">Mergesort</h3>
    <ul>
      <li>There are approximately \( log_{2}n \) levels in the recursion tree</li>
      <li>At each level \( j \), there are \( 2^{j} \) sub-problems whose size is \( \dfrac{n}{2^{j}} \)</li>
      <li>Work per level is \( (2^{j})(\dfrac{n}{2^{j}}) = n \)</li>
      <li>Thus, total work is approximately \( (n)(\log{n}) \)</li>
    </ul>

<pre><code class="python">recursively sort 1st half of array
recursively sort 2nd half of array
C = output[length=n]
A = 1st sorted array[n/2]
B = 2st sorted array[n/2]
i = 1
j = 1

for k=1 to n
    if A(i) < B(j)
        C(k) = A(i)
        i++
    else B(j) < A(i)
        C(k)
        j++</code></pre>

    <h3 class="card-title">Quicksort</h3>
    <ul>
      <li>\( O(n\log{n}) \) on average</li>
      <li>No additional space required</li>
      <li>If pivot is chosen in worst way possible, the algorithm could run in \( O(n^2) \)</li>
      <li>Choosing pivot "randomly" is a good idea</li>
    </ul>

    <h4 class="card-title">Partition</h4>
    <ul>
      <li>Rearrange array so that</li>
      <ul>
        <li>Left of pivot is less than pivot</li>
        <li>Right of pivot is greater than pivot</li>
      </ul>
      <li>This also puts pivot in its rightful position</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Linked list</h2>

    <h3 class="card-title">Runtime</h3>
    <ul>
      <li>Search - \( O(n) \)</li>
      <li>Insert</li>
      <ul>
        <li>At head - \( O(1) \)</li>
        <li>At tail - \( O(n) \)</li>
      </ul>
      <li>Delete</li>
      <ul>
        <li>At head - \( O(1) \)</li>
        <li>At tail - \( O(n) \)</li>
      </ul>
    </ul>

    <h3 class="card-title">Representation</h3>

<pre><code class="python"># Singly
class Node:
    def __init__(self, data=0, next=None):
        self.data = data
        self.next = next

# Doubly
class Node:
    def __init__(self, data=0, next=None, prev=None):
        self.data = data
        self.prev = prev
        self.next = next</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Stack</h2>

    <h3 class="card-title">Representation</h3>

<pre><code class="python"># Initialize a stack
stack = []</code></pre>

    <h3 class="card-title">Runtime</h3>
    <ul>
      <li>Search</li>
      <ul>
        <li>Get item at the front of a stack - <code>stack[0]</code> - \( O(?) \)</li>
        <li>Get item at the end of a stack - <code>stack[-1]</code> - \( O(?) \)</li>
      </ul>
      <li>Insert</li>
      <ul>
        <li>Add elements at the end of a stack - <code>stack.append('element')</code> - \( O(?) \)</li>
      </ul>
      <li>Delete</li>
      <ul>
        <li>Remove elements from the end of a stack - <code>stack.pop()</code> - \( O(?) \)</li>
      </ul>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Queue</h2>

    <h3 class="card-title">Representation</h3>

<pre><code class="python"># "deque" implementation of queue
from collections import deque

# Initialize a queue
queue = deque()</code></pre>

    <h3 class="card-title">Runtime</h3>
    <ul>
      <li>Search</li>
      <ul>
        <li>Get item at the front of a queue - <code>queue[0]</code> - \( O(?) \)</li>
        <li>Get item at the end of a queue - <code>queue[-1]</code> - \( O(?) \)</li>
      </ul>
      <li>Insert</li>
      <ul>
        <li>Add elements at the end of a queue - <code>queue.append('element')</code> - \( O(?) \)</li>
      </ul>
      <li>Delete</li>
      <ul>
        <li>Remove elements from the front of a queue - <code>queue.popleft()</code> - \( O(?) \)</li>
        <li>Remove elements from the end of a queue - <code>queue.pop()</code> - \( O(?) \)</li>
      </ul>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>
<!-- Data structure and algorithm END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>