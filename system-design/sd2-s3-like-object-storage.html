<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax/tex-chtml.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- S3-like Object Storage BEGIN -->
<div class="card mb-4" id="s3-like-object-storage">
  <div class="card-body">
    <h2 class="card-title">S3-like Object Storage</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#s3-like-object-storage-1">Understand the Problem and Establish Design Scope</a></li>
      <li><a href="#s3-like-object-storage-2">Propose High-level Diagram and Get Buy-in</a></li>
      <li><a href="#s3-like-object-storage-3">Design Deep Dive</a></li>
      <li><a href="#s3-like-object-storage-4">Wrap Up</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="s3-like-object-storage-1">
  <div class="card-body">
    <h2 class="card-title">Understand the Problem and Establish Design Scope</h2>
    <ul>
      <li>What is typical data size? massive objects (GBs) and large number of small objects (KBs)</li>
      <li>How much data should the system store per year? 100PB</li>
    </ul>

    <h3 class="card-title">Bandwidth</h3>
    <ul>
      <li>Assume 20% of objects are small (0.5MB)</li>
      <li>Assume 60% of objects are medium (32MB)</li>
      <li>Assume 20% of objects are large (200MB)</li>
      <li>Assume we utilize 40% of 100PB</li>
      <li>\( \dfrac{10\text{PB} \times 0.4}{0.2 \times 0.5\text{MB} + 0.6 \times 32\text{MB} + 0.2 \times 200\text{MB}} = 0.68B \) objects</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: System Design Interview Volume 2, Alex Xu & Sahn Lam
  </div>
</div>

<div class="card mb-4" id="s3-like-object-storage-2">
  <div class="card-body">
    <h2 class="card-title">Propose High-level Diagram and Get Buy-in</h2>
    <ul>
      <img class="img-fluid" class="card-img-top" src="/system-design/image/ref-sd-2/s3-like-object-storage-1.png" alt="Card image cap">
      <ul>
        <li>IAM</li>
        <ul>
          <li>Authentication and authorization</li>
        </ul>
        <li>Data store</li>
        <ul>
          <li>Stores actual data</li>
        </ul>
      </ul>
      <li>Workflow (uploading an object)</li>
      <ul>
        <li>Client sends HTTP PUT request to API service to create a bucket</li>
        <li>API service calls IAM to ensure user has write permission</li>
        <li>API service calls metadata store to create an entry</li>
        <li>Client sends HTTP PUT request to API service to create an object</li>
        <li>API service calls IAM to ensure user has write permission</li>
        <li>API service calls data store ti persist the payload as object</li>
        <li>API service calls metadata store to create an entry</li>
      </ul>
      <li>Workflow (downloading an object)</li>
      <ul>
        <li>Client sends HTTP GET request to API service</li>
        <li>API service calls IAM to ensure user has read permission</li>
        <li>API service fetches corresponding object's UUID from metadata store</li>
        <li>API service fetches object data from data store by UUID</li>
        <li>API service returns object data to client</li>
      </ul>
      <li>Storage schema</li>
      <ul>
        <li>Bucket</li>
        <ul>
          <li>bucket_name</li>
          <li>bucket_id</li>
          <li>owner_id</li>
          <li>enable_versioning</li>
        </ul>
        <li>Object</li>
        <ul>
          <li>bucket_name</li>
          <li>object_name</li>
          <li>object_version</li>
          <li>object_id</li>
        </ul>
      </ul>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: System Design Interview Volume 2, Alex Xu & Sahn Lam
  </div>
</div>

<div class="card mb-4" id="s3-like-object-storage-3">
  <div class="card-body">
    <h2 class="card-title">Design Deep Dive</h2>
    <ul>
      <li>Data store</li>
      <img class="img-fluid" class="card-img-top" src="/system-design/image/ref-sd-2/s3-like-object-storage-2.png" alt="Card image cap">
      <ul>
        <li>Data routing service</li>
        <ul>
          <li>Query the placement service to get the best data node to store data</li>
          <li>Read data from data nodes and return it to API service</li>
          <li>Write data to data nodes</li>
        </ul>
        <li>Placement service</li>
        <ul>
          <li>Monitors all data nodes via heartbeats</li>
        </ul>
        <li>Data nodes</li>
        <ul>
          <li>Stores actual data object</li>
          <li>Data service daemon sends heartbeats to placement service</li>
        </ul>
      </ul>
      <li>Workflow</li>
      <ul>
        <li>API service forwards object data to data store</li>
        <li>Data routing service generates UUID for this object and queries the placement service for the data node to store this object</li>
        <li>Placement service checks the virtual cluster map and returns the primary node</li>
        <li>Data routing service sends data directly to primary data node</li>
        <li>Primary data node saves data locally and replicates it to two secondary data nodes</li>
        <li>Primary node responds to data routing service, then UUID of object is returned to API service</li>
      </ul>
      <li>Durability</li>
      <ul>
        <li>Replication</li>
        <ul>
          <li>6 nines (data is copied 3 times)</li>
          <li>200% storage overhead</li>
          <li>No computation</li>
          <li>No write operation needed</li>
          <li>Reads are served from the same replica</li>
        </ul>
        <li>Erasure coding</li>
        <ul>
          <li>11 nines (8+4 erasure coding)</li>
          <li>50% storage overhead</li>
          <li>Computation needed to calculate parities</li>
          <li>Write latency having to calculate parities before data is written to disk</li>
          <li>Every read must come from multiple nodes</li>
        </ul>
      </ul>
      <li>Scalability</li>
      <ul>
        <li>Size of bucket table will be small</li>
        <li>Size of object table will be large, thus sharding is needed</li>
        <ul>
          <li>Sharding by bucket_id can create hotspots</li>
          <li>Sharding by object_id makes queries that are based on object names inefficient</li>
          <li>Thus, shard by a combination of bucket_name and object_name (use the hash of &lt;bucket_name, object_name&gt;)</li>
        </ul>
      </ul>
      <li>Versioning</li>
      <ul>
        <li>A new record is inserted with the same bucket_id and object name but with a new object_id and object_version</li>
      </ul>
      <li>Uploading large files</li>
      <ul>
        <li>Workflow</li>
        <ul>
          <li>Client calls the object storage to initial a multipart upload</li>
          <li>Data store returns an upload_id</li>
          <li>Client splits the large files into smaller objects and start uploading them with upload_id</li>
          <li>When a part is uploaded, data store returns a ETag, which is md5 checksum of that part, which then is used to verify multipart upload</li>
          <li>After all parts are uploaded, client sends a complete multipart upload request, which includes upload_id, part numbers, ETags</li>
          <li>Data store reassembles the object from its parts pased on part number</li>
        </ul>
        <li>Garbage collection</li>
        <ul>
          <li>Old parts are no longer useful after the object has been reassembled from them</li>
        </ul>
      </ul>
    </ul>    
  </div>
  <div class="card-footer text-muted">
    Reference: System Design Interview Volume 2, Alex Xu & Sahn Lam
  </div>
</div>

<div class="card mb-4" id="s3-like-object-storage-4">
  <div class="card-body">
    <h2 class="card-title">Wrap Up</h2>
  </div>
  <div class="card-footer text-muted">
    Reference: System Design Interview Volume 2, Alex Xu & Sahn Lam
  </div>
</div>
<!-- S3-like Object Storage END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>