<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax/tex-chtml.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- Data structure and algorithm BEGIN -->
<div class="card mb-4" id="data-structure-and-algorithm">
  <div class="card-body">
    <h2 class="card-title">Data structure and algorithm - deep dive</h2>
    <ul>
      <li><a href="#data-structure-and-algorithm-">Big O</a></li>
      <li><a href="#data-structure-and-algorithm-">Divide and conquer</a></li>
      <li><a href="#data-structure-and-algorithm-">String</a></li>
      <li><a href="#data-structure-and-algorithm-">Array</a></li>
      <ul>
        <li>Hash table</li>
        <li>Sequence</li>
        <li>Prefix sum</li>
        <li>Sliding window</li>
        <li>Two pointers</li>
      </ul>
      <li><a href="#data-structure-and-algorithm-">Stack</a></li>
      <ul>
        <li>Monotonic stack</li>
      </ul>
      <li><a href="#data-structure-and-algorithm-">Queue</a></li>
      <ul>
        <li>Monotonic queue</li>
      </ul>
      <li><a href="#data-structure-and-algorithm-">Binary search</a></li>
      <li><a href="#data-structure-and-algorithm-">Linked list</a></li>
      <li><a href="#data-structure-and-algorithm-">Tree</a></li>
      <ul>
        <li>DFS</li>
        <li>BFS</li>
        <li>Binary tree</li>
        <li>Balanced search tree</li>
      </ul>
      <li><a href="#data-structure-and-algorithm-">Heap</a></li>
      <li><a href="#data-structure-and-algorithm-">Sorting</a></li>
      <li><a href="#data-structure-and-algorithm-">Backtracking</a></li>
      <li><a href="#data-structure-and-algorithm-">Trie</a></li>
      <li><a href="#data-structure-and-algorithm-">Graph</a></li>
      <ul>
        <li>DFS</li>
        <li>Topological sort</li>
        <li>BFS</li>
        <li>BFS multi</li>
        <li>Union-Find</li>
        <li>Dijkstra</li>
        <li>Bellman-Ford</li>
      </ul>
      <li><a href="#data-structure-and-algorithm-">Dynamic programming</a></li>
      <ul>
        <li>1D</li>
        <li>2D</li>
      </ul>
      <li><a href="#data-structure-and-algorithm-">Greedy</a></li>
      <li><a href="#data-structure-and-algorithm-">Interval</a></li>
      <li><a href="#data-structure-and-algorithm-">Matrix</a></li>
      <li><a href="#data-structure-and-algorithm-">Math</a></li>
      <li><a href="#data-structure-and-algorithm-">Geometry</a></li>
      <li><a href="#data-structure-and-algorithm-">Bit manipulation</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Big O</h2>
    <ul>
      <li>\( T(n) = O(f(n)) \) iff there exists \( c, n_{0} \) such that \( T(n) \le cf(n) \) for all \( n \ge n_{0} \)</li>
      <li>\( T(n) = \Omega(f(n)) \) iff there exists \( c, n_{0} \) such that \( T(n) \ge cf(n) \) for all \( n \ge n_{0} \)</li>
      <li>\( T(n) = \Theta(f(n)) \) iff \( T(n) = O(f(n)) \) and \( T(n) = \Omega(f(n)) \)</li>
    </ul>

    <h3 class="card-title">Master's method</h3>
    <ul>
      <li>\( T(n) \le aT\left(\dfrac{n}{b}\right) + O(n^{d}) \)</li>
      <ul>
        <li>\( a \) = number of recursive step</li>
        <li>\( b \) = input size factor</li>
        <li>\( d \) = running time of "combine step"</li>
      </ul>
      <li>Examples</li>
      <ul>
        <li>\( T(n) = O(n^{d}\log{n}) \) if \( a = b^{d} \)</li>
        <li>\( T(n) = O(n^{d}) \) if \( a \lt b^{d} \)</li>
        <li>\( T(n) = O(n^{\log_{b}{a}}) \) if \( a \gt b^{d} \)</li>
      </ul>
    </ul>

    <h3 class="card-title">Examples</h3>
    <ul>
      <li>Nested for-loop with dependant variables - \( O(n^2) \)</li>
<pre><code class="python">for i in range(n):
    for x in range(i):
        print(x)</code></pre>
      <li>Nested for-loop with index modification - \( O(n^2) \)</li>
<pre><code class="python">for i in range(n):
    i *= 2
    for x in range(i):
        print(x)</code></pre>
      <li>Loop statement that multiplies/divides the loop variable - \( O(\frac{log(n)}{log(k)}) \)</li>
<pre><code class="python">while i < n:
    i *= k
    print(i)</code></pre>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Divide and conquer</h2>

    <h3 class="card-title">Closest pair</h3>
    <ul>
      <li>Input</li>
      <ul>
        <li>Let \( P = \{p_{1} \dots p_{n}\} \) points in \( {\rm I\!R^{2}} \)</li>
        <li>Let \( d(p_{i}, p_{j}) \) be Eucliean distance of \( p_{i}, p_{j} \)</li>
      </ul>
      <li>Output</li>
      <ul>
        <li>\( p, q \) such that $\( d(p,q) \) is the minumum</li>
      </ul>
      <li>Naive approach</li>
      <ul>
        <li>Sort points - \( O(n\log{n}) \)</li>
        <li>Return the closest pair of adjacent points - \( O(n) \)</li>
        <li>In total - \( O(n^{2}) \)</li>
      </ul>
      <li>Divide-and-conquer</li>
      <ul>
        <li>Let \( Q \) = left half of \( P \) and \( R \) = right half of \( P \)</li>
        <li>Form \( Q_{x}, Q_{y}, R_{x}, R_{y} \)</li>
        <li>\( (p_{1}, q_{1}) \) = closest_pair \( (Q_{x}, Q_{y}) \)</li>
        <li>\( (p_{2}, q_{2}) \) = closest_pair \( (R_{x}, R_{y}) \)</li>
        <li>Let \( \delta = min\left[d(p_{1}, q_{1}), d(p_{2}, q_{2})\right] \)</li>
        <li>\( (p_{3}, q_{3}) \) = closest_split_pair \( (p_{x}, p_{y}, \delta) \)</li>
        <li>Return the best of \( (p_{1}, q_{1}), (p_{2}, q_{2}), (p_{3}, q_{3}) \)</li>
      </ul>
      <li>closest_split_pair</li>
      <ul>
        <li>Let \( \bar{x} \) = the biggest x-coordinate in left of \( P \)</li>
        <li>Let \( S_{y} \) = points of \( P \) with x-coordinates in sorted by y-coordinate</li>
        <li>Initialize best = \( \delta \), best_pair = None</li>
        <li>For \( i = 1 \) to \( |S_{y}| - 7 \)</li>
        <ul>
          <li>For \( j = 1 \) to \( 7 \)</li>
          <ul>
            <li>Let \( p \) = \( i \)th point of \( S_{y} \)</li>
            <li>Let \( q \) = \( (i+j) \)th point of \( S_{y} \)</li>
            <li>If \( d(p,q) \) < best</li>
            <ul>
              <li>best_pair = \( (p,q) \)</li>
              <li>best = \( d(p,q) \)</li>
            </ul>
          </ul>
        </ul>
      </ul>
    </ul>

    <h3 class="card-title">Correctness</h3>
    <ul>
      <li>Let \( p \in Q, q \in R \) be a split pair with \( d(p,q) \lt \delta \)</li>
      <li>(A) \( p \) and \( q \) are members of \( S_{y} \)</li>
      <li>(B) \( p \) and \( q \) are at most 7 positions apart of \( S_{y} \)</li>
      <li>Corollary - if the closest pair of \( P \) is a split pair, then the closest_split_pair finds it</li>
    </ul>

    <h4 class="card-title">Proof of (A)</h4>
    <ul>
      <li>Let \( p = (x_{1}, y_{1}) \in Q \)</li>
      <li>Let \( q = (x_{2}, y_{2}) \in R \)</li>
      <li>Let \( d(p,q) \le \delta \)</li>
      <li>Since \( (p,q) \le \delta \), \( |x_{1} - x_{2}| \le \delta \) and \( |y_{1} - y_{2}| \le \delta \)</li>
      <li>\( p \in Q \) => \( x_{1} \le \bar{x}, q \in R \) => \( x_{2} \ge \bar{x} \)</li>
      <li>Thus, \( x_{1}, x_{2} \in [\bar{x} - \delta, \bar{x} + \delta] \)</li>
    </ul>

    <h4 class="card-title">Proof of (B)</h4>
    <ul>
      <li>Consider \( \delta / 2 \) by \( \delta / 2 \) boxes with center \( \bar{x} \) and bottom \( min\{y_{1}, y_{2}\} \)</li>
      <li>Lemma 1 - all points of \( S_{y} \) with y-coordinate between those of \( p \) and \( q \) lie in one of 8 boxes</li>
      <ul>
        <li>Proof - y-coordinates of \( p,q \) differ by less than \( \delta \) and x-coordinates are between \( \bar{x} - \delta, \bar{x} + \delta \)</li>
      </ul>
      <li>Lemma 2 - at most one point of \( P \) in each box</li>
      <ul>
        <li>proof - suppose \( a,b \) lie in the same box. Then, \( a,b \) are either both in \( Q \) or both in \( R \). Then, \( d(a,b) \le \dfrac{\delta}{2}\sqrt{2} \le \delta \). But, this contradicts the definition of \( \delta \)</li>
      </ul>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">String</h2>

    <h3 class="card-title">String to list</h3>

<pre><code class="python"># Split string into list of characters
chars = list(string)  # O(n)

# Join list of characters into string
string = "".join(chars)  # O(n) n = length of chars array</code></pre>

    <h3 class="card-title">String to integer</h3>

<pre><code class="python"># Find integer representation of character
index = ord(c) - ord("a")  # O(1)

# Convert integer representation to character
char = chr(index)  # O(1)</code></pre>

<pre><code class="python"># Remove leading and trailing whitespaces
string = string.strip()  # O(n) n = length of string

# Check if string is a digit
string.isdigit()  # O(n) n = length of string

# Check if string starts with value
string.startswith(val)  # O(n) n = length of val</code></pre>    
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Hash table</h2>
    <ul>
      <li>There is always an underlying array</li>
      <li>Hash function maps keys to indexes of an array</li>
      <li>Large number of keys are mapped to small number of indexes, which could cause collision</li>
      <li>Each element of array holds a linked list to handle collision</li>
    </ul>

    <h3 class="card-title">High level idea</h3>
    <ul>
      <li>Setup - universe \( U \)</li>
      <li>Goal - want to maintain evolving set \( S \subseteq U \)</li>
      <li>Pick \( n \) = number of "buckets"</li>
      <li>Choose a hash function \( h: U \rightarrow \{0,1,2 \dots n-1\} \)</li>
      <li>Use array \( A \) of length \( n \), store \( x \) in \( A[h(x)] \)</li>
    </ul>

    <h3 class="card-title">Resolving collisions</h3>
    <ul>
      <li>Collision - distinct \( x,y \in U \) such that \( h(x) = h(y) \)</li>
      <li>Solution #1 - (separate) chaining</li>
      <ul>
        <li>Keep linked list in each bucket</li>
        <li>Given a key/object \( x \), perform insert/delete/lookup in the list in \( A[h(x)] \)</li>
        <ul>
          <li>\( A \) = linked list for \( x \)</li>
          <li>\( h(x) \) = bucket for \( x \)</li>
        </ul>
      </ul>
      <li>Solution #2 - open addressing (only one object per bucket)</li>
      <ul>
        <li>Hash function now specifies probe sequence \( h_{1}(x), h_{2}(x) \dots \) (keep trying till finding an open slot)</li>
        <li>Ex. linear probing (look consecutively), double hashing</li>
      </ul>
    </ul>

    <h3 class="card-title">Good hash function</h3>
    <ul>
      <li>Spread data out</li>
      <li>Easy to store</li>
      <li>Fast to evaluate</li>
    </ul>

    <h3 class="card-title">Universal hash function</h3>
    <ul>
      <li>The load of a hash table \( \alpha \) = (number of objects in hash table) / (number of buckets of hash table)</li>
      <ul>
        <li>\( \alpha = O(1) \) is necessary condition for operations to run in constant time</li>
        <li>With open addressing, need \( \alpha << 1 \)</li>
      </ul>
      <li>Good hash table performance</li>
      <ul>
        <li>Need to control load</li>
        <li>Need a good hash function</li>
      </ul>
      <li>Ideally we want hash function that guarantees to spread every data set out evenly, however for every hash function, there is a pathological data set</li>
      <ul>
        <li>Use a cryptographic hash function (Ex. SHA-2)</li>
        <ul>
          <li>Infeasible to reverse engineer a pathological data set</li>
        </ul>
      </ul>
      <ul>
        <li>Use randomization</li>
        <ul>
          <li>Design a family \( H \) of hash functions such that for all data sets \( S \), "almost all" functions \( h \in H \) spread \( S \) out "pretty evenly"</li>
        </ul>
      </ul>
      <li>Definition</li>
      <ul>
        <li>Let \( H \) be a set of hash functions from \( U \) to \( \{0,1,2 \dots n-1\} \)</li>
        <li>\( H \) is universal iff for all \( x,y \) in \( U \) (with \( x != y \))</li>
        <li>\( \text{Prob}_{h \in H}[h(x) = h(y)] \le \dfrac{1}{n} \)</li>
        <ul>
          <li>\( n \) = number of buckets</li>
          <li>\( h \) is chosen uniformly at random from \( H \)</li>
        </ul>
      </ul>
    </ul>

    <h3 class="card-title">Hashing IP addresses</h3>
    <ul>
      <li>Let \( U \) = IP addresses of the form \( (x_{1}, x_{2}, x_{3}, x_{4}) \) with each \( x_{i} \in \{0,1,2 \dots 255\} \)</li>
      <li>Let \( n \) = a prime (Ex. small multiple of number of objects in hash table)</li>
      <li>Define one hash function \( h_{a} \) per 4-tuple \( a = (a_{1}, a_{2}, a_{3}, a_{4}) \) with each \( a_{i} \in \{0,1,2 \dots n-1\} \)</li>
      <li>\( h_{a} \) - IP addresses -> buckets by</li>
      <ul>
        <li>\( h_{a}(x_{1}, x_{2}, x_{3}, x_{4}) = (a_{1}x_{1} + a_{2}x_{2} + a_{3}x_{3} + a_{4}x_{4}) \) mod \( n \)</li>
        <li>\( H = \{h_{a} | a_{1}, a_{2}, a_{3}, a_{4} \in \{0,1,2 \dots n-1\} \} \)</li>
      </ul>
      <li>Claim - this family is universal</li>
      <li>Proof</li>
      <ul>
        <li>Consider distinct IP addresses \( (x_{1}, x_{2}, x_{3}, x_{4}), (y_{1}, y_{2}, y_{3}, y_{4}) \)</li>
        <li>Assume \( x_{4} != y_{4} \)</li>
        <li>Collision <=> \( a_{1}x_{1} + a_{2} + x_{2} + a_{3} + x_{3} + a_{4}x_{4} = a_{1}y_{1} + a_{2} + y_{2} + a_{3} + y_{3} + a_{4} + y_{4} \) <=> \( a_{4}(x_{4} - y_{4}) = \displaystyle\sum_{i=1}^{3}a_{i}(y_{i} - x_{i}) \) mod \( n \)</li>
        <li>With \( a_{1}, a_{2}, a_{3} \) fixed arbitrarily, how many choices of \( a_{4} \) satisfy</li>
        <ul>
          <li>\( a_{4}(x_{4} - y_{4}) = \displaystyle\sum_{i=1}^{3}a_{i}(y_{i} - x_{i}) \) mod \( n \)</li>
        </ul>
        <li>Notice that LHS is equally likely to be any of \( \{0,1,2 \dots n-1\} \) (\(x_{4} != y_{4}\), \( n \) is prime, \( a_{4} \) uniform at random)</li>
      </ul>
    </ul>

    <h3 class="card-title">Chaining (constant-time guarantee)</h3>
    <ul>
      <li>Scenario - hash table implemented with chaining. Hash function \( h \) chosen uniformly at random from universal family \( H \)</li>
      <li>Theorem - all operations run in \( O(1) \) for every data set \( S \)</li>
      <li>Caveats</li>
      <ul>
        <li>In expectation over the random choice of the hash function \( h \)</li>
        <li>Assumes \( |S| = O(n) \) (Ex. load \( \alpha = \dfrac{|S|}{n} = O(1) \))</li>
        <li>Assumes \( O(1) \) to evaluate hash function</li>
      </ul>
      <li>Proof - only analyze an unsuccessful lookup because other operations are faster</li>
      <ul>
        <li>Let \( S \) = data set with \( |S| = O(n) \)</li>
        <li>Consider lookup for \( X \notin S \)</li>
        <li>Runtime - \( O(1) + O \) (list length in \( A[h(x)]) \) (compute \( h(x) \) + traverse list)</li>
        <li>Let \( L \) = list length in \( A[h(x)] \)</li>
        <li>For \( y \in S \) (so \( y != x \)) define \( z_{y} = 1 \) if \( h(y) = h(x) \), \( 0 \) otherwise</li>
        <li>Note \( L = \displaystyle\sum_{y \in S}A_{y} \)</li>
        <li>So \( E[L] = \displaystyle\sum_{y \in S}E[z_{y}] \)</li>
        <li>\( E[z_{y}] = 0 * \text{Prob}[z_{y} = 0] + 1 * \text{Prob}[z_{y} = 1] = \text{Prob}[h(y) = h(x)] \)</li>
        <li>\( E[L] = \displaystyle\sum_{y \in S}E[z_{y}] = \displaystyle\sum_{y \in S}\text{Prob}[h(y) = h(x)] \le \displaystyle\sum_{y \in S}\dfrac{1}{n} \) (because \( H \) is universal and by definition of universal hash function) = \(\dfrac{|S|}{n} = \alpha = O(1) \)</li>
      </ul>
    </ul>

    <h3 class="card-title">Open addressing</h3>
    <ul>
      <li>One object per slot, hash function produces a probe sequence for each possible key \( x \)</li>
      <li>Difficult to analyze rigorousely</li>
      <li>Heuristic assumption - all \( n! \) probe sequences equally</li>
      <li>Claim - under heuristic assumption, expected insertion time is \( \dfrac{1}{1-\alpha} \), where \( \alpha \) = load</li>
      <li>Proof</li>
      <ul>
        <li>A random probe finds an empty slot with probability \( 1-\alpha \)</li>
        <li>Thus, insertion time is approximately equals to the number \( N \) of coin flips to get "heads", where \( \text{Prob}[\text{heads}] = 1-\alpha \)</li>
        <li>Note \( E[N] \) = (1st coin flip) + (probability of tails)(expected number of further coin flip needed) = \( 1 + \alpha E[N] \)</li>
        <li>Thus \( E[N] = \dfrac{1}{1-\alpha} \)</li>
      </ul>
    </ul>

    <h3 class="card-title">Linear probing</h3>
    <ul>
      <li>Heuristic assumption is completely false</li>
      <li>Assume instead - initial probes uniform at random independent for different keys</li>
      <li>Theorem - expected insertion time = \( \dfrac{1}{(1-\alpha)^{2}} \)</li>
    </ul>

    <h3 class="card-title">Bloom filters</h3>
    <ul>
      <li>Fast insert and lookup</li>
      <li>Compare to hash table</li>
      <ul>d
        <li>More space efficient (pro)</li>
        <li>Can't store an associated object (con)</li>
        <li>No delete (con)</li>
        <li>Small false positive probability (con)</li>
        <ul>
          <li>Might say \( x \) has been inserted although it hasn't</li>
        </ul>
      </ul>
      <li>No false negative (if \( x \) was inserted, lookup(x) guaranteed to succeed)</li>
      <li>False positive if all \( k, h_{i}(x) \)'s are already set to \( 1 \) by other insertions</li>
      <li>Applications</li>
      <ul>
        <li>Early spellcheckers</li>
        <li>List of forbidden passwords</li>
        <li>Network routers (limited memory, so need to be super fast)</li>
      </ul>
      <li>Ingredients</li>
      <ul>
        <li>Array of \( n \) bits (\( \dfrac{n}{|S|} \) = number of bits per object in data set \( S \))</li>
        <li>\( k \) hash functions \( h_{1} \dots h_{k} \), where \( k \) is a small constant</li>
      </ul>
      <li>Insert(x)</li>
      <ul>
        <li>For \( i = 1,2 \dots k \) (whether or not bit already set to \( 1 \))</li>
        <ul>
          <li>Set \( A[h_{i}(x)] = 1 \)</li>
        </ul>
      </ul>
      <li>Lookup(x)</li>
      <ul>
        <li>Return True <=> \( A[h_{i}(x)] = 1 \) for every \( i = 1,2 \dots k \)</li>
      </ul>
    </ul>

    <h3 class="card-title">Heuristic analysis</h3>
    <ul>
      <li>Intuition - should be a trade-off between space and error (false positive) probability</li>
      <li>Assume - all \( h_{i}(x) \)'s uniformly random and independent (across different \( i \)'s and \( x \)'s)</li>
      <li>Setup - \( n \) bits, insert data set \( S \) into bloom filter</li>
      <li>Note - for each bit of \( A \), the probability it's been set to \( 1 \) is</li>
      <ul>
        <li>\( 1-(1-\dfrac{1}{n})^{k|S|} \le 1 - e^{-k|S|/n} = 1 - e^{-k/b} \), \( b \) = number of bits per object \( \dfrac{n}{|S|} \)</li>
      </ul>
      <li>Thus, false positive probability is \( \le [1-e^{-k/b}]^{k} = \epsilon \)</li>
      <li>For fixed \( b, \epsilon \) is minimized by setting</li>
      <ul>
        <li>\( \epsilon \approx \dfrac{1}{2}^{(ln2)b} \)</li>
      </ul>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Graph</h2>
    
    <h3 class="card-title">Find mother vertex</h3>
    <ul>
      <li>Every node can be reached from the mother vertex</li>
      <li>Compute all connected groups in the graph</li>
      <li>The last visited node is the mother node</li>
    </ul>
<pre><code class="python">def find_mother_vertex(graph, num_nodes):

    explored = set()
    last_vertex = 0

    for i in range(num_nodes):
        if i not in explored:
            dfs(i, graph, explored)
            last_vertex = i</code></pre>

    <h3 class="card-title">Strongly connected components</h3>
    <ul>
      <li>There exist path u to v and v to u in graph G</li>
      <li>Kosaraju's two pass algorithm</li>
      <ul>
        <li>Compute SCC in \( O(m+n) \)</li>
        <li>Let G' = G with all arcs reversed</li>
        <li>Run DFS_loop on G' (compute magical ordering of nodes)</li>
        <li>Run DFS_loop on G (compute strongly connected component one by one)</li>
      </ul>
    </ul>

    <h3 class="card-title">Dijkstra</h3>
    <ul>
      <li>Find the shortest path from starting node to each node in "positive" weighted graph</li>
      <li>Add the starting node to the "visited" set</li>
      <li>Initialize the distance to each node to infinity except the starting node whose distance should be zero</li>
      <li>For all edges in the graph, consider edges (parent_node, child_node) where parent_node is visited and child_node is unvisited. Pick the edge where the distance to parent + the distance between parent and child is the minimum</li>
      <li>Add the child to "visited" set</li>
      <li>Update the distance to child such that dist[child] = dist[parent] + distance between parent and child</li>
      <li>Continue until all nodes in the graph are explored</li>
    </ul>

<pre><code class="python">def dijkstra(start_node, graph, n):

    explored = set()
    explored.add(start_node)

    # Distance from start_node to itself is 0
    # Otherwise, initialize distance to infinity
    distance = {}
    for i in range(1,n+1):
        if i == start_node:
            distance[i] = 0
        else:
            distance[i] = math.inf

    node = start_node

    while True:

        # If there is no more node to explore in the graph
        if len(explored) == n:
            return distance

        # Amongst all edges where one node exists in explored and the other
        # does not exist in explored, we will visit the node with smallest distance
        min_distance = math.inf
        next_node_to_visit = -1
        for node in explored:
            for item in graph[node]:
                child_node = item[0]
                dist = item[1]

                if distance[node] + dist < min_distance \
                    and child_node not in explored:
                    min_distance = distance[node] + dist
                    next_node_to_visit = child_node

        # If there is no unexplored node amongst all "directed" edges in graph
        if next_node_to_visit == -1:
            return distance

        # Mark the node as visited
        explored.add(next_node_to_visit)

        # Update the distance
        distance[next_node_to_visit] = min_distance

        # Visit the next node
        node = next_node_to_visit

    return distance</code></pre>

    <h3 class="card-title">Bellman-Ford</h3>
    <ul>
      <li>Consider all possible number of stops possible in the graph (It should be n-1)</li>
      <li>Consider all directed edges in graph</li>
      <li>Use dynamic programming to compute the minimum distance from the starting_node to every other node for each number of stops</li>
      <li>Update the minimum distance as dist[child][k] = min(dist[child][k], dist[parent][k-1] + distance between parent and child)</li>
    </ul>

<pre><code class="python">def bellman_ford(start_node, graph, n):

    # Initiallize 2D array
    # (number of nodes in graph, number of stops possible in graph)
    distance = {}
    for i in range(n):
        distance[i] = {}
        for j in range(n):
            distance[i][j] = math.inf

    # Distance from start_node in zero stops is 0
    distance[start_node][0] = 0

    # Consider all possible number of stops j
    # Time O(nm)
    # Space O(nm)
    for j in range(n-1):
        for item in graph:
            parent = item[0]
            child = item[1]
            dist = item[2]
            distance[child][j+1] = min(distance[child][j+1], distance[parent][j] + dist)

    return distance</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Tree</h2>

    <h3 class="card-title">Balanced search tree</h3>
    <ul>
      <li>Sorted array with fast insert & delete</li>
      <li>Search - \( O(\log{n}) \)</li>
      <li>Insert/Delete - \( O(\log{n}) \)</li>
      <li>Select - \( O(\log{n}) \)</li>
      <li>Min/Max - \( O(\log{n}) \)</li>
      <li>Pred/Succ - \( O(\log{n}) \)</li>
      <li>Rank - \( O(\log{n}) \)</li>
      <li>Output in sorted order - \( O(n) \)</li>
    </ul>

    <h3 class="card-title">Red-Black tree</h3>
    <ul>
      <li>Each node red or black</li>
      <li>Root is black</li>
      <li>No 2 reds in a row (red node => only black children)</li>
      <li>Every root-NULL path (unsuccessful search) has the same number of black nodes</li>
      <li>Height guarantee</li>
      <ul>
        <li>Every red-black tree with n nodes has height less than or equal to \( 2\text{log}_{2}(n+1) \)</li>
      </ul>
      <li>Rotation</li>
      <ul>
        <li>Locally rebalance subtrees at a node in \( O(1) \) time</li>
        <li>Left rotation</li>
        <li>Right rotation</li>
      </ul>
      <li>Insert</li>
      <ul>
        <li>Insert x as usual (makes x a leaf)</li>
        <li>Try coloring x red</li>
        <li>If x's parent y is black, done</li>
        <li>Else y is red, then y has a black parent w</li>
      </ul>
    </ul>

    <h3 class="card-title">Binary tree</h3>
    <ul>
      <li>Exactly one node per key</li>
      <li>Each node has</li>
      <ul>
        <li>Left child pointer</li>
        <li>Right child pointer</li>
        <li>Parent</li>
      </ul>
      <li>All nodes left on node X are less than X</li>
      <li>All nodes right on node X are greater than X</li>
      <li>Many possible trees for a set of keys</li>
      <li>Height could be anywhere from \( \text{log}_{2}^{n} \) to \( n \)</li>
      <li>Generally operations are \( O(\text{height}) \)</li>
    </ul>

    <h3 class="card-title">Binary search tree</h3>
    <ul>
      <li>Binary tree where each node of the tree has key-value pairs</li>
    </ul>

<pre><code class="python">class Node(object):
    def __init__(self, val=0, left=None, right=None, parent=None):
        self.val = val
        self.left = left
        self.right = right
        self.parent = parent</code></pre>

    <h4 class="card-title">Search</h4>

<pre><code class="python">def search(self, val):
    current = self

    while current is not None:

        if val < current.val:
            current = current.left
        elif val > current.val:
            current = current.right
        else:
            return True

    return False</code></pre>

    <h4 class="card-title">Insert</h4>

<pre><code class="python">def insert(self, val):
    current = self
    parent = None

    while current:
        parent = current
        if val < current.val:
            current = current.left
        else:
            current = current.right

    if val < parent.val:
        parent.left = Node(val)
    else:
        parent.right = Node(val)</code></pre>

    <h4 class="card-title">Delete</h4>

<pre><code class="python">def delete(self, val):

    if val < self.val:
        if self.left:
            self.left = self.left.delete(val)
        else:
            print(str(val) + " not found in the tree")
            return self
    elif val > self.val:
        if self.right:
            self.right = self.right.delete(val)
        else:
            print(str(val) + " not found in the tree")
            return self
    else:
        # Delete node with no children
        if self.left is None and self.right is None:
            self = None
            return None

        # Delete node with right child
        elif self.left is None:
            tmp = self.right
            self = None
            return tmp

        # Delete node with left child
        elif self.right is None:
            tmp = self.left
            self = None
            return tmp

        # Delete node with two children
        else:
            current = self.right

            # Find the leftmost leaf.
            while current.left is not None:
                current = current.left
            self.val = current.val
            self.right = self.right.delete(current.val)

    return self</code></pre>

    <h3 class="card-title">AVL tree</h3>
    <ul>
      <li>Balanced binary search tree</li>
    </ul>

    <h4 class="card-title">Red-black tree</h4>
    <ul>
      <li>AVL tree where</li>
      <ul>
        <li>Root is always black</li>
        <li>Two red nodes cannot be adjacent</li>
      </ul>
    </ul>

<pre><code class="python">class Node:
    def __init__(self,val):
        self.val = val
        self.left = None
        self.right = None
        is_red = None</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Dynamic programming</h2>
    <ul>
      <li>Identify a small number of sub-problems</li>
      <li>Can quickly + correctly solve "larger" sub-problems given the solutions to "smaller sub-problems"</li>
      <li>Solving all sub-problems computes final solution</li>
    </ul>

    <h3 class="card-title">Weighted independent sets</h3>
    <ul>
      <li>Input - a path graph \( G = (V,E) \) with non-negative weights on vertices</li>
      <li>Desired output - subset of nonadjacent vertices (an independent set of maximum total weight)</li>
      <li>Brute force - exponential time</li>
      <li>Optimal structure</li>
      <ul>
        <li>Reason about structure of an optimal solution</li>
        <li>Let \( S \le V \) be a max-weight independent set (IS)</li>
        <li>Let \( v_{n} \) = last vertex of path</li>
      </ul>
      <li>A case analysis</li>
      <ul>
        <li>Case #1 - suppose \( v_{n} \in S \). let \( G^{'} = G \) with \( v_{n} \) deleted</li>
        <ul>
          <li>Note - \( S \) also an IS of \( G^{'} \)</li>
          <li>Note - \( S \) must be a max-weight IS of \( G^{'} \) - if \( S^{*} \) was better, it would also be better than \( S \) in \( G \) (contradiction)</li>
        </ul>
        <li>Case #2 - suppose \( v_{n} \in S \)</li>
        <ul>
          <li>Note - previous vertex \( v_{n-1} \notin S \) (by definition of IS). Let \( G^{''} = G \) with \( v_{n-1}, v_{n} \) deleted</li>
          <li>Note - \( S-\{v_{n}\} \) is an IS of \( G^{''} \)</li>
          <li>Note - must in fact be a max-weight IS of \( G^{''} \) - if \( S{*} \) is better than \( S \) in \( G^{''} \), then \( S^{*}\cup\{v_{n}\} \) is better than \( S \) in \( G \) (contradiction)</li>
        </ul>
      </ul>
      <li>Optimal solution</li>
      <ul>
        <li>Reformulate as a bottom-up iterative algorithm. Let \( G_{i} \) = 1st vertices of \( G \)</li>
        <li>Populate array \( A \) left to right with \( A[i] \) = value of max-weight IS of \( G_{i} \)</li>
        <li>Initialize \( A[0] = 0, A[1] = w_{1} \)</li>
        <li>For \( i = 2,3 \dots n \)</li>
        <ul>
          <li>\( A[i] = max{A[i-1], A[i-2]+w_{i}} \)</li>
        </ul>
        <li>Runs in \( O(n) \)</li>
        <li>Trace back through filled-in array to reconstruct optimal solution</li>
        <li>Key point - we know that a vertex \( v_{i} \) belongs to a max-weight IS of \( G_{i} \) <=> \( w_{i} \) + max-weight IS of \( G_{i-2} \ge \) max-weight IS of \( G_{i-1} \)</li>
      </ul>
      <li>A reconstruction algorithm - trace back through filled-in array to reconstruct optimal solution</li>
      <ul>
        <li>Let \( A \) = filled-in array</li>
        <li>Let \( S \) = empty set</li>
        <li>While \( i \ge 1 \)</li>
        <ul>
          <li>If \( A[i-1] \ge A[i-2] + w_{i} \) (case 1 wins)</li>
          <ul>
            <li>Decrease i by 1</li>
          </ul>
          <li>Else (case 2 wins)</li>
          <ul>
            <li>Add \( v_{i} \) to \( S \)</li>
            <li>Decrease \( i \) by 2</li>
          </ul>
        </ul>
        <li>Return \( S \)</li>
      </ul>
    </ul>

    <h3 class="card-title">Knapsack problem</h3>
    <ul>
      <li>Input - \( n \) items</li>
      <ul>
        <li>Value \( v_{i} \) (non-negative)</li>
        <li>Size \( w_{i} \) (non-negative and integral)</li>
        <li>Capacity \( W \) (non-negative integer)</li>
      </ul>
      <li>Output - subset \( S \in \{1 \dots n\} \) that maximizes \( \displaystyle\sum_{i}v_{i} \) subject to \( \displaystyle\sum_{i}w_{i} \le W \)</li>
      <li>Step #1</li>
      <ul>
        <li>Let \( S \) = a max-value solution</li>
        <li>Suppose item \( n \notin S \). \( S \) must be optimal with first \( n-1 \) items with capacity \( W \)</li>
        <ul>
          <li>If \( S^{*} \) were better than \( S \) with respect to 1st \( n-1 \) items, then this equally true with respect to all \( n \) items -> contradiction</li>
        </ul>
        <li>Suppose item \( n \in S \). \( S-\{n\} \) must be optimal with first \( n-1 \) items with capacity \( W-w_{n} \)</li>
        <ul>
          <li>If \( S^{*} \) has higher value than \( S-\{n\} \) + totla size \( \le W-w_{n} \), then \( S\cup\{n\} \) has size \( \le W \) and value more than \( S \) -> contradiction</li>
        </ul>
      </ul>
      <li>Step #2</li>
      <ul>
        <li>Let \( v_{i,x} \) = value of the best solution that</li>
        <ul>
          <li>Uses only the first \( i \) items</li>
          <li>Has total size \( \le x \)</li>
        </ul>
        <li>For i = 1 to n and any x</li>
        <ul>
          <li>\( v_{i,x} = \text{max}\{v_{i-1,x}\} \) (case when item \( i \) in excluded), \( v_{i} + v_{i-1,x-w_{i}} \) (case when item \( i \) in included)}</li>
        </ul>
        <li>If \( w_{i} > x \), then \( v_{i,x} = v_{i-1,x} \)</li>
      </ul>
      <li>Step #3</li>
      <ul>
        <li>Let \( A \) = 2D array</li>
        <li>Init \( A[0,x] = 0 \) for \( x = 0 \dots W \)</li>
        <li>For \( i = 1 \dots n \)</li>
        <ul>
          <li>For \( x = 0 \dots W \)</li>
          <ul>
            <li>\( A[i,x] = \text{max}\{A[i-1, x], A[i-1, x-w_{i}] + v_{i}\} \) (ignore second term if \( w_{i} \gt x \))</li>
          </ul>
        </ul>
        <li>Return \( A[n,W] \)</li>
        <li>Runs in \( \theta(nW) \)</li>
      </ul>
    </ul>

    <h3 class="card-title">Sequence alignment</h3>
    <ul>
      <li>Input - strings \( X = x_{1} \dots x_{m}, Y = y_{1} \dots y_{m} \) over some alphabet (like \( \{A,C,G,T\} \))</li>
      <ul>
        <li>Penalty \( \alpha_{gap} \ge 0 \) for inserting a gap, \( \alpha_{ab} \) for matching \( a \) and \( b \)</li>
      </ul>
      <li>Alignment - insert gaps to equalize length of string</li>
      <li>Goal - alignment with minimum possible total penalty</li>
      <li>Final position of string can be one of</li>
      <ul>
        <li>Case1 - \( x_{m} \) and \( y_{n} \) matched</li>
        <li>Case2 - \( x_{m} \) is matched with a gap</li>
        <li>Case3 - \( y_{n} \) is matched with a gap</li>
      </ul>
      <li>Let \( X^{'} = X - x_{m} \) and \( Y^{'} = Y - y_{m} \)</li>
      <ul>
        <li>Case1 - alignment of \( X^{'} \) and \( Y^{'} \) is optimal</li>
        <li>Case2 - alignment of \( X^{'} \) and \( Y \) is optimal</li>
        <li>Case3 - alignment of \( X \) and \( Y^{'} \) is optimal</li>
      </ul>
      <li>Subproblem \( (X_{i}m Y_{j}) \)</li>
      <ul>
        <li>\( X_{i} \) = 1st \( i \) letters of \( X \)</li>
        <li>\( Y_{j} \) = 1st \( j \) letters of \( Y \)</li>
      </ul>
      <li>Recurrence</li>
      <ul>
        <li>Let \( P_{ij} \) = penalty of optimal alignment of \( X_{i} \) and \( Y_{j} \)</li>
        <li>For all i = 1 to n and j = 1 to n, \( P_{ij} \) is the <strong>minimun</strong> of the following three cases</li>
        <li>Case1 - \( \alpha_{x_{i}y_{j}} + P_{i-1,j-1} \)</li>
        <li>Case2 - \( \alpha_{gap} + P_{i-1,j} \)</li>
        <li>Case3 - \( \alpha_{gap} + P_{i,j-1} \)</li>
      </ul>
      <li>Algorithm</li>
      <ul>
        <li>Let \( A \) = 2D array</li>
        <li>\( A[i,0] = A[0,j] = i * \alpha_{gap} \forall i \ge 0 \)</li>
        <li>For \( i = 1 \dots m \)</li>
        <ul>
          <li>For \( j = 1 \dots n \)</li>
          <ul>
            <li>\( A[i,j] = min\{A[i-1,j-1]+\alpha_{x_{i}y_{j}}, A[i-1,j]+\alpha_{gap}, A[i,j-1]+\alpha_{gap}\} \)</li>
          </ul>
        </ul>
        <li>Runs in \( O(mn) \)</li>
      </ul>
      <li>Reconstructing a solution</li>
      <ul>
        <li>Trace back through filled-in table \( A_{i} \) starting at \( A[m,n] \)</li>
        <li>When reaching subproblem \( A[i,j] \)</li>
        <ul>
          <li>If \( A[i,j] \) filled using case1, match \( x_{i} \) and \( y_{j} \), and go to \( A[i-1, j-1] \)</li>
          <li>If \( A[i,j] \) filled using case2, match \( x_{i} \) and a gap, and go to \( A[i-1, j] \)</li>
          <li>If \( A[i,j] \) filled using case3, match \( y_{j} \) and a gap, and go to \( A[i, j-1] \)</li>
        </ul>
        <li>If \( i=0 \) or \( j=0 \), match remaining substring with gaps</li>
        <li>Runs in \( O(m+n) \)</li>
      </ul>
    </ul>

    <h3 class="card-title">Optimal binary search tree</h3>
    <ul>
      <li>What is the best search tree for a given set of keys?</li>
      <li>Input - frequencies \( p_{1} \dots p_{n} \) for items \( 1 \dots n \) (assume items in sorted order \( 1 \lt \dots \lt n \))</li>
      <li>Goal - compute a valid search tree that minimizes weighted search time</li>
      <ul>
        <li>\( C(T) = \displaystyle\sum_{i}P_{i}* \) [search time for \( i \) in \( T \)]</li>
        <li>Ex. if \( T \) is a red-black tree, then \( C(T) = O(logn) \) (assuming \( \displaystyle\sum_{i}P_{i} = 1 \))</li>
      </ul>
      <li>Optimal structure</li>
      <ul>
        <li>Suppose an optimal BST for keys \( \{1,2 \dots n\} \) has root \( r \), left subtree \( T_{1} \), right subtree \( T_{2} \)</li>
        <li>Then, subtrees \( T_{1} \) and \( T_{2} \) are optimal BSTs for the keys \( \{1 \dots r-1\} \) and \( \{r+1 \dots n\} \)</li>
        <li>Proof</li>
        <ul>
          <li>Let \( T \) be an optimal BST for keys \( \{1 \dots n\} \) with frequencies \( p_{1} \dots p_{n} \)</li>
          <li>Suppose \( T \) has root \( r \)</li>
          <li>Suppose for contradiction that \( T_{1} \) is not optimal for \( \{1,2 \dots r-1\} \) (other case is similar) with \( C(T^{*}_{1}) \lt C(T_{1}) \)</li>
          <li>Obtain \( T^{*} \) from \( T \) by "cutting + pasting" \( T^{*}_{1} \) in for \( T_{1} \)</li>
          <li>Need to show \( C(T^{*}) \lt C(T) \)</li>
          <li>\( C(T) = \displaystyle\sum_{i=1}^{n}p_{i} [\text{search time for } i \text{ in } T] = p_{r} + \displaystyle\sum_{i=1}^{r-1}p_{i} [\text{search time for } i \text{ in } T] + \displaystyle\sum_{i=r+1}^{n}p_{i} [\text{search time for } i \text{ in } T] = \displaystyle\sum_{i=1}^{n}p_{i} + \displaystyle\sum_{i=1}^{r-1}p_{i} [\text{search time for } i \text{ in } T_{1}] + \displaystyle\sum_{i=r+1}^{n}p_{i} [\text{search time for } i \text{ in } T_{2}] \) = a constant (independent of \( T \)) + \( C(T_{1}) + C(T_{2}) \)</li>
          <li>\( C(T^{*}_{1}) \lt C(T_{1}) \) implies \( C(T^{*}) \lt C(T) \), contradicting optimality of \( T \)</li>
        </ul>
      </ul>
      <li>Relevant subproblems</li>
      <ul>
        <li>Key \( \{1 \dots n\} \) = original items. For which subsets \( S \in \{1 \dots n\} \) might we need to compute the optimal BST for \( S \)?</li>
        <ul>
          <li>Continuous interval (\(S = \{i, i+1 \dots j-1, j\}\)) for every \( i \le j \)</li>
        </ul>
      </ul>
      <li>Recurrence</li>
      <ul>
        <li>For \( 1 \ge i \ge j \ge n \), let \( C_{ij} \) = weighted search cost of optimal BST for items \( \{i, i+1 \dots j-1, j\} \) with properties \( \{p_{i}, p_{i+1} \dots p_{j}\} \)</li>
        <li>For every \( 1 \ge i \ge j \ge n \)</li>
        <ul>
          <li>\( C_{ij} = \underset{r=i}{\text{min}}\left[\displaystyle\sum_{k=1}^{j}P_{k}+C_{i,r-1}+C_{r+1,j}\right] \) where \( C_{i,r-1}, C_{r+1,j} = 0 \text{if} x>y \)</li>
        </ul>
        <li>Correctness - optimal substructure narrows candidates down to \( (j-i+1) \) possibilities, recurrence picks the best by brute force</li>
      </ul>
      <li>Algorithm</li>
      <ul>
        <li>Let \( A \) = 2D array</li>
        <li>For \( s = 0 \dots n-1 \) (\( s \) represent \( j-i \))</li>
        <ul>
          <li>for \( i = 1 \dots n \) (so \( i+s \) plays role of \( j \))</li>
          <ul>
            <li>\( A[i, i+s] \) = \( \underset{r=i}{\text{min}}\left[\displaystyle\sum_{k=i}^{i+s}P_{k}+A[i,r-1]+A[r+1,i+s]\right] \) where \( A[i,r-1]+A[r+1,i+s] = 0 \) if first index \( \ge \) second index</li>
          </ul>
        </ul>
        <li>Return \( A[1,n] \)</li>
        <li>Runs in \( \theta({n^{3}}) \) - (\( \theta({n^{2}}) \) subproblems, \( \theta(j-i) \) time to compute \( A[i,j] \))</li>
      </ul>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Sort</h2>

    <h3 class="card-title">Mergesort</h3>
    <ul>
      <li>There are approximately \( log_{2}n \) levels in the recursion tree</li>
      <li>At each level \( j \), there are \( 2^{j} \) sub-problems whose size is \( \dfrac{n}{2^{j}} \)</li>
      <li>Work per level is \( (2^{j})(\dfrac{n}{2^{j}}) = n \)</li>
      <li>Thus, total work is approximately \( (n)(\log{n}) \)</li>
    </ul>

<pre><code class="python">recursively sort 1st half of array
recursively sort 2nd half of array
C = output[length=n]
A = 1st sorted array[n/2]
B = 2st sorted array[n/2]
i = 1
j = 1

for k=1 to n
    if A(i) < B(j)
        C(k) = A(i)
        i++
    else B(j) < A(i)
        C(k)
        j++</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>
<!-- Data structure and algorithm END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>