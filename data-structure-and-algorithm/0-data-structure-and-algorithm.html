<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax/tex-chtml.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- Data Structure and Algorithm  BEGIN -->
<div class="card mb-4" id="data-structure-and-algorithm">
  <div class="card-body">
    <h2 class="card-title">Data Structure and Algorithm</h2>
    <!-- <ul class="list-unstyled mb-0"> -->
    <ul>
      <li>Structure</li>
      <ul>
        <li>Read question and create test/edge case - 5 minutes</li>
        <li>Design brute/optimal force solution and its runtime - 5 minutes</li>
        <li>Implement optimal solution - 5 minutes</li>
      </ul>
      <li>Blind 75, Neet 150 <b>(in-scope)</b></li>
      <ul>
        <li><a href="/data-structure-and-algorithm/1-array.html">Array</a></li>
        <li><a href="/data-structure-and-algorithm/1-array-prefix-sum.html">Array Prefix Sum</a></li>
        <li><a href="/data-structure-and-algorithm/1-string.html">String</a></li>
        <li><a href="/data-structure-and-algorithm/1-two-pointers.html">Two Pointers</a></li>
        <li><a href="/data-structure-and-algorithm/1-sliding-window.html">Sliding Window</a></li>
        <li><a href="/data-structure-and-algorithm/1-stack.html">Stack</a></li>
        <li><a href="/data-structure-and-algorithm/1-monotonic-stack.html">Monotonic Stack</a></li>
        <li><a href="/data-structure-and-algorithm/1-binary-search.html">Binary Search</a></li>
        <li><a href="/data-structure-and-algorithm/1-linked-list.html">Linked List</a></li>
        <li><a href="/data-structure-and-algorithm/1-linked-list-data-structure.html">Linked List Data Structure</a></li>
        <li><a href="/data-structure-and-algorithm/2-tree-dfs.html">Tree DFS</a></li>
        <li><a href="/data-structure-and-algorithm/2-tree-bfs.html">Tree BFS</a></li>
        <li><a href="/data-structure-and-algorithm/2-heap.html">Heap</a></li>
        <li><a href="/data-structure-and-algorithm/2-backtracking.html">Backtracking</a></li>
        <li><a href="/data-structure-and-algorithm/2-trie.html">Trie</a></li>
        <li><a href="/data-structure-and-algorithm/2-graph-dfs.html">Graph DFS</a></li>
        <li><a href="/data-structure-and-algorithm/2-graph-bfs.html">Graph BFS</a></li>
        <li><a href="/data-structure-and-algorithm/2-graph-topological-sort.html">Graph Topological Sort</a></li>
        <li><a href="/data-structure-and-algorithm/2-graph-multi-source.html">Graph Multi Source</a></li>
        <li><a href="/data-structure-and-algorithm/3-advanced-graph.html">Advanced Graph</a></li>
        <li><a href="/data-structure-and-algorithm/3-dynamic-programming-1d.html">Dynamic Programming 1D</a></li>
        <li><a href="/data-structure-and-algorithm/3-dynamic-programming-2d.html">Dynamic Programming 2D</a></li>
        <li><a href="/data-structure-and-algorithm/3-greedy.html">Greedy</a></li>
        <li><a href="/data-structure-and-algorithm/3-interval.html">Interval</a></li>
        <li><a href="/data-structure-and-algorithm/3-matrix.html">Matrix</a></li>
        <li><a href="/data-structure-and-algorithm/3-math.html">Math</a></li>
        <li><a href="/data-structure-and-algorithm/3-geometry.html">Geometry</a></li>
        <li><a href="/data-structure-and-algorithm/3-bit-manipulation.html">Bit Manipulation</a></li>
      </ul>
      <li>Neet 250, Alphabet 150  (out-of-scope)</li>
      <li>Reference</li>
      <ul>
        <li><a href="/data-structure-and-algorithm/a-data-structure-and-algorithm.html">Data Structure and Algorithm</a></li>
      </ul>
    </ul>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Hash table</h2>
    <ul>
      <li>Representation</li>
<pre><code class="python">my_dict = {}  # Dictionary
my_set = set()  # Set</code></pre>
      <li>Runtime</li>
      <ul>
        <li>Search</li>
        <ul>
          <li>On average - \( O(1) \)</li>
          <li>Worst case - \( O(n) \)</li>
        </ul>
        <li>Insert</li>
        <ul>
          <li>On average - \( O(1) \)</li>
          <li>Worst case - \( O(n) \)</li>
        </ul>
        <li>Delete</li>
        <ul>
          <li>On average - \( O(1) \)</li>
          <li>Worst case - \( O(n) \)</li>
        </ul>
      </ul>
    </ul>

<!--     <h3 class="card-title">Sequence</h3>

    <h3 class="card-title">Prefix sum</h3>

<pre><code class="python">prefix_sum = 0

for i, num in enumerate(nums):
    prefix_sum += num</code></pre>

    <h3 class="card-title">Sliding window</h3>
    <ul>
      <li>Uses a pointer and window size</li>
    </ul>

    <h3 class="card-title">Two pointer</h3> -->
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Stack</h2>
    <ul>
      <li>Representation</li>
<pre><code class="python">stack = []</code></pre>
      <li>Runtime</li>
      <ul>
        <li>Search</li>
        <ul>
          <li>Get item at the front of a stack - <code>stack[0]</code> - \( O(1) \)</li>
          <li>Get item at the end of a stack - <code>stack[-1]</code> - \( O(1) \)</li>
        </ul>
        <li>Insert</li>
        <ul>
          <li>Add elements at the end of a stack - <code>stack.append('element')</code> - \( O(1) \)</li>
        </ul>
        <li>Delete</li>
        <ul>
          <li>Remove elements from the beginning of a stack - <code>stack.pop(0)</code> - \( O(n) \)</li>
          <li>Remove elements from the end of a stack - <code>stack.pop()</code> - \( O(1) \)</li>
        </ul>
      </ul>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Queue</h2>
    <ul>
      <li>Representation</li>
<pre><code class="python">from collections import deque

queue = deque()</code></pre>
      <li>Runtime</li>
      <ul>
        <li>Search</li>
        <ul>
          <li>Get item at the front of a queue - <code>queue[0]</code> - \( O(1) \)</li>
          <li>Get item at the end of a queue - <code>queue[-1]</code> - \( O(1) \)</li>
        </ul>
        <li>Insert</li>
        <ul>
          <li>Add elements at the end of a queue - <code>queue.append('element')</code> - \( O(1) \)</li>
        </ul>
        <li>Delete</li>
        <ul>
          <li>Remove elements from the beginning of a queue - <code>queue.popleft()</code> - \( O(1) \)</li>
          <li>Remove elements from the end of a queue - <code>queue.pop()</code> - \( O(1) \)</li>
        </ul>
      </ul>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Binary search</h2>
    <ul>
      <li>Recursive</li>
      <ul>
        <li>Time - \( O(logn) \)</li>
        <li>Space - \( O(logn) \)</li>
      </ul>
<pre><code class="python">def binary_search(nums, left, right, target):

    if left > right:
        return -1

    mid = (left+right) // 2
    if target > nums[mid]:
        return binary_search(nums, mid+1, right, target)
    elif target < nums[mid]:
        return binary_search(nums, left, mid-1, target)
    else:
        return mid 
</code></pre>
      <li>Iterative</li>
      <ul>
        <li>Time - \( O(logn) \)</li>
        <li>Space - \( O(1) \)</li>
      </ul>
<pre><code class="python">def binary_search(nums, target):

left, right = 0, len(nums) - 1

while left <= right:

    mid = (left+right) // 2
    if target > nums[mid]:
        left = mid + 1
    elif target < nums[mid]:
        right = mid - 1
    else:
        return mid

    return left</code></pre>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Linked list</h2>
    <ul>
      <li>Representation</li>
<pre><code class="python"># Singly
class Node:
    def __init__(self, data=0, next=None):
        self.data = data
        self.next = next

# Doubly
class Node:
    def __init__(self, data=0, next=None, prev=None):
        self.data = data
        self.prev = prev
        self.next = next</code></pre>
      <li>Runtime</li>
      <ul>
        <li>Search - \( O(n) \)</li>
        <li>Insert</li>
        <ul>
          <li>At head - \( O(1) \)</li>
          <li>At tail - \( O(n) \)</li>
        </ul>
        <li>Delete</li>
        <ul>
          <li>At head - \( O(1) \)</li>
          <li>At tail - \( O(n) \)</li>
        </ul>
      </ul>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Tree</h2>
    <ul>
      <li>Representation</li>
<pre><code class="python">class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right</code></pre>
    </ul>

    <h3 class="card-title">DFS</h3>
    <ul>
      <li>Runtime</li>
      <ul>
        <li>Time - \( O(n) \)</li>
        <ul>
          <li>\( n \) - number of nodes in tree</li>
        </ul>
        <li>Space \( O(h) = O(n) \)</li>
        <ul>
          <li>Recursion stack</li>
        </ul>
      </ul>
      <li>Pre-order - node, left, right</li>
<pre><code class="python">def pre_order(node):
    if node:
        print(node.val)
        pre_order(node.left)
        pre_order(node.right)</code></pre>
      <li>Post-order - left, right, node</li>
<pre><code class="python">def post_order(node):
    if node:
        post_order(node.left)
        post_order(node.right)
        print(node.val)</code></pre>
      <li>In-order - left, node, right</li>
<pre><code class="python">def in_order(node):
    if node is not None:
        in_order(node.left)
        print(node.val)
        in_order(node.right)</code></pre>
    </ul>

    <h3 class="card-title">BFS</h3>
    <ul>
      <li>Runtime</li>
      <ul>
        <li>Time - \( O(n) \)</li>
        <ul>
          <li>\( n \) - number of nodes in tree</li>
        </ul>
        <li>Space \( O(n) \)</li>
      </ul>
<pre><code class="python">def bfs(root):

    explored = set()
    explored.add(root)

    queue = deque()
    queue.append(root)

    while queue:
        root = queue.popleft()
        if root.left and root.left not in explored:
            explored.add(root.left)
            queue.append(root.left)
        if root.right and root.right not in explored:
            explored.add(root.right)
            queue.append(root.right)</code></pre>      
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Heap</h2>
    <ul>
      <li>Perfectly balanced tree</li>
      <li>Root element must have the minimum key</li>
      <li>Representation</li>
<pre><code class="python">min_heap = []

heappush(min_heap, 1)
heappush(min_heap, 3)
heappush(min_heap, 2)

print(heappop(min_heap)) # 1
print(heappop(min_heap)) # 2
print(heappop(min_heap)) # 3</code></pre>

<pre><code class="python">max_heap = []

heappush(min_heap, -1)
heappush(min_heap, -3)
heappush(min_heap, -2)

print(-heappop(min_heap)) # 3
print(-heappop(min_heap)) # 2
print(-heappop(min_heap)) # 1</code></pre>
      <li>Runtime</li>
      <ul>
        <li>Heapify (n batched inserts) - \( O(n) \)</li>
        <li>Extract (remove an element with minimum key) - \( O(logn) \)</li>
        <ul>
          <li>Delete root</li>
          <li>Move last node to new root</li>
          <li>Bubble-down k until k's parent <= k</li>
        </ul>
        <li>Insert (add to heap) - \( O(logn) \)</li>
        <ul>
          <li>Create a new node at the end of the heap</li>
          <li>Place the new key at that node</li>
          <li>Perculate (swap values if needed) up until reaching the root and the heap property is satisfied</li>
        </ul>
        <li>Delete - \( O(logn) \)</li>
        <ul>
          <li>Delete the root</li>
          <li>Move the key of the last child node to root</li>
          <li>Perculate (swap values if needed) up until reaching the last node and the heap property is satisfied</li>
        </ul>
      </ul>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Sort</h2>

    <h3 class="card-title">Quicksort</h3>
    <ul>
      <li>Partition</li>
      <ul>
        <li>Choosing pivot randomly</li>
        <li>Numbers less than pivot should be on left side</li>
        <li>Numbers greater than pivot should be on right side</li>
      </ul>
      <li>Recurse on left and right</li>
      <li>\( O(n\log{n}) \) on average</li>
      <li>No additional space required</li>
      <li>If pivot is chosen in worst way possible, the algorithm could run in \( O(n^2) \)</li>
    </ul>

<pre><code class="python">def partition(nums, l, r):

    p = random.randint(l, r)
    
    for i in range(l, r+1):
        if nums[i] > nums[p] and i > p:
            nums[i], nums[p] = nums[p], nums[i]
        if nums[i] < nums[p] and i < p:
            nums[i], nums[p] = nums[p], nums[i]
        p = i

    return p</code></pre>

    <h3 class="card-title">Quickselect</h3>
    <ul>
      <li>Find kth smallest element</li>
      <li>Partition like quicksort</li>
      <li>If k < p, search on left side</li>
      <li>If k > p, search on right side</li>
      <li>If k == p, return value at pivot</li>
      <li>\( O(n) \) on average</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Backtracking</h2>
    <ul>
      <li>Runtime</li>
      <ul>
        <li>\( k \) - branching factor</li>
        <li>\( n  \) - depth of recursion</li>
      </ul>
    </ul>

<pre><code class="python">def backtrack():

    for i in n:
        array.append()
        backtrack()
        array.pop()</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Trie</h2>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Graph</h2>
    <ul>
      <li>Representation</li>
      <ul>
        <li>Adjacency list is space-wise more efficient than list of lists</li>
        <li>Dictionary can be used where key is each node and value is array of nodes</li>
      </ul>
<pre><code class="python">from collections import defaultdict

graph = defaultdict(list)</code></pre>
    </ul>

    <h3 class="card-title">DFS</h3>
    <ul>
      <li>Runtime</li>
      <ul>
        <li>Time - \( O(n+m) \)</li>
        <ul>
          <li>\( n \) - number of nodes</li>
          <li>\( m  \) - number of edges</li>
        </ul>
        <li>Space \( O(n) \)</li>
      </ul>
<pre><code class="python">def dfs(graph, start):

    explored = set()
    explored.add(start)

    stack = []
    stack.append(start)

    while stack:
        node = stack.pop()
        for next_node in graph[node]:
            if next_node not in explored:
                explored.add(next_node)
                stack.append(next_node)</code></pre>
      <li>Check if graph is tree</li>
      <ul>
        <li>Check if there is no cycle</li>
        <li>Check if all nodes are connected</li>
      </ul>
    </ul>

    <h3 class="card-title">BFS</h3>
    <ul>
      <li>Runtime</li>
      <ul>
        <li>Time - \( O(n+m) \)</li>
        <ul>
          <li>\( n \) - number of nodes</li>
          <li>\( m  \) - number of edges</li>
        </ul>
        <li>Space \( O(n) \)</li>
      </ul>
<pre><code class="python">from collections import deque

def bfs(graph, start):

    explored = set()
    explored.add(start)

    queue = deque()
    queue.append(start)

    while queue:
        node = queue.popleft()
        for next_node in graph[node]:
            if next_node not in explored:
                explored.add(next_node)
                queue.append(next_node)</code></pre>

      <li>Shortest path</li>
      <ul>
        <li>Compute dist(v), the fewest number of edges on path from s to v</li>
        <li>Assumption - every edge has length of 1</li>
        <li>Extra code to BFS</li>
      </ul>
<pre><code class="python">from collections import deque

def bfs(graph, start, end):

    explored = set()
    explored.add(start)

    queue = deque()
    queue.append((start, 0))

    while queue:
        node, depth = queue.popleft()

        for next_node in graph[node]:
            if next_node == end_node:
                return depth + 1

            if next_node not in explored:
                queue.append((next_node, depth+1))
                explored.add(next_node)

    return -1</code></pre>
      <li>Connected component</li>
      <ul>
        <li>Let G(V,E) undirected graph</li>
        <li>Connected component = pieces of G</li>
        <li>Compute all connected components</li>
      </ul>
<pre><code class="python">explored = set()

for i in range(num_nodes):
    if i not in explored:
        bfs(i, graph, explored)</code></pre>
    </ul>

    <h3 class="card-title">Topological Sort (Khan's algorithm)</h3>
    <ul>
      <li>Find indegree for each node where indegree is number of incoming nodes</li>
      <li>Add nodes with indegree of 0 to a queue</li>
      <li>For next nodes, remove incoming node</li>
      <li>Repeat</li>
<pre><code class="python">from collections import deque

def topological_sort(edges):

    graph, indegree = defaultdict(list), defaultdict(int)

    for a, b in edges:
        graph[a] = b
        indegree[b] += 1

    queue = deque()

    for key, val in graph.items():
        if key not in indegree:
            queue.append(key)

    while queue:
        node = queue.popleft()
        
        for next_node in graph[node]:
            indegree[next_node] -= 1
            if indegree[next_node] == 0:
                queue.append(next_node)</code></pre>
      <li>Detect cycle</li>
      <ul>
        <li>Do topological sort</li>
        <li>If indegree of any node != 0, then there is cycle</li>
      </ul>
    </ul>

    <h3 class="card-title">Union-Find</h3>
    <ul>
      <li>Representation</li>
      <ul>
        <li>Find - returns the sub-graph that a node belongs to</li>
        <li>Union - merge two sub-graphs into one sub-graph</li>
      </ul>
<pre><code class="python"># Key represents each node
# Value represents the leader of group that the node belongs to
parent = defaultdict(int)

def find(node):

    if parent[node] == node:
        return node

    return find(parent[node])

def union(node_1, node_2):

    leader_1 = find(node_1)
    leader_2 = find(node_2)

    if leader_1 == leader_2:
        return

    parent[leader_2] = leader_1  # OR parent[leader_1] = leader_2</code></pre>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Dynamic programming</h2>

    <h3 class="card-title">1D</h3>

<pre><code class="python">dp = [0 for _ in range(n+1)]</code></pre>

    <h3 class="card-title">2D</h3>

<pre><code class="python">dp = [[0]*(m+1) for _ in range(n+1)]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Greedy</h2>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Interval</h2>
    <ul>
      <li>Sort by start time</li>
<pre><code class="python">intervals.sort(key = lambda x: (x[0]))</code></pre>
      <li>Find intersection</li>
<pre><code class="python">def find_intersection(a, b):

    if a[0] <= b[1] and b[0] <= a[1]:
        intersection = [max(a[0], b[0]), min(a[1], b[1])]
    else:
        intersection = []

    return intersection</code></pre>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Matrix</h2>

<pre><code class="python">n, m = len(matrix), len(matrix[0])

for i in range(n):
    for j in range(m):
        print(matrix[i][j])</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Math</h2>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Geometry</h2>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Bit manipulation</h2>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>
<!-- Data Structure and Algorithm END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>