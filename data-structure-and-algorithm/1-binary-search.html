<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax/tex-chtml.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- binary Search BEGIN -->
<div class="card mb-4" id="binary-search">
  <div class="card-body">
    <h2 class="card-title">Binary Search</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#binary-search-">Median of Two Sorted Arrays</a></li>
      <li><a href="#binary-search-">Search in Rotated Sorted Array</a></li>
      <li><a href="#binary-search-">Find First and Last Position of Element in Sorted Array<</a></li>
      <li><a href="#binary-search-">Search a 2D Matrix</a></li>
      <li><a href="#binary-search-">Find Minimum in Rotated Sorted Array</a></li>
      <li><a href="#binary-search-">Find Peak Element</a></li>
      <li><a href="#binary-search-">Split Array Largest Sum</a></li>
      <li><a href="#binary-search-">Find K Closest Elements</a></li>
      <li><a href="#binary-search-">Binary Search</a></li>
      <li><a href="#binary-search-">Koko Eating Bananas</a></li>
      <li><a href="#binary-search-">Time Based Key-Value Store </a></li>
      <li><a href="#binary-search-">House Robber IV</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Median of Two Sorted Arrays (150/250)</h2>

<pre><code class="python"># [1,3,4], [2,5] ? 3
        # [1,2,3,4,5]

        # Let n1 = len(nums1), n2 = len(nums2), n = n1 + n2
        # Let m1, m2 be mid points of nums1, nums2, and nums = nums1 + nums2
        # Consider that we want to find kth element in nums
        #   If k < m1 + m2, then kth is on left half of nums
        #     If nums1[m1] > nums2[m2], remove r1
        #     If nums1[m1] < nums2[m2], remove r2
        #   If k > m1 + m2, then kth is on right half of nums
        #     If nums1[m1] < nums2[m2], remove l1
        #     If nums1[m1] > nums2[m2], remove l2
        # Time O(log(n1+n2))
        # Space O(1)
    
        def binary_search(i1, j1, i2, j2, k):
            while i1 <= j1 and i2 <= j2:
                if k == 0:
                    break
                m1 = (i1+j1) // 2
                m2 = (i2+j2) // 2
                if k < m1 + m2:
                    if nums1[m1] > nums2[m2]:
                        if m1 < j1:
                            j1 = m1
                        else:
                            j1 = m1 - 1
                    else:
                        if m2 < j2:
                            j2 = m2
                        else:
                            j2 = m2 - 1
                else:
                    if nums1[m1] < nums2[m2]:
                        if m1 > i1:
                            k -= (m1-i1)
                            i1 = m1
                        else:
                            k -= 1
                            i1 = m1 + 1
                    else:
                        if m2 > i2:
                            k -= (m2-i2)
                            i2 = m2
                        else:
                            k -= 1
                            i2 = m2 + 1
                print(f"{nums1[i1:j1+1]},{nums2[i2:j2+1]},k={k}")
            if i1 > j1:
                return nums2[i2+k]
            if i2 > j2:
                return nums1[i1+k]
            return min(nums1[i1], nums2[i2])
            
        n1, n2 = len(nums1), len(nums2)
        n = n1 + n2
        i1, i2, j1, j2 = 0, 0, n1 - 1, n2 - 1
        if (n1+n2) % 2 != 0:
            return binary_search(i1, j1, i2, j2, n//2)
        else:
            a = binary_search(i1, j1, i2, j2, n//2)
            b = binary_search(i1, j1, i2, j2, n//2-1)
            print(a)
            print(b)
            return (a+b) / 2
        
        return 0</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/median-of-two-sorted-arrays">4. Median of Two Sorted Arrays</a> | <a href="https://neetcode.io/problems/median-of-two-sorted-arrays">Median of Two Sorted Arrays</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Search in Rotated Sorted Array (75/150/250)</h2>

<pre><code class="python">class Solution:
    def search(self, nums: List[int], target: int) -> int:

        # [1,2,3,4,5] target = 3 ? 2
        # [4,5,1,2,3] target = 3 ? 4
        # [3,4,5,1,2] target = 3 ? 0
        # [3,4,5,1,2] target = 6 ? -1

        # If mid < right, right side is sorted
        #   If mid < target <= right, search on right
        #   Else, search on left 
        # If mid > right, left side is sorted 
        #   If left <= target < mid, search on left
        #   Else, search on right
        # Time O(logn) n = len(nums)
        # Space O(1)

        left, right = 0, len(nums) - 1

        while left <= right:
            mid = (left+right) // 2
            if nums[mid] == target:
                return mid
            if nums[mid] < nums[right]:
                if nums[mid] < target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
            else:
                if nums[left] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1

        return -1</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/search-in-rotated-sorted-array">33. Search in Rotated Sorted Array</a> | <a href="https://neetcode.io/problems/find-target-in-rotated-sorted-array">Search in Rotated Sorted Array</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Find First and Last Position of Element in Sorted Array (M)</h2>

<pre><code class="python">class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:

        # Binary search

        left = 0
        right = len(nums) - 1

        # Time O(logn) 
        #   n = len(nums)
        # Space O(1)
        while left <= right:
            mid = (left+right) // 2
            if target > nums[mid]:
                left = mid + 1
            elif target < nums[mid]:
                right = mid - 1
            else:
                start = mid
                while nums[mid] == nums[start]:
                    start -= 1
                    if start < 0:
                        break
                start += 1

                end = mid
                while nums[mid] == nums[end]:
                    end += 1
                    if end >= len(nums):
                        break
                end -= 1

                return [start, end]

        return [-1, -1]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array">34. Find First and Last Position of Element in Sorted Array</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Search a 2D Matrix (150/250)</h2>

<pre><code class="python">class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        
        # Consider middle row
        # If target < first num, search in upper row
        # If target > last num, search in lower row
        # Else, search in middle row
        # Time O(logn+logm) n = number of rows, m = number of cols
        # Space O(1)

        def binary_search(nums, target):

            i, j = 0, len(nums)
            while i <= j:
                m = (i+j) // 2
                if nums[m] < target:
                    i = m + 1
                elif nums[m] > target:
                    j = m - 1
                else:
                    return True
            return False

        i, j = 0, len(matrix) - 1
        while i <= j:
            m = (i+j) // 2
            if matrix[m][-1] < target:
                i = m + 1
            elif matrix[m][0] > target:
                j = m - 1
            else:
                return binary_search(matrix[m], target)
            
        return False</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/search-a-2d-matrix">74. Search a 2D Matrix</a> | <a href="https://neetcode.io/problems/search-2d-matrix">Search a 2D Matrix</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Find Minimum in Rotated Sorted Array (75/150/250)</h2>

<pre><code class="python">class Solution:
    def findMin(self, nums: List[int]) -> int:
        
        # [1,2,3,4,5] ? 1
        # [2,3,4,5,1] ? 1
        # [4,5,1,2,3] ? 1
        # [5,1,2,3,4] ? 1

        # If mid < right most, right side is sorted
        #   Min is on left side   
        #   right = mid - 1
        # If mid > right most, left side is sorted
        #   Min is on right side
        #   left = mid + 1
        # If mid < mid - 1, mid is the min
        # If mid + 1 < mid, mid + 1 is the min
        # If nums is already in sorted order, return left most
        # Time O(logn) n = len(nums)
        # Space O(1)

        left, right = 0, len(nums) - 1

        if nums[left] <= nums[right]:
            return nums[left]

        while left <= right:
            mid = (left+right) // 2
            if nums[mid] < nums[mid-1]:
                return nums[mid]
            if nums[mid+1] < nums[mid]:
                return nums[mid+1]
            if nums[mid] < nums[right]:
                right = mid
            else:
                left = mid

        return nums[left]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array">153. Find Minimum in Rotated Sorted Array</a> | <a href="https://neetcode.io/problems/find-minimum-in-rotated-sorted-array">Find Minimum in Rotated Sorted Array</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Find Peak Element (M)</h2>

<pre><code class="python">class Solution:
    def findPeakElement(self, nums: List[int]) -> int:

        # Binary search
        # If nums[mid] > nums[mid+1], peak must exist on left
        # If nums[mid] < nums[mid+1], peak must exist on right

        # Time O(logn)
        #   n = len(nums)
        # Space O(1)
        left = 0
        right = len(nums) - 1

        while left < right:
            mid = (left+right) // 2

            if nums[mid] > nums[mid+1]:
                right = mid
            else:
                left = mid + 1

        return left</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/find-peak-element">162. Find Peak Element</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Split Array Largest Sum (H)</h2>

<pre><code class="python"></code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/split-array-largest-sum">410. Split Array Largest Sum</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Find K Closest Elements (M)</h2>

<pre><code class="python">class Solution:
    def findClosestElements(self, nums: List[int], k: int, num: int) -> List[int]:

        # Because nums is sorted, k closest integers will be in
        # consecutive array
        # Find a number that is closest to x
        #   Then, expand left and right from that number
        #   to gather k closest numbers
        # Run binary seach to find closest number of x
        #   If mid > x, search on left side
        #   If mid < x, search on right side
        #   If mid == x, return mid
        #   Remember the last left and right pointer, 
        #   and return it when right >= left
        # Expand
        #   Initialize k' = 1
        #   Compare left and right numbers
        #   If k' + 2 <= k
        #     Then, include both numbers
        #   Else
        #     Compare left and right number and
        #     pick number that is closer to the 
        #     cloest number   

        # Time O(logn+k)
        #   n = len(nums)
        # Space O(1)

        def binary_search(nums, left, right, target):

            while left <= right:
                mid = (left + right) // 2
                if target > nums[mid]:
                    left = mid + 1
                elif target < nums[mid]:
                    right = mid - 1
                else:
                    return mid
                
            return left

        index = binary_search(nums, 0, len(nums)-1, num)
        
        left = index - 1
        right = index

        while right - left - 1 < k:
            # check for out of bounds
            if left == -1:
                right += 1
                continue

            if right == len(nums) \
                or abs(nums[left]-num) <= abs(nums[right]-num):
                left -= 1
            else:
                right += 1

        return nums[left+1:right]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/find-k-closest-elements">658. Find K Closest Elements</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Binary Search (150/250)</h2>

<pre><code class="python">class Solution:
    def search(self, nums: List[int], target: int) -> int:

        # Time O(logn) n = len(nums)
        # Space O(1)

        i, j = 0, len(nums) - 1

        while i <= j:
            m = (i+j) // 2
            if nums[m] < target:
                i = m + 1
            elif nums[m] > target:
                j = m - 1
            else:
                return m

        return -1</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/binary-search">704. Binary Search</a> | <a href="https://neetcode.io/problems/binary-search">Binary Search</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Koko Eating Bananas (150/250)</h2>

<pre><code class="python">class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:

        # [1,2,3,4], h = 7 ? 2

        # Try k between 1 and max(piles)
        # h_ = nubmer of hours took to eat with speek k
        # If h_ < h, eating too fast, decrease k
        # If h_ > h, eating too slow, increase k
        # Time O(mlogn) m = len(piles), n = max(piles)
        # Space O(1)

        i, j = 1, max(piles)

        while i <= j:
            m = (i+j) // 2
            h_ = 0
            for num in piles:
                h_ += num // m
                if num % m != 0:
                    h_ += 1
            if h_ < h:
                j = m - 1
            elif h_ > h:
                i = m + 1
            else:
                j = m - 1

        return i</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/kth-missing-positive-number">875. Koko Eating Bananas</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">Time Based Key-Value Store (150/250)</h2>

<pre><code class="python">class TimeMap:

    # Use dictionary of list
    # Later timestamp will be inserted later in list
    # Binary search to find biggest timestamp that is <= current
    # from the end of list
    # Set
    # Time O(1)
    # Space O(n)
    # Get
    # Time O(logn)
    # Space O(1)

    def __init__(self):
        self.timemap = defaultdict(list)

    def set(self, key: str, value: str, timestamp: int) -> None:
        self.timemap[key].append((value, timestamp))

    def get(self, key: str, timestamp: int) -> str:
        if key not in self.timemap:
            return ""
        if timestamp < self.timemap[key][0][1]:
            return ""
        
        i, j = 0, len(self.timemap[key]) - 1
        while i <= j:
            m = (i+j) // 2
            if self.timemap[key][m][1] < timestamp:
                i = m + 1
            elif self.timemap[key][m][1] > timestamp:
                j = m - 1
            else:
                return self.timemap[key][m][0]
        
        return self.timemap[key][j][0]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/time-based-key-value-store">981. Time Based Key-Value Store</a> | <a href="https://neetcode.io/problems/time-based-key-value-store">Time Based Key-Value Store</a>
  </div>
</div>

<div class="card mb-4" id="binary-search-">
  <div class="card-body">
    <h2 class="card-title">House Robber IV (M)</h2>

<pre><code class="python">class Solution:
    def minCapability(self, nums: List[int], k: int) -> int:
        
        # Binary search
        # Find max steal and min steal from any one house
        # Compute mid value
        # Check if at least k houses can be robbed 
        # (but no house whose value is greater than mid value can be robbed) 
        
        left, right, n = min(nums), max(nums), len(nums)

        # Time O(nlogm)
        #   n = len(nums)
        #   m = difference between min and max number in nums
        # Space O(1)
        while left < right:
            mid = (left+right) // 2

            i, num_robbed = 0, 0
            while i < n:
                if nums[i] <= mid:
                    num_robbed += 1
                    i += 2
                else:
                    i += 1

            # If feasible, decrease next value to check
            if num_robbed >= k:
                right = mid
            # If not feasible, increase next value to check
            else:
                left = mid + 1

        return left</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/house-robber-iv">2560. House Robber IV</a>
  </div>
</div>
<!-- Binary Search END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>