<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax/tex-chtml.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>
</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- Array BEGIN -->
<div class="card mb-4" id="array">
  <div class="card-body">
    <h2 class="card-title">Array</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#array-">Two Sum</a></li>
      <li><a href="#array-">Next Permutation</a></li>
      <li><a href="#array-">First Missing Positive</a></li>
      <li><a href="#array-">Longest Consecutive Sequence</a></li>
      <li><a href="#array-">Majority Element</a></li>
      <li><a href="#array-">Rotate Array</a></li>
      <li><a href="#array-">Contains Duplicate</a></li>
      <li><a href="#array-">Product of Array Except Self</a></li>
      <li><a href="#array-">Longest Increasing Subsequence</a></li>
      <li><a href="#array-">Intersection of Two Arrays</a></li>
      <li><a href="#array-">Russian Doll Envelopes</a></li>
      <li><a href="#array-">Logger Rate Limiter</a></li>
      <li><a href="#array-">Insert Delete GetRandom O(1)</a></li>
      <li><a href="#array-">Design In-Memory File System</a></li>
      <li><a href="#array-">Analyze User Website Visit Pattern</a></li>
      <li><a href="#array-">Invalid Transactions</a></li>
      <li><a href="#array-">Dot Product of Two Sparse Vectors</a></li>
      <li><a href="#array-">Buildings With an Ocean View</a></li>
      <li><a href="#array-">Put Marbles in Bags</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="array-">
  <div class="card-body">
    <h2 class="card-title">Two Sum (75/150)</h2>

<pre><code class="python">class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:

        # nums = [1,2,3,4], target = 3 ? [0,1]

        # Create a set with nums
        # For each num in nums, check if target-num is in set
        # Time O(n) n = len(nums)
        # Space O(n)

        nums_dict = defaultdict(int)

        for i, num in enumerate(nums):
            nums_dict[num] = i

        for i, num in enumerate(nums):
            if target - num in nums_dict \
                and i != nums_dict[target-num]:
                return [i, nums_dict[target-num]]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/two-sum">1. Two Sum</a> | <a href="https://neetcode.io/problems/two-integer-sum">Two Sum</a>
  </div>
</div>

<div class="card mb-4" id="array-">
  <div class="card-body">
    <h2 class="card-title">Next Permutation (M)</h2>

<pre><code class="python">class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """

        # Iterate from right
        #   Find first decreasing number
        #   Find first number from right > above number
        #   Swap those two numbers
        #   Reverse right side of array
        # If there is no decreasing number, reverse entire array

        reverse = True

        # Time O(n)
        #   n = len(nums)
        # Space O(1)
        for i in range(len(nums)-1, 0, -1):
            if nums[i-1] < nums[i]:
                
                j = len(nums) - 1
                while i - 1 < j:
                    if nums[i-1] < nums[j]:
                        nums[j], nums[i-1] = nums[i-1], nums[j]
                        break
                    j -= 1
                
                print(nums)
                k = i
                l = len(nums) - 1
                while k < l:
                    nums[l], nums[k] = nums[k], nums[l]
                    k += 1
                    l -= 1

                reverse = False
                break

        if reverse:
            nums.reverse()</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/next-permutation">31. Next Permutation</a>
  </div>
</div>

<div class="card mb-4" id="array-">
  <div class="card-body">
    <h2 class="card-title">First Missing Positive (H)</h2>

<pre><code class="python">class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        
        # First missing positive num must be in [1,n]
        # Set numbers outside [1,n] to 0
        # Let index represents frequency of each number in array

        n = len(nums)
        
        for i in range(n):
            if nums[i] < 1 or nums[i] > n:
                nums[i] = 0

        for i in range(n):
            if nums[i] != 0 and nums[i] % (n+1) <= n:
                nums[(nums[i]%(n+1))-1] += (n+1)

        for i in range(n):
            if nums[i] <= n:
                return i + 1

        return n + 1</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/first-missing-positive">41. First Missing Positive</a>
  </div>
</div>

<div class="card mb-4" id="array-">
  <div class="card-body">
    <h2 class="card-title">Longest Consecutive Sequence (75/150)</h2>

<pre><code class="python">class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:

        # [2,3,15,1,4,19,5] ? 5

        # Create a set from nums
        # For each elements in set, check if n + 1 is also in the set
        # Avoid duplicate work by checking is n - 1 is in set 
        # Time O(n) n = len(nums)
        # Space O(n)

        nums_set = set(nums)
        max_len = 0

        for num in nums:
            if num - 1 not in nums_set:
                length = 1
                while num + 1 in nums_set:
                    num = num + 1
                    length += 1
                max_len = max(max_len, length)

        return max_len</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/longest-consecutive-sequence">128. Longest Consecutive Sequence</a> | <a href="https://leetcode.com/problems/longest-consecutive-sequence">128. Longest Consecutive Sequence</a>
  </div>
</div>

<div class="card mb-4" id="array-">
  <div class="card-body">
    <h2 class="card-title">Majority element (E)</h2>

<pre><code class="python">class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        
        # Boyer-Moore
        
        count = 0 
        candidate = None

        # Time O(n)
        #   n = len(nums)
        # Space O(1)
        for num in nums:
            if count == 0:
                candidate = num

            if num == candidate:
                count += 1
            else:
                count -= 1

        return candidate</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/majority-element">169. Majority Element</a>
  </div>
</div>

<div class="card mb-4" id="array-">
  <div class="card-body">
    <h2 class="card-title">Rotate Array (M)</h2>

<pre><code class="python">class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """

        # New index is (i+k) % len(nums)

        # Time O(n)
        #   n = len(nums)
        # Space O(n)
        nums_copy = nums[:]
        for i, num in enumerate(nums):
            new_index = (i+k) % len(nums)
            nums[new_index] = nums_copy[i]

        return nums</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/rotate-array">189. Rotate Array</a>
  </div>
</div>

<div class="card mb-4" id="array-">
  <div class="card-body">
    <h2 class="card-title">Contains Duplicate (75/150)</h2>

<pre><code class="python">cclass Solution:
    def hasDuplicate(self, nums: List[int]) -> bool:

        # [1,1,2]? True
        # [1,2,3]? False

        # Use a hash table to remember seen num
        # Time O(n) n = len(nums)
        # Space O(n)

        seen = set()
        for num in nums:
            if num in seen:
                return True
            seen.add(num)  
        
        return False</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/contains-duplicate">217. Contains Duplicate</a> | <a href="https://neetcode.io/problems/duplicate-integer">Contains Duplicate</a> 
  </div>
</div>

<div class="card mb-4" id="array-">
  <div class="card-body">
    <h2 class="card-title">Product of Array Except Self (75/150)</h2>

<pre><code class="python">class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:

        # [1,2,3,4] ? [24,12,8,6]
        # [1,0,2,3] ? [0,6,0,0]
        # [1,0,0,4] ? [0,0,0,0]

        # More than one zero ? return array of 0
        # Exactly one zero? ? array has zero except one element
        # No zero? Find total product and divide it by each element
        # But this solution requires division
        # Time O(n)
        # Space O(1) ignoring space for result
        
        # For each index, find product from left and right side
        # Ex. [1,2,3,4] => Left product [1,1,2,6] right product [24,12,4,1] 
        # Time O(n) n = len(nums)
        # Space O(n)

        n = len(nums)
        left_product, right_product = [1] * n, [1] * n

        for i in range(1, n):
            left_product[i] = left_product[i-1] * nums[i-1]
        
        for i in range(n-2, -1, -1):
            right_product[i] = right_product[i+1] * nums[i+1]
        
        result = []
        for i in range(n):
            result.append(left_product[i]*right_product[i])

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/product-of-array-except-self">238. Product of Array Except Self</a> | <a href="https://neetcode.io/problems/products-of-array-discluding-self">Products of Array Except Self</a>
  </div>
</div>

<div class="card mb-4" id="array-">
  <div class="card-body">
    <h2 class="card-title">Longest Increasing Subsequence (75/150)</h2>

<pre><code class="python">class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        
        # [1,2,4,3,5] ? 4 (1,2,3,5)
        # [1,2,4,7,2,3,5] ? 4 (1,2,4,7), (1,2,3,5)
        # [1,7,8,9,2,3,4,5] ? 5 (1,2,3,4,5)

        # Start appending nums into result
        # If incoming num > last num in result, append
        # Else, find first num from beginning that is >= incoming num
        #   and replace
        # Always remember max size of result
        # Time O(n**2) n = len(nums)
        # Space O(n)

        max_len, result = 0, []

        for num in nums:
            if not result or result[-1] < num:
                result.append(num)
            else:
                for i in range(len(result)):
                    if result[i] >= num:
                        result[i] = num
                        break
            max_len = max(max_len, len(result))

        return max_len</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/longest-increasing-subsequence">300. Longest Increasing Subsequence</a> | <a href="https://neetcode.io/problems/longest-increasing-subsequence">Longest Increasing Subsequence</a>
  </div>
</div>

<div class="card mb-4" id="array-">
  <div class="card-body">
    <h2 class="card-title">Intersection of Two Arrays (E)</h2>

<pre><code class="python">class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        
        # Convert nums2 into a set
        # Iterate nums1 and see if that number exists in nums2 set

        nums2_set, result = set(nums2), set()

        # Time O(max(n,m))
        #   n = len(nums1)
        #   m = len(nums2)
        # Space O(m)
        for num in nums1:
            if num in nums2_set:
                result.add(num)

        return list(result)</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/range-sum-query-2d-immutable">349. Intersection of Two Arrays</a>
  </div>
</div>

<div class="card mb-4" id="array-">
  <div class="card-body">
    <h2 class="card-title">Russian Doll Envelopes (H)</h2>

<pre><code class="python">class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:

        # Sort x[0] ascending
        # Sort x[1] decending
        # Extra x[1]'s, then compute longest increasing subsequence

        def lis(nums):

            sub = []
            sub.append(nums[0])

            def binary_search(nums, k):

                left = 0
                right = len(nums) - 1
                
                while left < right:
                    mid = (left+right) // 2 
                    if nums[mid] < k:
                        left = mid + 1
                    else:
                        right = mid

                return right

            # Time O(nlogn)
            #   n = len(nums)
            # Space O(1)
            #   Ignoring space for output
            for i in range(1, len(nums)):

                if nums[i] < sub[-1]:
                    # Find first number in sub that is > nums[i]
                    j = binary_search(sub, nums[i])
                    sub[j] = nums[i]

                if nums[i] > sub[-1]:
                    sub.append(nums[i])
                
            return len(sub)       

        envelopes.sort(key=lambda x: (x[0], -x[1]))
        sequence = [x for _, x in envelopes]
        return lis(sequence)</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/russian-doll-envelopes">354. Russian Doll Envelopes</a>
  </div>
</div>

<div class="card mb-4" id="array-">
  <div class="card-body">
    <h2 class="card-title">Logger Rate Limiter (E)</h2>

<pre><code class="python">class Logger:

    # Use dictionary to remember the last timestamp for each message

    def __init__(self):
        self.messages = defaultdict(int)

    # Time O(1)
    # Space O(n) 
    #   n = number of unique messages
    def shouldPrintMessage(self, timestamp: int, message: str) -> bool:

        if message in self.messages \
            and timestamp - self.messages[message] < 10:
                return False
        else:
            self.messages[message] = timestamp
            return True


# Your Logger object will be instantiated and called as such:
# obj = Logger()
# param_1 = obj.shouldPrintMessage(timestamp,message)</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/logger-rate-limiter">359. Logger Rate Limiter</a>
  </div>
</div>

<div class="card mb-4" id="array-">
  <div class="card-body">
    <h2 class="card-title">Insert Delete GetRandom O(1) (M)</h2>

<pre><code class="python">class RandomizedSet:

    # Use list to store numbers
    # Use dictionary to store indice of numbers
    # Insert
    #   Append to list O(1)
    #   dic[element] = index O(1)
    # Remove
    #   Swap index of value to remove with last element O(1)
    #   Pop from list O(1)
    #   Remove element from dic O(1)  

    # Time O(1)
    # Space O(n)
    #   n = length of input numbers
    def __init__(self):
        self.nums = []
        self.indices = defaultdict(int)

    def insert(self, val: int) -> bool:
        if val not in self.indices:
            self.nums.append(val)
            self.indices[val] = len(self.nums) - 1
            return True
        return False
        
    def remove(self, val: int) -> bool:
        if val in self.indices:
            val_index = self.indices[val]
            self.nums[val_index] = self.nums[-1]
            self.indices[self.nums[-1]] = val_index
            self.nums.pop()
            del self.indices[val]
            return True
        return False

    def getRandom(self) -> int:
        return self.nums[random.randint(0, len(self.nums)-1)]


# Your RandomizedSet object will be instantiated and called as such:
# obj = RandomizedSet()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/insert-delete-getrandom-o1">380. Insert Delete GetRandom O(1)</a>
  </div>
</div>

<div class="card mb-4" id="array-">
  <div class="card-body">
    <h2 class="card-title">Design In-Memory File System (H)</h2>

<pre><code class="python"></code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/design-in-memory-file-system">588. Design In-Memory File System</a>
  </div>
</div>

<div class="card mb-4" id="array-">
  <div class="card-body">
    <h2 class="card-title">Analyze User Website Visit Pattern (M)</h2>

<pre><code class="python">class Solution:
    def mostVisitedPattern(self, username: List[str], timestamp: List[int], website: List[str]) -> List[str]:

        # Group (timestamp, website) by each user
        # Count sequence of websites for each user
        #   First sort sequence by timestamp
        #   Do not count sequence more than once for each user  
        
        users, count = defaultdict(list), defaultdict(int)

        # Time O(n)
        #   n = number of incoming data
        # Space O(n)
        for user, time, web in zip(username, timestamp, website):
            users[user].append((time, web))

        # Time O(nlogn)
        for key, val in users.items():
            val.sort(key=lambda x: x[0])

        # Time O(n**3)
        for key, val in users.items():
            n, seen = len(val), set()
            for i in range(n):
                for j in range(i+1, n):
                    for k in range(j+1, n):
                        seq = (val[i][1],val[j][1],val[k][1])
                        if seq not in seen:
                            count[seq] += 1
                            seen.add(seq)
                        
        ret_val, max_count = "", 0
        for key, val in count.items():
            if val > max_count:
                max_count = val
                ret_val = key
            elif val == max_count:
                if key < ret_val:
                    ret_val = key

        return ret_val</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/analyze-user-website-visit-pattern">1152. Analyze User Website Visit Pattern</a>
  </div>
</div>

<div class="card mb-4" id="array-">
  <div class="card-body">
    <h2 class="card-title">Dot Product of Two Sparse Vectors (M)</h2>

<pre><code class="python">class SparseVector:

    # Only store indices of non-zero element
    # Compute multiplication only when indices match
    # between two arrays

    # Time O(n) to create array O(l) to compute dot product
    #   n = len(nums)
    #   l = number of non-zero elements
    # Space O(l)
    def __init__(self, nums: List[int]):
        self.nums = []
        for i, num in enumerate(nums):
            if num != 0:
                self.nums.append((i, num))

    def dotProduct(self, vec: 'SparseVector') -> int:

        i, j, result = 0, 0, 0

        while i < len(self.nums) and j < len(vec.nums):

            if self.nums[i][0] > vec.nums[j][0]:
                j += 1
            elif self.nums[i][0] < vec.nums[j][0]:
                i += 1
            else:
                result += self.nums[i][1] * vec.nums[j][1]
                i += 1
                j += 1
                print(result)

        return result


# Your SparseVector object will be instantiated and called as such:
# v1 = SparseVector(nums1)
# v2 = SparseVector(nums2)
# ans = v1.dotProduct(v2)</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/dot-product-of-two-sparse-vectors">1570. Dot Product of Two Sparse Vectors</a>
  </div>
</div>

<div class="card mb-4" id="array-">
  <div class="card-body">
    <h2 class="card-title">Buildings With an Ocean View (M)</h2>

<pre><code class="python">class Solution:
    def findBuildings(self, heights: List[int]) -> List[int]:

        # Iterate from right
        #   Remeber the max number seen
        # If a num > max_seen, then it has ocean view

        result = []
        max_seen = 0
        
        # Time O(n)
        #   n = len(heights)
        # Space O(1)
        for i in range(len(heights)-1, -1, -1):
            if heights[i] > max_seen:
                result.append(i)
            max_seen = max(max_seen, heights[i])

        result.reverse()
        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/buildings-with-an-ocean-view">1762. Buildings With an Ocean View</a>
  </div>
</div>

<div class="card mb-4" id="array-">
  <div class="card-body">
    <h2 class="card-title">Put Marbles in Bags (H)</h2>

<pre><code class="python">class Solution:
    def putMarbles(self, weights: List[int], k: int) -> int:
        
        # Greedy
        # There are k-1 splitting points
        #   Ex. [1,2,3,4,5,6,7,8] k = 3
        #   If [1,2,3], [4,5], [6,7,8], score is 1+3, 4+5, 6+8
        # The score is always 
        #   first num 
        #   + left and right num of each split
        #   last num
        # Compute pair sum for all possible pairs
        #   Then, find irst k-1 largest pairs
        #   Then, find irst k-1 smallest pairs

        pair_sums = []

        # Time O(n)
        #   n = len(weights)
        # Space O(n)
        for i in range(len(weights)-1):
            pair_sums.append(weights[i]+weights[i+1])

        # Time O(nlogn)
        pair_sums.sort()

        i, j, result = 0, len(pair_sums) - 1, 0

        for _ in range(k-1):
            result += pair_sums[j]
            result -= pair_sums[i]
            i += 1
            j -= 1

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/put-marbles-in-bags">2551. Put Marbles in Bags</a>
  </div>
</div>
<!-- Array END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>