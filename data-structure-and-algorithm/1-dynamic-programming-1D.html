<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax/tex-chtml.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- Dynamic Programming 1D BEGIN -->
<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Dynamic Programming 1D</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#dynamic-programming-1d">Climbing Stairs</a></li>
      <li><a href="#dynamic-programming-1d">Decode Ways</a></li>
      <li><a href="#dynamic-programming-1d">Word Break</a></li>
      <li><a href="#dynamic-programming-1d">Word Break II</a></li>
      <li><a href="#dynamic-programming-1d">House Robber</a></li>
      <li><a href="#dynamic-programming-1d">House Robber II</a></li>
      <li><a href="#dynamic-programming-1d">Best Time to Buy and Sell Stock with Cooldown</a></li>
      <li><a href="#dynamic-programming-1d">Coin Change</a></li>
      <li><a href="#dynamic-programming-1d">Partition Equal Subset Sum</a></li>
      <li><a href="#dynamic-programming-1d">Min Cost Climbing Stairs</a></li>
      <li><a href="#dynamic-programming-1d">Maximum Profit in Job Scheduling</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Climbing Stairs (75/150)</h2>

<pre><code class="python">class Solution:
    def climbStairs(self, n: int) -> int:

        # n = 2 ? 2 (1+1, 2)
        # n = 3 ? 3 (1+1+1, 1+2, 2+1)

        # DP
        # dp[i] = number of ways to achieve i
        # dp[i] = dp[i-1] + dp[i-2]
        # Time O(n)
        # Space O(n)

        dp = [0 for _ in range(n+1)]
        if n == 1: 
            return 1
        dp[1], dp[2] = 1, 2

        for i in range(3, n+1):
            dp[i] = dp[i-1] + dp[i-2]

        return dp[n]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/climbing-stairs">70. Climbing Stairs</a> | <a href="https://neetcode.io/problems/climbing-stairs">Climbing Stairs</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Decode Ways (75/150)</h2>

<pre><code class="python">class Solution:
    def numDecodings(self, s: str) -> int:

        # 12 ? 2 (A, B and L)

        # DP
        # Let dp[i] = number of ways to decode s[:i]
        # dp[i] = dp[i] + dp[i-1] if s[i] != 0
        # dp[i] = dp[i] + dp[i-2] if 1 <= s[i-2:i] <= 26
        # dp[1] = 1 if s[0] != 0, 0 if s[0] == 0
        # Time O(n) n = len(s)
        # Space O(1)

        n = len(s)
        dp = [0 for _ in range(n+1)]
        dp[0] = 1
        if int(s[0]) == 0:
            dp[1] = 0
        else:
            dp[1] = 1

        for i in range(2,n+1):
            if int(s[i-1]) != 0:
                dp[i] += dp[i-1]
            if 10 <= int(s[i-2:i]) <= 26:
                dp[i] += dp[i-2]

        return dp[n]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/decode-ways">91. Decode Ways</a> | <a href="https://neetcode.io/problems/decode-ways">Decode Ways</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Word Break (75/150)</h2>

<pre><code class="python">class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        
        # applepie, [apple, pie] ? True
        # applepie, [app, pie] ? False
        # piepie, [app, pie] ? True

        # DP
        # dp[i] = whether s[i] can be constructed from wordDict
        # dp[i] = True if dp[i-len(w)] == True for all w in wordDict 
        # dp[0] = True
        # Time O(nm) n = len(s), m = len(wordDict)
        # Space O(n)

        n = len(s)
        dp = [False for _ in range(n+1)]
        dp[0] = True

        for i in range(1,n+1):
            for w in wordDict:
                if i - len(w) >= 0 and dp[i-len(w)] and s[i-len(w):i] == w:
                    dp[i] = True

        return dp[n]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/word-break">139. Word Break</a> | <a href="https://neetcode.io/problems/word-break">Word Break</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Word Break II (H)</h2>

<pre><code class="python">class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:

        # Let dp[i] = all possible outputs for s[:i+1]
        # At dp[i], scan "s" from right to left to check if 
        # any substring is in "wordDict"
        
        word_set = set(wordDict)
        n = len(s)

        dp = [[""] for _ in range(n+1)]

        # Time O(n**2)
        # Space O(n**2)
        for i in range(n):
            for j in range(i, -1, -1):
                if s[j:i+1] in word_set:
                    for sol in dp[j-1]:
                        dp[i].append(sol+" "+s[j:i+1])

        result = []
        for string in dp[n-1]:
            if len(string.strip().replace(" ", "")) == n:
                result.append(string.strip())

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/word-break-ii">140. Word Break II</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">House Robber (75/150)</h2>

<pre><code class="python">class Solution:
    def rob(self, nums: List[int]) -> int:

        # [1,2,3,4] ? 2+4=6
        # [2,0,3,4] ? 2+4=6

        # DP
        # dp[i] = max amount by robbing up to index i
        # dp[i] = max(dp[i-1], dp[i-2]+nums[i])
        # Time O(n) n = len(nums)
        # Space O(n)

        n = len(nums)
        dp = [0 for i in range(n+1)]

        for i in range(1, n+1):
            dp[i] = max(dp[i-1], dp[i-2]+nums[i-1])

        return dp[n]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/house-robber">198. House Robber</a> | <a href="https://neetcode.io/problems/house-robber">House Robber</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">House Robber II (75/150)</h2>

<pre><code class="python">class Solution:
    def rob(self, nums: List[int]) -> int:
        
        # [1,2,3,4] ? 2+4=6
        # [2,0,3,4] ? 2+3=5

        # DP
        # Consider two valid cases
        #   Don't rob first
        #   Don't rob last
        # dp[i] = max amount by robbing up to i
        # dp[i] = max(dp[i-1], dp[i-2]+nums[i])
        # Time O(n) n = len(nums)
        # Space O(n)

        def helper(nums):
            n = len(nums)
            dp = [0 for _ in range(n+1)]

            for i in range(1, n+1):
                dp[i] = max(dp[i-1], dp[i-2]+nums[i-1])

            return dp[n]

        if len(nums) == 1:
            return nums[0]
        return max(helper(nums[1:]), helper(nums[:-1]))</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/house-robber-ii">213. House Robber II</a> | <a href="https://neetcode.io/problems/house-robber-ii">House Robber II</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Best Time to Buy and Sell Stock with Cooldown (150)</h2>

<pre><code class="python">class Solution:
    def maxProfit(self, prices: List[int]) -> int:

        # DP
        # Ordering is buy, sell, cooldown
        # b[i] = max profit at i where last action is buy
        #   If buy at i, must sold at i - 2 and cooldown at i - 1
        #   If not buy at i, b[i] = b[i-1]
        #   b[i] = max(b[i-1], s[i-2]-prices[i])
        # s[i] = max profit at i where last action is sell
        #   If sell at i, must bought at i - 1
        #   If not sell at i, s[i] = s[i-1]
        #   s[i] = max(s[i-1], b[i-1]-prices[i])
        # Time O(n)
        # Space O(n)

        n = len(prices)
        if n == 1:
            return 0

        b, s = [-math.inf] * n, [0] * n

        for i in range(n):
            s[i] = max(s[i-1], b[i-1]+prices[i])
            b[i] = max(b[i-1], s[i-2]-prices[i])

        return s[-1]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown">309. Best Time to Buy and Sell Stock with Cooldown</a> | <a href="https://neetcode.io/problems/buy-and-sell-crypto-with-cooldown">Best Time to Buy and Sell Stock with Cooldown</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Coin Change (75/150)</h2>

<pre><code class="python">class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:

        # [1,2], 3 ? 2 ([1,2])
        # [1,2], 4 ? 2 ([2,2])

        # dp[i] = min number of coins to make up amount i
        # dp[i] = min(dp[i-c1]+1, dp[i-c2]+1, ...) for all c in coins
        # dp[0] = 0
        # Time O(nm) n = amount, m = len(coins)
        # Space O(n)

        n, m = amount, len(coins)
        dp = [0 for _ in range(n+1)]

        for i in range(1, n+1):
            cnt = math.inf
            for j in coins:
                if i - j >= 0:
                    cnt = min(cnt, dp[i-j])
            dp[i] = cnt + 1

        if dp[n] == math.inf:
            return -1
        return dp[n]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/coin-change">322. Coin Change</a> | <a href="https://neetcode.io/problems/coin-change">Coin Change</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Partition Equal Subset Sum (150)</h2>

<pre><code class="python">class Solution:
    def canPartition(self, nums: List[int]) -> bool:

        # nums = [1,1] => True
        # nums = [1] => False
        # nums = [] => Invalid

        # DP 
        # Check if (total_sum//2) can be created 
        # dp[i] = whether sum i can be created
        # Time O(nm) n = sum(nums) m = len(nums)
        # Space O(n)

        total_sum = sum(nums)
        if total_sum % 2 != 0:
            return False

        subset_sum = total_sum // 2
        dp = [False for _ in range(subset_sum+1)]
        dp[0] = True

        
        for j in nums:
            for i in range(subset_sum, j-1, -1):
                dp[i] = dp[i] or dp[i-j]

        return dp[subset_sum]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/partition-equal-subset-sum">416. Partition Equal Subset Sum</a> | <a href="https://neetcode.io/problems/partition-equal-subset-sum">Partition Equal Subset Sum</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Min Cost Climbing Stairs (150)</h2>

<pre><code class="python">class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        
        # cost = [0, 0, 0] => 0
        # cost = [1, 2, 3] => 2
        # cost = [1, 2, 3, 4] => 1+3=4
        # cost = [] => 0
        # cost = [1] => 0
        # cost = [1, 2] => 0

        # DP
        # dp[n] = min cost to reach index n
        # dp[n] = min(dp[n-1]+cost[n-1], dp[n-2]+cost[n-2])
        # dp[1] = 0
        # dp[2] = 0
        # Time O(n) n = len(cost)
        # Space O(n)

        n = len(cost)
        dp = [0 for _ in range(n+1)]
        
        for i in range(2, n+1):
            dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])

        return dp[n]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/min-cost-climbing-stairs">746. Min Cost Climbing Stairs</a> | <a href="https://neetcode.io/problems/min-cost-climbing-stairs">Min Cost Climbing Stairs</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-1d">
  <div class="card-body">
    <h2 class="card-title">Maximum Profit in Job Scheduling (H)</h2>

<pre><code class="python">class Solution:
    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:

        # Sort jobs based on start time
        # At each interval, there are two choices
        #   Skip the current job and move to next job
        #   Execute current job and move to next non-conflicting job
        # Let dp[i] = profit from jobs from index i to n
        #   If skip job i, dp[i] = dp[i+1]
        #   If execute job i, dp[i] = profit at i + d[next_i]
        # Use binary search to find next_i since start time is sorted

        # Time O(nlogn)
        intervals = []
        for x, y, z in zip(startTime, endTime, profit):
            intervals.append([x,y,z])

        intervals.sort(key=lambda x: x[0])
        
        n = len(intervals)
        dp = [0] * (n+1)

        def binary_search(i, intervals):

            end_t = intervals[i][1]
            left = 0
            right = len(intervals) - 1
            next_i = len(intervals)
            
            while left <= right:
                mid = (left+right) // 2
                if intervals[mid][0] >= end_t:
                    right = mid - 1
                    next_i = mid
                else:
                    left = mid + 1
                
            return next_i

        # Time O(nlogn)
        # Space O(n)
        for i in range(n-1, -1, -1):
            next_i = binary_search(i, intervals)
            print(f"{i}, {next_i}")
            if next_i == -1:
                dp[i] = max(dp[i+1], intervals[i][2])
            else:
                dp[i] = max(dp[i+1], intervals[i][2]+dp[next_i])

        return dp[0]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/maximum-profit-in-job-scheduling">1235. Maximum Profit in Job Scheduling</a>
  </div>
</div>
<!-- Dynamic Programming 1D END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>