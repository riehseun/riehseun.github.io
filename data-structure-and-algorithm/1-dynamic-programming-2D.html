<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax/tex-chtml.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- Dynamic programming 2D BEGIN -->
<div class="card mb-4" id="dynamicprogramming">
  <div class="card-body">
    <h2 class="card-title">Dynamic programming 2D</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#dynamic-programming-2d">Regular Expression Matching</a></li>
      <li><a href="#dynamic-programming-2d">Unique Paths</a></li>
      <li><a href="#dynamic-programming-2d">Edit Distance</a></li>
      <li><a href="#dynamic-programming-2d">Interleaving String</a></li>
      <li><a href="#dynamic-programming-2d">Distinct Subsequences</a></li>
      <li><a href="#dynamic-programming-2d">Burst Balloons</a></li>
      <li><a href="#dynamic-programming-2d">Target Sum</a></li>
      <li><a href="#dynamic-programming-2d">Coin Change II</a></li>
      <li><a href="#dynamic-programming-2d">Longest Common Subsequence</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-2d">
  <div class="card-body">
    <h2 class="card-title">Regular Expression Matching (150)</h2>

<pre><code class="python"># DP
        # Time O(nm) n = len(s), m = len(p)
        # Space O(nm)

        n, m = len(s), len(p)
        dp = [[" "]*(m+1) for _ in range(len(s)+1)]
        
        # An empty pattern always mathes an empty string
        dp[0][0] = "Y"

        # First row for a pattern to match an empty char in string
        for j in range(1, len(p)+1):
            # For * to match an empty string, everything up to the last
            # two characters needs to match and the preceeding char
            # can be anything
            if p[j-1] == "*":
                if dp[0][j-2] == "Y":
                    dp[0][j] = "Y"
                else:
                    dp[0][j] = "N"
            else:
                dp[0][j] = "N"

        # First column for an empty char in pattern to match any char
        # in string
        for i in range(1, len(s)+1):
            dp[i][0] = "N"

        for i in range(1, len(s)+1):
            for j in range(1, len(p)+1):
                # If two characters match, Then two substrings
                # without these two characters will be the result
                if s[i-1] == p[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    if p[j-1] == "*":
                        # In this case, p[j-2] is important
                        # This mean any character is repeated zero
                        # or more times, so the pattern will match
                        # all possible scenarios

                        #       . * . . a *
                        #     0 1 2 3 4 5 6
                        #   0 Y N Y N N N N
                        # a 1 N Y Y Y N N N
                        if p[j-2] == s[i-1] or p[j-2] == ".":
                            if (dp[i][j-2] == "Y" \
                                or dp[i-1][j-2] == "Y" \
                                or dp[i-1][j] == "Y"):
                                dp[i][j] = "Y"
                            else:
                                dp[i][j] = "N"
                        else:
                            dp[i][j] = dp[i][j-2]
                    # In this case, pattern can be any character to
                    # satisfy this condition: s[j-1] == p[j-1]
                    elif p[j-1] == ".":
                        dp[i][j] = dp[i-1][j-1]
                    else:
                        dp[i][j] = "N"

        if dp[n][m] == "Y":
            return True
        else:
            return False</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/regular-expression-matching">10. Regular Expression Matching</a> | <a href="https://neetcode.io/problems/regular-expression-matching">Regular Expression Matching</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-2d">
  <div class="card-body">
    <h2 class="card-title">Unique Paths (75/150)</h2>

<pre><code class="python">class Solution:
    def uniquePaths(self, m: int, n: int) -> int:

        # Let dp[i][j] = number of unique path at i and j
        # dp[i][j] = dp[i-1][j] + dp[i][j-1]
        # Time O(nm)
        # Space O(nm)

        dp = [[0]*(n+1) for _ in range(m+1)]
        
        for i in range(1, m+1):
            for j in range(1, n+1):
                if i == 1 and j == 1:
                    dp[i][j] = 1
                else:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1]

        return dp[m][n]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/unique-paths">62. Unique Paths</a> | <a href="https://neetcode.io/problems/count-paths">Unique Paths</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-2d">
  <div class="card-body">
    <h2 class="card-title">Edit Distance (150)</h2>

<pre><code class="python"># DP
        # Time O(nm) n = len(word1), m = len(word2)
        # Space O(nm)

        # "horse" and "ros"
        #   0 1 2 3 4 5
        # 0 0 1 2 3 4 5
        # 1 1
        # 2 2
        # 3 3

        n, m = len(word1), len(word2)

        if n == 0:
            return len(word2)
        if m == 0:
            return len(word1)

        dp = [[0]*(m+1) for _ in range(n+1)]
        for i in range(1, n+1):
            dp[i][0] = dp[i-1][0] + 1
        for j in range(1, m+1):
            dp[0][j] = dp[0][j-1] + 1

        for i in range(1, n+1):
            for j in range(1, m+1):
                if word1[i-1] == word2[j-1]:\
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+1)

        return dp[n][m]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/edit-distance">72. Edit Distance</a> | <a href="https://neetcode.io/problems/edit-distance">Edit Distance</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-2d">
  <div class="card-body">
    <h2 class="card-title">Interleaving String (150)</h2>

<pre><code class="python">class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:

        # Check if s3 up to k can be formed by s1 and s2 up to i and j
        # If s1[i] != s3[k] and s2[j] != s3[k], dp[i][j] = False
        # If s1[i] == s3[k] or s2[j] == s3[k]
        # Time O(nm) n = len(s1), m = len(s2)
        # Space O(nm)

        n, m = len(s1), len(s2)
        if len(s3) != m + n:
            return False 

        dp = [[False]*(m+1) for _ in range(n+1)]
        dp[0][0] = True

        for i in range(n+1):
            for j in range(m+1):
                if i == 0 and j != 0:
                    dp[i][j] = dp[i][j-1] and s2[j-1] == s3[i+j-1]
                if i != 0 and j == 0:
                    dp[i][j] = dp[i-1][j] and s1[i-1] == s3[i+j-1]
                if i != 0 and j != 0:
                    a = dp[i][j-1] and s2[j-1] == s3[i+j-1]
                    b = dp[i-1][j] and s1[i-1] == s3[i+j-1]
                    dp[i][j] = a or b

        return dp[n][m]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/interleaving-string">97. Interleaving String</a> | <a href="https://neetcode.io/problems/interleaving-string">Interleaving String</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-2d">
  <div class="card-body">
    <h2 class="card-title">Distinct Subsequences (150)</h2>
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        
        # DP
        # dp[i][j]
        # Time O(nm) n = len(s), m = len(t)
        # Space O(nm)
        
        # Ex. babgbag bag
        #   0 1 2 3 4 5 6 7
        # 0 1 1 1 1 1 1 1 1
        # 1 0 
        # 2 0
        # 3 0

        n, m = len(s), len(t)

        dp = [[0]*(m+1) for _ in range(n+1)]
        for i in range(0, n+1):
            dp[i][0] = 1
 
        for i in range(1, n+1):
            for j in range(1, m+1):
                if s[i-1] == t[j-1]:
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j]

        return dp[n][m]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/distinct-subsequences">115. Distinct Subsequences</a> | <a href="https://neetcode.io/problems/count-subsequences">Distinct Subsequences</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-2d">
  <div class="card-body">
    <h2 class="card-title">Burst Balloons (150)</h2>

<pre><code class="python">class Solution:
    def maxCoins(self, nums: List[int]) -> int:

        # DP
        # dp[i][j] max gain by bursting on interval i, j
        # Time O(n**3)
        # Space O(n*2)

        nums = [1] + nums + [1]
        n = len(nums)
        dp = [[0]*n for _ in range(n)]

        for i in range(n-2, 0, -1):
            for j in range(i, n-1):
                for k in range(i, j+1):
                    gain = nums[i-1] * nums[k] * nums[j+1]
                    remain = dp[i][k-1] + dp[k+1][j]
                    dp[i][j] = max(remain+gain, dp[i][j])

        return dp[1][n-2]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/burst-balloons">312. Burst Balloons</a> | <a href="https://neetcode.io/problems/burst-balloons">Burst Balloons</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-2d">
  <div class="card-body">
    <h2 class="card-title">Target Sum (150)</h2>

<pre><code class="python">class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        
        # Let P = positive subset, N = negative subset
        # Then, sum(P) + sum(N) = sum(nums)
        # We want subsets such that, sum(P) - sum(N) = target
        # Then sum(P) = (sum(nums)+target) // 2
        # dp[i][j] = number of ways to have sum j with first i nums
        # Time O(nm) n = len(nums) m = target
        # Space O(nm)

        if (sum(nums)+target) % 2 != 0 or (sum(nums)+target) < 0:
            return 0   

        m = (sum(nums)+target) // 2
        n = len(nums)
        dp = [[0]*(m+1) for _ in range(n+1)]
        dp[0][0] = 1

        for i in range(1, n+1):
            for j in range(m+1):
                dp[i][j] = dp[i-1][j] 
                if j >= nums[i-1]:
                    dp[i][j] = dp[i][j] + dp[i-1][j-nums[i-1]]
                 
        return dp[n][m]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/target-sum">494. Target Sum</a> | <a href="https://neetcode.io/problems/target-sum">Target Sum</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-2d">
  <div class="card-body">
    <h2 class="card-title">Coin Change II (150)</h2>

<pre><code class="python">class Solution:
    def change(self, amount: int, coins: List[int]) -> int:

        # DP
        # Let dp[i][j] number of ways to make up amount j using coins from i
        # dp[i][0] = 1 amount 0 can be made by not selecting any coins
        # If coins[i] > j, coin i cannot be used. dp[i][j] = dp[i-1][j]
        # Else, dp[i][j] = dp[i-1][j] + dp[i][j-coins[i]]
        # Time O(nm)
        # Space O(nm)

        n, m = len(coins), amount
        dp = [[0]*(m+1) for _ in range(n+1)]
        for i in range(n):
            dp[i][0] = 1

        for i in range(n):
            for j in range(1, m+1):
                if coins[i] > j:
                    dp[i][j] = dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j] + dp[i][j-coins[i]]

        return dp[n-1][m]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/coin-change-ii">518. Coin Change II</a> | <a href="https://neetcode.io/problems/coin-change-ii">Coin Change II</a>
  </div>
</div>

<div class="card mb-4" id="dynamic-programming-2d">
  <div class="card-body">
    <h2 class="card-title">Longest Common Subsequence (75/150)</h2>

<pre><code class="python">class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        
        # DP 
        #     c r a b t
        #   0 0 0 0 0 0
        # c 0 1 1 1 1 1 
        # a 0 1 1 2 2 2
        # t 0 1 1 2 2 3
        # Let dp[i][j] length of common subseq up to i and j
        # dp[i][j] = dp[i-1][j-1] + 1 if char is same
        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) o/w
        # Time O(nm)
        # Space O(nm)

        n, m = len(text1), len(text2)
        dp = [[0]*(m+1) for _ in range(n+1)]
        
        for i in range(1, n+1):
            for j in range(1, m+1):
                if text1[i-1] == text2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])

        return dp[n][m]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/longest-common-subsequence">1143. Longest Common Subsequence</a> | <a href="https://neetcode.io/problems/longest-common-subsequence">Longest Common Subsequence</a>
  </div>
</div>
<!-- Dynamic programming 2D END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>