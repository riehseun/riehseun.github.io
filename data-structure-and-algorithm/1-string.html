<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax/tex-chtml.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- String BEGIN -->
<div class="card mb-4" id="string">
  <div class="card-body">
    <h2 class="card-title">String</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#string-">Roman to Integer</a></li>
      <li><a href="#string-">Longest Common Prefix</a></li>
      <li><a href="#string-">Group Anagrams</a></li>
      <li><a href="#string-">Valid Number</a></li>
      <li><a href="#string-">Text Justification</a></li>
      <li><a href="#string-">Valid Anagram</a></li>
      <li><a href="#string-">Group Shifted Strings</a></li>
      <li><a href="#string-">Encode and Decode Strings</a></li>
      <li><a href="#string-">Integer to English Words</a></li>
      <li><a href="#string-">Valid Word Abbreviation</a></li>
      <li><a href="#string-">Valid Parenthesis String</a></li>
      <li><a href="#string-">Fizz Buzz</a></li>
      <li><a href="#string-">Special Binary String</a></li>
      <li><a href="#string-">Custom Sort String</a></li>
      <li><a href="#string-">Minimum Add to Make Parentheses Valid</a></li>
      <li><a href="#string-">Merge Strings Alternately</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Roman to Integer (E)</h2>

<pre><code class="python">class Solution:
    def romanToInt(self, s: str) -> int:
        """
        :type s: str
        :rtype: int
        """

        # Dictionary to store symbol-value mapping
        mapping = {
            'I':1,
            'V':5,
            'X':10,
            'L':50,
            'C':100,
            'D':500,
            'M':1000, 
            "IV":4, 
            "IX":9, 
            "XL":40, 
            "XC":90, 
            "CD":400, 
            "CM":900}
        
        i = 0
        result = 0
        
        # Time O(1) 
        #   3999 is maximum for Roman numbers
        # Space O(1)
        while i < len(s):
            if i < len(s) - 1 and s[i] + s[i+1] in mapping:
                result += mapping[s[i]+s[i+1]]
                i += 2
            else:
                result += mapping[s[i]]
                i += 1

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/roman-to-integer">13. Roman to Integer</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Longest Common Prefix (M)</h2>

<pre><code class="python">class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:

        # Fix first string  
        #   Compare each char in first string
        #   against each char in all other strings

        i = 0
        break_other_loop = False

        # Time O(kn)
        #   k = length of first char  
        #   n = len(strs)
        # Space O(1)
        while i < len(strs[0]):

            for j in range(1, len(strs)): 
                if i >= len(strs[j]) or strs[j][i] != strs[0][i]:
                    break_other_loop = True
                    break

            if break_other_loop:
                break
            i += 1

        return strs[0][:i]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/longest-common-prefix">14. Longest Common Prefix</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Group Anagrams (75/150)</h2>

<pre><code class="python">class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:

        # Find a representation for a set of anagrams
        # Use a tuple of each char count and use it 
        # as a key in dictionary

        strs_dict = defaultdict(list)

        # Time O(nm)
        #   n = len(strs)
        #   m = length of char
        # Space O(n)

        for s in strs:
            rep = [0] * 26
            for c in s:
                index = ord('a') - ord(c)
                rep[index] += 1
            strs_dict[tuple(rep)].append(s)

        result = []
        for k, v in strs_dict.items():
            result.append(v)

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/group-anagrams">49. Group Anagrams</a> | <a href="https://neetcode.io/problems/anagram-groups">Group Anagrams</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Valid Number (H)</h2>

<pre><code class="python">class Solution:
    def isNumber(self, s: str) -> bool:

        # Each char must be digit, sign, exponent, dot
        # Input cannot end with a sign or an exponent
        # There must be at least one digit in the input
        # If there is a sign, it must be either
        #   First character in the input
        #   First character after an exponent
        # There cannot be more than one exponent in the input
        # If an exponent exists, a digit must have existed beforehand
        # There cannot be more than one dot in the input
        # If a dot exists, there should be no exponent beforehand
        
        digit_exist, exponent_exist, dot_exist = False, False, False

        # Time O(n) 
        #   n = len(s)
        # Space O(1)
        for i, c in enumerate(s):
            if c.isdigit():
                digit_exist = True
            elif c == "-" or c == "+":
                if i > 0 \
                    and (s[i-1] != "e" and s[i-1] != "E"):
                    return False
                if i == len(s) - 1:
                    return False
            elif c == "e" or c == "E":
                if exponent_exist:
                    return False
                if not digit_exist:
                    return False
                if i == len(s) - 1:
                    return False
                exponent_exist = True
            elif c == ".":
                if dot_exist:
                    return False
                if exponent_exist:
                    return False
                dot_exist = True
            else:
                return False

        if not digit_exist:
            return False
        
        return True</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/valid-number">65. Valid Number</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Text Justification (H)</h2>

<pre><code class="python">class Solution:
    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:

        # Compute running sum of available spaces
        #   If length of accumulated text > available spaces left
        #   then, insert the word in the next line
        # Each word in each line must have equal space in between
        #   Number of splits = number of words - 1
        #   Number of spaces in each split = spaces // number of splits 
        #   Extra spaces = spaces % number of splits

        result = []
        char_count, word_length, word_array = 0, 0, []
        
        # Time O(n)
        #   n = len(words)
        # Space O(n)
        #   word_array may contain entire words in worst case
        for word in words:
            
            if char_count + len(word) <= maxWidth:
                char_count += len(word) + 1
                word_length += len(word)
                word_array.append(word)
            else:
                if len(word_array) == 1:
                    extra_spaces = maxWidth - word_length
                    text = word_array[0] + " " * extra_spaces 
                    result.append(text)
                else:
                    num_splits = len(word_array) - 1
                    num_spaces = (maxWidth-word_length) // num_splits
                    extra_spaces = (maxWidth-word_length) % num_splits

                    text = ""
                    for w in word_array[:-1]:
                        text += w
                        text += " " * num_spaces
                        if extra_spaces > 0:
                            text += " " 
                            extra_spaces -= 1
                    text += word_array[-1]
                    result.append(text)
                
                char_count = len(word) + 1
                word_length = len(word)
                word_array = [word]
                
        # Process remaining words in word_array
        text = ""
        for w in word_array:
            text += w
            if len(text) < maxWidth:
                text += " "
        text += " " * (maxWidth-len(text))
        result.append(text)

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/text-justification">68. Text Justification</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Valid Anagram (75/150)</h2>

<pre><code class="python">class Solution:
    def isAnagram(self, s: str, t: str) -> bool:

        # s = "abc", t = "cab" ? True
        # s = "aab", t = "aba" ? True
        # s = "aab", t = "abb" ? False

        # Count occurance of each char in s and t 
        # Compare the occurances
        # Time O(n+m) n = len(s), m = len(t)
        # Space O(n+m) = O(1) up to 26 chars

        chars_s, chars_t = defaultdict(int), defaultdict(int)

        for c in s:
            chars_s[c] += 1

        for c in t:
            chars_t[c] += 1

        return chars_s == chars_t</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/valid-anagram">242. Valid Anagram</a> | <a href="https://neetcode.io/problems/is-anagram">Valid Anagram</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Group Shifted Strings (M)</h2>

<pre><code class="python">class Solution:
    def groupStrings(self, strings: List[str]) -> List[List[str]]:

        # If strings are either right shift or left shift of each other,
        # they should be in the same group
        # Compute unique identifier for each group
        #   Shift all chars in string until the first char is "a"
        #   Use "ord" to convert char to num
        #   Mod by 26 to handle circular shift

        groups = defaultdict(list)

        # Time O(n)
        #   n = total number of characters in input list
        # Space O(n)
        #   Storing all chars in input list in dictionary
        for string in strings:

            new_string = ""
            diff_from_a = ord(string[0]) - ord("a")
            for i, c in enumerate(string[1:]):
                new_string += chr((ord(c)-diff_from_a)%26)
            
            groups[new_string].append(string)

        return list(groups.values())</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/group-shifted-strings">249. Group Shifted Strings</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Encode and Decode Strings (75/150)</h2>

<pre><code class="python">class Codec:

    # Encode string like this
    # Ex. ["neet", "code", "love"] => 4|neet5|code6|love
    # Decode
    #   Find the first |
    #   Chars before the first | is a number representing the length
    #   Move by that length after the first |
    #   Repeat 

    # Time O(n)
    #   n = number of strings
    # Space O(nm) 
    #   m = total length of strings
    def encode(self, strs: List[str]) -> str:
        """Encodes a list of strings to a single string.
        """
        
        encoded_string = ""
        for s in strs:
            encoded_string += str(len(s)) + "|" + s
        return encoded_string

    def decode(self, s: str) -> List[str]:
        """Decodes a single string to a list of strings.
        """

        decoded_string = []
        i, j = 0, 0

        # 4|neet5|code6|love
        while j < len(s):
            if s[j] == "|":
                length = int(s[i:j])
                decoded_string.append(s[j+1:j+1+length])
                i = j + 1 + length
                j = i
            j += 1

        return decoded_string


# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.decode(codec.encode(strs))</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/encode-and-decode-strings">271. Encode and Decode Strings</a> | <a href="https://neetcode.io/problems/string-encode-and-decode">Encode and Decode Strings</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Integer to English Words (H)</h2>

<pre><code class="python">class Solution:
    def numberToWords(self, num: int) -> str:

        # Create mapping for ones, tens, thousands
        # Keep diving the number by 1000

        # Corner case
        if num == 0:
            return "Zero"

        ones = {
            0: "Zero",
            1: "One",
            2: "Two",
            3: "Three",
            4: "Four",
            5: "Five",
            6: "Six",
            7: "Seven",
            8: "Eight",
            9: "Nine",
            10: "Ten",
            11: "Eleven",
            12: "Twelve",
            13: "Thirteen",
            14: "Fourteen",
            15: "Fifteen",
            16: "Sixteen",
            17: "Seventeen",
            18: "Eighteen",
            19: "Nineteen"
        }

        tens = {
            2: "Twenty",
            3: "Thirty",
            4: "Forty",
            5: "Fifty",
            6: "Sixty",
            7: "Seventy",
            8: "Eighty",
            9: "Ninety",
        }

        thousands = {
            0: "",
            1: "Thousand",
            2: "Million",
            3: "Billion"
        }

        total_result = ""
        index = 0

        # Time O(logn)
        #   Dividing num by 1000 in each iteration
        # Space O(1)
        #   Ignoring space for result
        while num:

            result = ""
            quotient = num // 1000
            remainder = num % 1000
            
            if remainder >= 100:
                result += ones[remainder//100] + " Hundred "
                remainder %= 100

            if 100 > remainder >= 20:
                result += tens[remainder//10] + " "
                remainder %= 10

            if 20 > remainder > 0:
                result += ones[remainder] + " "

            if result:
                result += thousands[index] + " "
            index += 1

            num = quotient
            total_result = result + total_result

        return total_result.strip()</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/integer-to-english-words">273. Integer to English Words</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Valid Word Abbreviation (E)</h2>

<pre><code class="python">class Solution:
    def validWordAbbreviation(self, word: str, abbr: str) -> bool:

        # Iterate word and abbr 
        # For abbr, differentate letters and digits
        # If numbers are found, move indices based on that number
        # If any indices between word and abbr don't match, return False

        n, m = len(word), len(abbr)
        i, j = 0, 0

        # Time O(max(n,m))
        #   n = len(word)
        #   m = len(abbr)
        # Space O(1)
        while i < n and j < m:

            digit = ""
            while j < m and abbr[j].isdigit():
                digit += abbr[j]
                j += 1
            if digit:
                # Check if leading zeros
                if digit.startswith("0"):
                    return False
                i += int(digit)
            else:
                # Check if char matches in each index
                if word[i] != abbr[j]:
                    return False
                i += 1
                j += 1

        return i == n and j == m</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/valid-word-abbreviation">408. Valid Word Abbreviation</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Valid Parenthesis String (150)</h2>

<pre><code class="python">class Solution:
    def checkValidString(self, s: str) -> bool:

        # s = "(**)))" => True
        # s = "())*" => False
        
        # Run pointer forward
        # Treat * as (, check number of open and closing parenthesis 
        # Run pointer backward
        # Treat * as ) 
        # Time O(n) n = len(s)
        # Space O(1)

        num, i = 0, 0

        while i < len(s):
            if s[i] == "(" or s[i] == "*":
                num += 1
            if s[i] == ")":
                num -= 1
            if num < 0:
                return False
            i += 1

        i, num = len(s) - 1, 0

        while i >= 0:
            if s[i] == ")" or s[i] == "*":
                num += 1
            if s[i] == "(":
                num -= 1
            if num < 0:
                return False
            i -= 1

        return True</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/valid-parenthesis-string">678. Valid Parenthesis String</a> | <a href="https://neetcode.io/problems/valid-parenthesis-string">Valid Parenthesis String</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Fizz Buzz (M)</h2>

<pre><code class="python">class Solution:
    def fizzBuzz(self, n: int) -> List[str]:

        # Follow the rules
        
        result = []

        # Time O(n)
        # Space O(1)
        #   Ignoring space for result
        for i in range(1,n+1):
            if i % 3 == 0 and i % 5 == 0:
                result.append("FizzBuzz")
            elif i % 3 == 0 and i % 5 != 0:
                result.append("Fizz")
            elif i % 3 != 0 and i % 5 == 0:
                result.append("Buzz")
            else:
                result.append(str(i))

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/fizz-buzz">412. Fizz Buzz</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Special Binary String (H)</h2>

<pre><code class="python">class Solution:
    def makeLargestSpecial(self, s: str) -> str:

        # Find all special substrings
        # For each special substring, recursively find chilren special substrings
        #   Sort children to build largest result
        # In each substring, first char is always 1 and last char is always 0

        # Time O(n**2)
        #   n = len(s)
        #   Recursion will take max n
        # Space O(n)

        substrings, start, count = [], 0, 0
        
        for i, c in enumerate(s):
            if c == "1":
                count += 1
            else:
                count -= 1

            if count == 0:
                substrings.append("1"+self.makeLargestSpecial(s[start+1:i])+"0")
                start = i + 1

        substrings.sort(reverse=True)

        return "".join(substrings)</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/special-bit-manipulation-string">761. Special Binary String</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Custom Sort String (M)</h2>

<pre><code class="python">class Solution:
    def customSortString(self, order: str, s: str) -> str:

        # For each char in s, find its ordering 
        #   Store frequencies of each char in s
        #   Go through each char in order and see if it 
        #   is in frequencies hash table

        # Time O(n) 
        #   n = len(s)
        # Space O(n)
        frequencies = defaultdict(int)
        for c in s:
            frequencies[c] += 1

        result = ""
        for c in order:
            if c in frequencies:
                result += frequencies[c] * c

        # Find char in s, that is not in order
        for key, val in frequencies.items():
            if key not in set(order):
                result += val * key 

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/custom-sort-string">791. Custom Sort String</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Minimum Add to Make Parentheses Valid (M)</h2>

<pre><code class="python">class Solution:
    def minAddToMakeValid(self, s: str) -> int:

        # Count number of mismatched parenthesis
        # Count number of opening and closing parenthesis separately
        # Decrease opening count when matching closing is found

        opening_count, closing_count = 0, 0

        # Time O(n)
        #   n = len(s)
        # Space O(1)
        for c in s:
            if c == "(":
                opening_count += 1
            if c == ")":
                if opening_count > 0:
                    opening_count -= 1
                else:
                    closing_count += 1

        return opening_count + closing_count</code></pre>
  </div>
  <div class="card-footer text-muted">
    <a href="https://leetcode.com/problems/minimum-add-to-make-parentheses-valid">921. Minimum Add to Make Parentheses Valid</a>
  </div>
</div>

<div class="card mb-4" id="string-">
  <div class="card-body">
    <h2 class="card-title">Merge Strings Alternately (E)</h2>

<pre><code class="python">class Solution:
    def mergeAlternately(self, word1: str, word2: str) -> str:

        # Iterate both words using two pointers

        i, j, result = 0, 0, ""
        w1, w2 = list(word1), list(word2) 

        # Time O(max(n,m))
        #   n = len(word1)
        #   m = len(word2)
        # Space O(1)
        #   Ignoring space for result

        while i < len(w1) and j < len(w2):
            result += w1[i]
            result += w2[j]
            i += 1
            j += 1

        if i < len(w1):
            result += "".join(w1[i:])

        if j < len(w2):
            result += "".join(w2[j:])

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/merge-strings-alternately">1768. Merge Strings Alternately</a>
  </div>
</div>
<!-- String END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>