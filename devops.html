<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="Seungmoon's DevOps Engineering Blog">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="Python, Groovy, Kubernetes, Docker, Jenkins, Terraform, Bash">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="css/bootstrap.min.css" rel="stylesheet">
<link href="css/monokai-sublime.css" rel="stylesheet">
<link href="css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="js/jquery.min.js"></script>
<script src="js/bootstrap.bundle.min.js"></script>
<script src="js/highlight.pack.js"></script>
<script type="text/javascript" src="js/include_html.js"></script>
<script type="text/javascript" src="js/site.js"></script>

</head>

<body>

<include src="header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- DevOps BEGIN -->
<div class="card mb-4" id="devops">
  <div class="card-body">
    <h2 class="card-title">DevOps</h2>
    <p class="card-text">DevOps culture aims to achieve efficiency in Software Development Life Cycle. Areas to improve in SDLC will differ by organizations but will generally include</p>
    <ul>
      <li>Deliever busniess requirement in agile fashion</li>
      <li>Reduce time to deploy</li>
      <li>Fast reponse to errors</li>
      <li>Robust security control</li>
      <li>Achieve target reliability</li>
    </ul>

    <h3 class="card-title">Qualifications</h3>
    <ul>
      <li>Branching strategy (Git flow, Github flow)</li>
      <li>Deployment and release strategy (Blue/Green, Canary, Dark Launch)</li>
      <li>Configuration (Salt, Ansible)</li>
      <li>Provisioning (Terraform)</li>
      <li>Containerization (Docker)</li>
      <li>Cloud computing (GCP, Azure, AWS)</li>
      <li>Container orchestration (Kubernetes)</li>
      <li>CI/CD, SDLC (Jenkins)</li>
      <li>Scripting (Bash, Python, Groovy)</li>
      <li>Code build (Maven, npm, gradle)</li>
      <li>Security (SonarQube, Veracode, TLS/SSL, AD/LDAP)</li>
    </ul>

    <ul class="list-unstyled mb-0">
      <li><a href="#devops-1">1. Cloud</a></li>
      <li><a href="#devops-2">2. Continuous Integration</a></li>
      <li><a href="#devops-3">3. Continuous Delivery</a></li>
      <li><a href="#devops-4">4. Microservice-centric architecture</a></li>
      <li><a href="#devops-5">5. Test Automation</a></li>
      <li><a href="#devops-6">6. Infrastructure/Configuration as Code</a></li>
      <li><a href="#devops-7">7. Continuous Monitoring</a></li>
      <li><a href="#devops-8">8. Release strategy</a></li>
      <li><a href="#devops-9">9. Security</a></li>
      <li><a href="#devops-10">10. Scaliability and Reliablity</a></li>
      <!-- <li><a href="#devops-11">11. Network</a></li> -->
      <li><a href="#devops-12">12. Agile</a></li>
      <li><a href="#devops-13">13. DevOps Culture and Metrics</a></li>
      <li><a href="#devops-14">14. DB Basic</a></li>
      <li><a href="#devops-15">15. Pipelining</a></li>
      <li><a href="#devops-16">16. Message vs. Event</a></li>
      <li><a href="#devops-17">17. Semantic Versioning (SemVer)</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="devops-1">
  <div class="card-body">
    <h2 class="card-title">1. Cloud</h2>
    <p class="card-text">Compute Power (three approaches)</p>
    <ul>
      <li>VM : Physical Hardware -> Operating System -> Hypervisor controller -> VM (App, OS, Virtual Hardware)</li>
      <li>Container : Physical Hardware -> Operating System -> Container Engine -> Container (App, dependencies)</li>
      <li>Serverless : Physical Hardware -> Operating System -> Serverless Runtime -> Function</li>
    </ul>
    <p class="card-text">4 types of computing resource management reponsibility by the users</p>
    <ul>
      <li>On-premises : Networking / Storage / Servers / Virtualization / OS / Middleware / Runtime / Data / Application</li>
      <li>Infrastructure as a Service : OS / Middleware / Runtime / Data / Application</li>
      <li>Platform as a Service : Data / Application</li>
      <li>Software as a Service : Everything is managed by Cloud Provider</li>
    </ul>
    <p class="card-text">Characteristics of cloud native</p>
    <ul>
      <li>Lightweight APIs</li>
      <li>Containers as standard deployment format</li>
      <li>Microservices</li>
      <li>Security at scale (Ex. Security tools provided by the Vendor)</li>
      <li>Reliability (Ex. Fully managed DB with high availability)</li>
      <li>Fast innovation (Ex. Serverless scales without managing infrastructure)</li>
    </ul>
  </div>
  <div class="card-footer text-muted">

  </div>
</div>

<div class="card mb-4" id="devops-2">
  <div class="card-body">
    <h2 class="card-title">2. Continuous Integration</h2>
    <p class="card-text">Continuous Integration means <strong>fast</strong> and <strong>automated</strong> feedback whenever there is code change</p>
    <img class="img-fluid" class="card-img-top" src="img/devops/devops-1-a.png" alt="Card image cap">
    <h3>Continuous Integration may include</h3>
    <ul>
      <li>builds</li>
      <li>unit test</li>
      <li>static analysis</li>
      <li>dynamic analysis</li>
      <li>package</li>
    </ul>
  </div>
  <div class="card-footer text-muted">

  </div>
</div>

<div class="card mb-4" id="devops-3">
  <div class="card-body">
    <h2 class="card-title">3. Continuous Delivery</h2>
    <p class="card-text">Continuous Delivery means fast deployment of new features to production</p>
    <img class="img-fluid" class="card-img-top" src="img/devops/devops-2-a.png" alt="Card image cap">
    <h3>Continuous Delivery requires</h3>
    <ul>
      <li>Externalized Configuration</li>
      <li>Automated tests</li>
      <li>Short build time (Failing slow tests!)</li>
      <li>Isolated and small pipeline steps</li>
      <li>Modularized code-base and parallel builds</li>
    </ul>
  </div>
  <div class="card-footer text-muted">

  </div>
</div>

<div class="card mb-4" id="devops-4">
  <div class="card-body">
    <h2 class="card-title">4. Microservice-centric architecture</h2>
    <p class="card-text">Example migration pattern from legacy system to modern architecture</p>
    <img class="img-fluid" class="card-img-top" src="img/devops/devops-3-a.png" alt="Card image cap">
    <h3>Monolithic</h3>
    <ul>
      <li>All components of application are colocated within a single unit</li>
      <li>Tied to a single technology stack
      <li>Data schema updates can be difficult since entire business logic shared a single DB</li>
      <li>Difficult to scale services independently</li>
    </ul>
    <h3>Microservice</h3>
    <ul>
      <li>Small, independent, and loosely coupled, thus can be deployed and scaled independently</li>
      <li>Impact of bugs from each component can be limited</li>
      <li>Each service is typically responsible for its own data</li>
      <li>Managing dependencies between components can be challenging (Ex. features of component A depends on features of component B)</li>
    </ul>
    <h3>Serverless</h3>
    <ul>
      <li>PaaS where business logic runs as functions</li>
      <li>Executions are event driven (http request, schedule, messages added to a queue, DB events, etc)</li>
      <li>Pros: only charged for what is used, automatic scaling</li>
      <li>Cons: there are execution timeouts of functions for each cloud provider, high frequency exeuctions can be cheaper in VM than in serverless</li>
    </ul>
  </div>
  <div class="card-footer text-muted">

  </div>
</div>

<div class="card mb-4" id="devops-5">
  <div class="card-body">
    <h2 class="card-title">5. Test Automation</h2>
    <ul>
      <li>Unit test - test each method/function</li>
      <li>Integration test  - test all components/modules of application togerther</li>
      <li>Behavior/Functional test  - test business logic</li>
      <li>Non-Functional test - test roll-back, roll-forward, performance/load/stress, penetration, compliance, etc</li>
      <li>User Acceptance test - test user interface</li>
    </ul>
    <p class="card-text">Volumn of each test should be the following</p>
    <img class="img-fluid" class="card-img-top" src="img/devops/devops-4-a.png" alt="Card image cap">
    <ul>
      <li>Because unit tests are for each method/function, there is no limit on how many tests you should have</li>
      <li>Integration/Functional tests should have enough size to catch potential errors at earlier stage</li>
      <li>UI tests will however frequently be modified based on changes on application layout, so this test should be small</li>
    </ul>
  </div>
  <div class="card-footer text-muted">

  </div>
</div>

<div class="card mb-4" id="devops-6">
  <div class="card-body">
    <h2 class="card-title">6. Infrastructure/Configuration as Code</h2>
    <p class="card-text">Infrastructure as Code</p>
    <ul>
      <li>No changes via GUI</li>
      <li>No live modification of instance (Immutable Server) - automating provisioning and recovery</li>
      <li>Versioning every infrastructure changes - making infrastructure reproducible</li>
    </ul>
    <p class="card-text">Configuration as Code</p>
    <ul>
      <li>Idempotency - operation results in the same outcome each time we apply</li>
    </ul>
  </div>
  <div class="card-footer text-muted">

  </div>
</div>

<div class="card mb-4" id="devops-7">
  <div class="card-body">
    <h2 class="card-title">7. Monitoring</h2>
    <ul>
      <li>Hook the test: Not only monitor availablity of services and resource comsumption, also periodically run tests to catch potential errors early</li>
      <li>Auto-correction upon finding problems: bring up the services that are down, clean up disk space by removing tmp files, safe or hard restart the server to clear memory, etc</li>
    </ul>
    <h3>Dickerson hierarchy of reliability</h3>
    <ul>
      <li><strong>monitoring</strong>: understand what is running in production. relibility is measured from customer perspective (there is no difference between system failing due to code bug or scaling issue from customers' point of view)</li>
      <li><strong>incident response</strong>: respond with urgency, rather than react. focus on clear communication and make information accessible</li>
      <li><strong>post-incident review</strong>: this is for pure learning purpose. it must be blameless. it is not document or report. understand that human errors do happen but they are not the cause of failures but symtom of larger problems</li>
      <li><strong>test and release procedures</strong>: </li>
      <li><strong>capacity planning</strong>: </li>
      <li><strong>development</strong>: </li>
      <li><strong>product</strong>: </li>
    </ul>
  </div>
  <div class="card-footer text-muted">

  </div>
</div>

<div class="card mb-4" id="devops-8">
  <div class="card-body">
    <h2 class="card-title">8. Release strategy</h2>
    <p class="card-text">Blue-Green</p>
    <ul>
      <li>Deployment strategy to avoid downtown during deployment</li>
      <li>Using IaC, deploy new instance "Green" (existing instance will be called "Blue")</li>
      <li>Run tests on Green instance</li>
      <li>Make "Green" the production instance - switch traffic from Blue to Green by re-mapping DNS to Green's IP address, remove Blue from load-balancer and add Green, etc</li>
    </ul>
    <p class="card-text">Carnary</p>
    <ul>
      <li>Similar to Blue-Green but redirect only subset of users instead of all users (choose users who are more active, etc)</li>
      <li>Both Blue and Green would be up during this time</li>
      <li>Great way to do capacity testing on new instance (can always roll-back by redirecting users to old instance)</li>
      <li>Management of multiple versions of Software is required</li>
    </ul>
    <p class="card-text">Dark-launching</p>
    <ul>
      <li>releasing production-ready features to subset of users prior to full release</li>
      <li>Feature toggle - run specific part of code based on configuration stored online</li>
      <li>Turn on features only for subset of users before releasing features to everybody</li>
    </ul>
  </div>
  <div class="card-footer text-muted">

  </div>
</div>

<div class="card mb-4" id="devops-9">
  <div class="card-body">
    <h2 class="card-title">9. Security</h2>
    <h3>SSL (Secure Sockets Layer)</h3>
    <ul>
      <li>Ensure that all data passed between Web server and Browsers remain private</li>
      <li>Web server creates private and public Key</li>
      <li>User submits Certificate Signing Request (CSR), which includes public key, to Certification Authority. CA then will issue SSL Certificate</li>
      <li>Web server will match user's SSL Certificate to its private Key</li>
      <li>When Broswer connects to secure site, it will check whether SSL Certificate is not expired, and it is isseud by Certification Authority that Browser trusts, and it is being used by the website for which it has been issued</li>
    </ul>

    <h3>SSL handshake</h3>
    <ul>
      <li>Client hello - client to server with TLS version</li>
      <li>Server hello - server to client with configuration it picked</li>
      <li>Server key exchange message - server to client with required information to generate pre-master secret</li>
      <li>Certificate request - server to client with certificate type, algorithm, and authorities</li>
      <li>Client certificate - client to server with certificate chain</li>
      <li>Client key exchange message - client to server so that a common key can be generated. Both sides then generate a master secret using pre-master secret, which is then used to generate symmetric key to encrypt session data</li>
    </ul>

    <h3>A layered approach to security</h3>
    <ul>
      <li>Data : attackers are always after this</li>
      <li>Application : free of vulnerabilities, application secrets in a secure storage medium</li>
      <li>Compute : secure access to VMs, implement endpoint protection, keep systems patched and current</li>
      <li>Networking : deny by default, implement secure connectivity to on-premises networks, restrict inbound internet access</li>
      <li>Perimeter : use distributed denial of service (DDoS) protection, use perimeter firewalls to identify malicious attacks</li>
      <li>Identity and access : use SSO and multi-factor authentication</li>
      <li>Physical security : access to physical data centre with compute machines</li>
    </ul>
    <h3>Examples of security breaches and attacks</h3>
    <ul>
      <li>Data : Exposing an encryption key or using weak encryption</li>
      <li>Application : Malicious code injection and execution. For example, SQL injection and cross-site scripting (XSS)</li>
      <li>Compute : Malware executing malicious code to compromise system</li>
      <li>Networking : Unnecessary open ports to the Internet. For example, leaving SSH or RDP open to virtual machines to leading brute-force attacks against your systems</li>
      <li>Perimeter : Denial-of-service (DoS) attacks</li>
      <li>Identity and access : Exposed credentials and toxic combinations of permissions and authorization</li>
      <li>Physical security : Unauthorized access to facilities</li>
    </ul>
    <p class="card-text">Authentication vs Authorization</p>
    <ul>
      <li>Authentication : process of establishing identity of a person</li>
      <li>Authorization : process of establishing what level of access an authenticated person has</li>
    </ul>
    <p class="card-text">Authentication strategy</p>
    <ul>
      <li>Single sign-on : access across applications is granted to a single identity/user, simplifying security model</li>
      <li>Multi-factor authentication : requires two or more elements for full authentication</li>
    </ul>
    <p class="card-text">Encryption</p>
    <ul>
      <li>Encryption : process of making data unreadable and unusable to unauthorized viewers</li>
      <li>Symmetric encryption : uses the same key to encrypt and decrypt the data</li>
      <li>Asymmetric encryption : uses public key and private key pair. Can use one key to encrypt but need both keys to decrypt. Ex. Transport Layer Security (TLS) used in HTTPS</li>
    </ul>
    <p class="card-text">Security concerns</p>
    <ul>
      <li>Input and outputs : Always validate input. Always use parameterized queries. Always encode your output</li>
      <li>Key Vault : Store connection strings, secrets, passwords, certificates, access policies, file locks, and automation scripts</li>
      <li>Framework : For example, Java/Javascript. Keep them updated</li>
      <li>Dependencies : Track vulnerabilities on your 3rd party dependencies</li>
    </ul>

    <p class="card-text">Active Directory - directory service implementation that provide authentication, group and user management, policy administration, etc. It supports both Kerberos and LDAP. It also provides SSO</p>
    <p class="card-text">LDAP (LightWeight Directory Acess Protocol) - open protocol used for directory service authentication</p>
    <p class="card-text">Relationship between AD and LDAP is similar to Apache and HTTP</p>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://medium.com/@kasunpdh/ssl-handshake-explained-4dabb87cdce">SSL Handshake explained</a> | <a href="https://www.varonis.com/blog/the-difference-between-active-directory-and-ldap/">The Difference Between Active Directory and LDAP</a>
  </div>
</div>

<div class="card mb-4" id="devops-10">
  <div class="card-body">
    <h2 class="card-title">10. Scaliability and Reliablity</h2>
    <h3>Scaling</h3>
    <ul>
      <li>Compute load patterns - consistent growth, constantly fluctuating loads, cyclical loads, unpredictable bursts</li>
      <li>Scale sets - load balancer distributes requests across VMs. Uses health probe to determine availability of each VM by pinging it</li>
      <li>Scaling up - adding more resources to a single instance (vertical scaling)</li>
      <li>Scaling out - addition of instances (horizontal scaling)</li>
    </ul>
    <h3>Strategies to achieve scalability and performance</h3>
    <ul>
      <li>Data partitioning - data partitions can be managed and accessed separately</li>
      <li>Caching - store frequently used data for fast retrieval. could be placed at database or application layer</li>
      <li>Autoscaling - dynamically allocate resources to match performance requirements</li>
      <li>Background jobs - tasks such as batch jobs, intensive processing tasks, and long-running processes should run as background jobs, decoupled from applicatio UI to minimize load</li>
      <li>Messaging - requests can continue to flow-in without error if application can’t keep up</li>
      <li>Scale units - define units for scaling</li>
    </ul>
    <h3>Architecting for availability</h3>
    <ul>
      <li>Recovery point objective - Maximum duration of acceptable data loss. For example, 30 minutes of data or four hours of data</li>
      <li>Recovery time objective - Maximum duration of acceptable downtime</li>
      <li>Design backup, restore, replication, and recovery capabilities based on above</li>
    </ul>
  </div>
  <div class="card-footer text-muted">

  </div>
</div>



<div class="card mb-4" id="devops-12">
  <div class="card-body">
    <h2 class="card-title">12. Agile</h2>
    <h3>Waterfall</h3>
    <ul>
      <li>Emphasis on planning to come up with accurate estimates on deliverables</li>
      <li>Fixed deliverables in each phase</li>
      <li>Test and release beome major events in each phase</li>
    </ul>

    <h3>Agile</h3>
    <ul>
      <li>Allows deliverables to move in/out from each sprint (as long as total story points remain the same)</li>
      <li>Test and release happen in much greater frequency for each sprint</li>
      <li>Backlogs are refiend 2-3 sprints ahead and team agrees on each item</li>
    </ul>

    <h3>Agile Manifesto</h3>
    <ul>
      <li>Individuals and interactions</li>
      <li>Working software</li>
      <li>Customer collaboration</li>
      <li>Responding to change</li>
    </ul>

    <h3>JIRA</h3>
    <ul>
      <li>Epic - theme of work. Should be delivered every quarter. Can have stories and tasks associated with it.</li>
      <li>Story - describes work. (as / want to / so that) Should be delivered within each sprint and can have sub-tasks</li>
      <li>Task - describes a single piece of work not taking more than one day. Can be part of a story and have sub-tasks</li>
      <li>Spike - research, investigation, prototyping</li>
    </ul>

    <h3>Pull Request</h3>
    <ul>
      <li>Size your story/task/sub-task such that your code change will not be more than 100 lines in each PR.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
      Reference: <a href="https://agilemanifesto.org/">Agile Manifesto</a>
  </div>
</div>

<div class="card mb-4" id="devops-13">
  <div class="card-body">
    <h2 class="card-title">13. DevOps Culture and Metrics</h2>
    <p class="card-text">Goal is to achieve efficiency (more outputs with the same amount of time, which translates to value for the organization)</p>

    <h3>These are some characteristics of DevOps culture</h3>
    <ul>
      <li>There are standards of technologies (tools and programming languages) used across the organization</li>
      <li>Teams across the organization have the same sprint cadence</li>
      <li>All members in the team are participating in code reviews, not just few individuals</li>
      <li>Epics are typically delivered in every quarter and all stories and tasks are tied to epics</li>
      <li>All requirements are mapped to branches of code repository</li>
      <li>code is released on planned basis via "fix version"</li>
      <li>Stories and Tasks marked as either Done or Not Done at the end of each sprint</li>
      <li>Standard branching strategies such as git and/or github flows are used</li>
    </ul>

    <h3>DevOps Metrics</h3>
    <ul>
      <li>Deployment frequency and speed</li>
      <li>Size (amount of stories and tasks) delievered in each sprint</li>
      <li>Lead time: time from starting to work on a feature to deploying it in production</li>
      <li>Time from when errors are detected to when they are resolved</li>
      <li>Number of people involved in deployment</li>
      <li>Number of errors found in production</li>
    </ul>
  </div>
  <div class="card-footer text-muted">

  </div>
</div>

<div class="card mb-4" id="devops-14">
  <div class="card-body">
    <h2 class="card-title">14. DB Basic</h2>
    <h3>Delete Vs. Truncate</h3>
    <ul>
      <li>Truncate - DDL (Data Definition Language), does not require commit to make the change permanent, deleted rows cannot be rolled back, always removes all rows from the table (table structure remains intact)</li>
      <li>Delete - DML (Data Manipulation Language), requires commit to make the change permanent, "where" clause can be used</li>
    </ul>
    <h3>DB indexing</h3>
    <ul>
      <li>Applying indexing on a field creates a data structure holding field value and pointer</li>
      <li>Data structure gets sorted so that search time can be O(logn) with binary search</li>
      <li>Fields with lots of duplicate values degrade benefits of indexing</li>
    </ul>
    <h3>Data types</h3>
    <ul>
      <li>Structured - relational data</li>
      <li>Semi-structured - ymal, json, xml</li>
      <li>Unstructured - photo, video, audio, text</li>
    </ul>
    <h3>Transaction (ACID)</h3>
    <ul>
      <li>Atomicity - either all is done or none is done</li>
      <li>Consistency - data is consistent before and after transaction</li>
      <li>Isolation - trasaction doesn't get affected by other transactions</li>
      <li>Durablility - transactions are permanently saved</li>
    </ul>
    <h3>Tokenization vs Encryption</h3>
    <ul>
      <li>Tokenized data is irreversible (detokenization can only be done by the original tokenization system)</li>
      <li>Encryption is reversible with the key</li>
    </ul>
  </div>
  <div class="card-footer text-muted">

  </div>
</div>

<div class="card mb-4" id="devops-15">
  <div class="card-body">
    <h2 class="card-title">15. Pipelining</h2>
    <p class="card-text">There are few principles when build a good pipeline for large organizations</p>
    <ul>
      <li>Multiple pipelines to deliver each business case is better than one pipeline ruling the whole Enterprise. One pipeline can become a single point of failure. Moreover, product owner of backlog needs to adhere everyone's concern in the Enterprise, which become an impossible task</li>
      <li>Speed is the key. Complex and over-engineered pipeline increases the duration of feedback loop that can defeat the purpose of automation</li>
      <li>Open-source the code. One team owning private repositories of pipeline implementation puts them at indisputable position</li>
      <li>Minimize tooling. Be mindful that each tool put into the pipeline increases complexity and reduces speed</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://medium.com/dzerolabs/the-six-horsemen-of-the-devops-apocalypse-a26ee8846f1f">The Six Horsemen of the DevOps Apocalypse</a>
  </div>
</div>-

<div class="card mb-4" id="devops-16">
  <div class="card-body">
    <h2 class="card-title">16. Message vs. Event</h2>
    <ul>
      <li>Message - used when communication needs guarantee to be processed. Contains raw data. </li>
      <li>Event - used for broadcasting communications (lighter than message). Has publishers and subscribers</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://medium.com/dzerolabs/the-six-horsemen-of-the-devops-apocalypse-a26ee8846f1f">The Six Horsemen of the DevOps Apocalypse</a>
  </div>
</div>

<div class="card mb-4" id="devops-17">
  <div class="card-body">
    <h2 class="card-title">17. Semantic Versioning (SemVer)</h2>
    <ul>
      <li>MAJOR - imcompatible API changes</li>
      <li>MINOR - add backwards compatible functionality</li>
      <li>PATCH - apply backwards compatible bugfix</li>
      <li>A pre-release (unstable) version examples: 1.0.0-alpha, 1.0.0-0.3.7, 1.0.0-x.7.z.92</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="semver.org">Semantic Versioning 2.0.0</a>
  </div>
</div>
<!-- DevOps END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="footer.html"></include>

</body>

</html>