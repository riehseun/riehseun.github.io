<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Exam</h1>

<!-- Exam BEGIN -->
<div class="card mb-4" id="exam">
  <div class="card-body">
    <h2 class="card-title">Exam</h2>
    <p class="card-text"></p>
    <ul class="list-unstyled mb-0">
      <li><a href="#exam-1">Mid-term 02/09/2026</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="exam-1">
  <div class="card-body">
    <h2 class="card-title">Mid-term 02/09/2026</h2>

<pre><code class="python">
# DSA Q1

# Implement the RandomizedSet class:

# RandomizedSet() Initializes the RandomizedSet object.
# bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.
# bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.
# int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.
# You must implement the functions of the class such that each function works in average O(1) time complexity.

class RandomizedSet:

    # Insert and Remove can be implemented by python dictionary with O(1)
    # Random - use randint function to get random index between 0 and len(dictionary)
    # During insert, also store number to a list
    # During insert, keep index of array as value of dictionary
    # During remove, swap index of removed item and the last element in list, then pop O(1)

    def __init__(self):
        self.dic = defaultdict(int)
        self.lis = []

    def insert(self, val):
        if val not in self.dic:
            self.lis.append(val)
            self.dic[val] = len(self.lis) - 1
            return True
        return False

    def remove(self, val):
        if val in self.dic:
            index = self.dic[val]
            n = len(self.lis)
            self.lis[index], self.lis[n-1] = self.lis[n-1], self.lis[index]
            self.lis.pop()
            del self.dic[val]
            return True
        return False

    def getRandom(self):
        random_index = random.randint(0, len(self.lis))
        return self.lis[random_index]
</code></pre>

<pre><code class="python">
# DSA Q2

# You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together.
# We repeatedly make k duplicate removals on s until we no longer can.
# Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.

# s = "aabbcc", k = 2 ? ""
# s = "abbbccdddcd", k = 3 ? ad
# s = "aaaaaaaaaaa", k = 3 ? ""

# Append char into stack
# If last k items in the stack are the same, pop all of them
# Time O(n) n  = len(s)
# Space O(n) 

stack = []

for c in s:
    stack.append(c)
    m = len(stack)
    if m >= k and len(set(stack[m-k:m])) == 1:
        for _ in range(k):
            stack.pop()

return "".join(stack)
</code></pre>

<pre><code class="python">
# DSA Q3

# An underground railway system is keeping track of customer travel times between different stations. They are using this data to calculate the average time it takes to travel from one station to another.
# Implement the UndergroundSystem class:
# void checkIn(int id, string stationName, int t)
# A customer with a card ID equal to id, checks in at the station stationName at time t.
# A customer can only be checked into one place at a time.
# void checkOut(int id, string stationName, int t)
# A customer with a card ID equal to id, checks out from the station stationName at time t.
# double getAverageTime(string startStation, string endStation)
# Returns the average time it takes to travel from startStation to endStation.
# The average time is computed from all the previous traveling times from startStation to endStation that happened directly, meaning a check in at startStation followed by a check out from endStation.
# The time it takes to travel from startStation to endStation may be different from the time it takes to travel from endStation to startStation.
# There will be at least one customer that has traveled from startStation to endStation before getAverageTime is called.
# You may assume all calls to the checkIn and checkOut methods are consistent. If a customer checks in at time t1 then checks out at time t2, then t1 < t2. All events happen in chronological order.

class UndergroundSystem:

    # Keep a mapping between id: stationName: and t (checkIn and checkOut)
    # Keep a mapping between id: lastCheckInStation
    # AverageTime - whenever customer ends a trip, compute travel time, and store it in another mapping (startStation, endStation): time
    # checkIn
    # Time O(1)
    # Space O(n) n = number of check-in
    # checkOut
    # Time O(1)
    # Space O(n)
    # getAverageTime
    # Time O(n)
    # Space O(1)

    def __init__(self):
        self.check_in = {}
        self.last_check_in_station = defaultdict(str)
        self.travel_time = defaultdict(list)

    def checkIn(self, id, stationName, t):
        if id not in self.check_in:
            self.check_in[id] = {}
        if stationName not in self.check_in[id]:
            self.check_in[id][stationName] = []
        self.check_in[id][stationName] = t
        self.last_check_in_station[id] = stationName

    def checkOut(self, id, stationName, t):
        station = self.last_check_in_station[id]
        start_time = self.check_in[id][station]
        self.travel_time[(station, stationName)].append(t-start_time)

    def getAverageTime(self, startStation, endStation):
        return sum(self.travel_time[(startStation, endStation)]) / len(self.travel_time[(startStation, endStation)])
</code></pre>

<pre><code class="python">
# DSA Q4

# You are given a doubly linked list, which contains nodes that have a next pointer, a previous pointer, and an additional child pointer. This child pointer may or may not point to a separate doubly linked list, also containing these special nodes. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure as shown in the example below.
# Given the head of the first level of the list, flatten the list so that all the nodes appear in a single-level, doubly linked list. Let curr be a node with a child list. The nodes in the child list should appear after curr and before curr.next in the flattened list.
# Return the head of the flattened list. The nodes in the list must have all of their child pointers set to null.

# If child pointer is not null, store node.next in stack, then node.next = child
# If node.next is null, node.next = stack.pop()
# Time O(n) n = number of nodes in LL
# Space O(1)

stack, node = [], head
dummy_head = Node()
dummy_head.next = node

while node:
    
    if not node.child:
        if not node.next:
            node.next = stack.pop()
        else:
            node = node.next
    else:
        stack.append(node.next)
        node.next = child

return dummy_head.next
</code></pre>

<img class="img-fluid" class="card-img-top" src="/exam/2026-02-09-1.png" alt="Card image cap">

<img class="img-fluid" class="card-img-top" src="/exam/2026-02-09-2.png" alt="Card image cap">

<pre><code class="markdown">
# MLSD Q1

# Design a system that sells AD space for customers to maximize revenue

# Requirement and Problem

Is the goal to recommend best spaces for place ADs to maximize revenue for each customer? Yes
Should the system provide personalized recommendataion for each customer? Yes
What does AD consist of? Text, image, video

Are there training dataset available? 1M data points of AD space and revenue for each customer
How fast should inference be? Under 200ms ! 
How many customers are there? 100M
How many AD spaces are there? Billions
Should the model be continuously trained based on new data points of AD space and revenue? Yes !
Should the model explain to users reasons for making recommendation? No !
Should the model be deployed to customer's edge devices? No

Input - customer
Output - list of AD spaces ranked based on expected revenue
Problem - supervised ranking problem

# High-Level Design

# Data and Feature Engineering

## Data model 
ADSpace, AD, Customer, ADSpace-AD

## Features
AD - text, image, video
ADSpace - platform type, average number of visitors to platform, total revenue

## Feature engineering
average number of visitors, total revenue - standardize
platform type - one-hot
ADSpace ID, Customer ID - embedding (learnable)
text - BERT
image - CLIP
video - CLIP's video encoder

# Model Development

## Baseline
Simply suggest ADSpace that generated most profit in the past - same recommendation for all users

## Architecture
Matrix Factorization between AD and ADSpace historical interaction (1 if generated good revenue, 0 otherwise)
Deep Learning with two tower

## Training
Ground truth - ranked list of ADSpace for each AD

# Inference and Evaluation

Store static features (AD - text, image, video, AD Space - platform type) in feature store
Compute dynamic features during runtime - average number of visitors, total revenue
Acquire ADs from the customers beforehand and compute candidate generation beforehand using collaborative filtering (only use AD and AD Space historical interaction, no AD or AD Space feature needed)
Compute similar between AD and AD Space embedding amongst candidate AD Spaces that are pre-generated
Ranking service (main model) focuses getting top k results
Re-ranking service focuses getting the ordering right 

## Offline
Ranking - recall at K
Re-ranking - precision at K
Overall - NDCG

## Online
Revenue reported by customers

# Detailed Design
</code></pre>

<img class="img-fluid" class="card-img-top" src="/exam/2026-02-09-5.png" alt="Card image cap">

<pre><code class="markdown">
# MLSD Q2

# Design Model Serving that can handle millions of requests per second

# Requirement and Problem

What kind of models are serves by the system? AD Space recommendation for AD
Are features static or do they constantly change? They are both static and dynamic

Are inferences batch or API? API
How fast should inference be generated? Under 200ms
How many requests are made to models? 100M per second

Input - API request
Output - API response
Problem - fast and scalable hosting solution for API

# High-Level Design

# Detailed Design

## Latency
Compute inference offline as much as possible (use static features to narrow down recommendation, and only use small subset of candidates when calling the model)

## Scalability
Kubernetes which uses autoscaler that scales nodes (thus pods) on demand
Use load balancers to route traffics to k8s cluster that has room to serve more traffic
</code></pre>

<pre><code class="python">
# ML
</code></pre>

<pre><code class="python">
# BE
</code></pre>

  </div>
  <div class="card-footer text-muted">
    Reference: <a href="="></a>
  </div>
</div>
<!-- Exam END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>