<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- K-way merge BEGIN -->
<div class="card mb-4" id="k-way-merge">
  <div class="card-body">
    <h2 class="card-title">K-way merge</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#k-way-merge-1">Merge sorted array</a></li>
      <li><a href="#k-way-merge-2">Kth smallest number in M sorted lists</a></li>
      <li><a href="#k-way-merge-3">Find K pairs with smallest sums</a></li>
      <li><a href="#k-way-merge-4">Merge K sorted linked lists</a></li>
      <li><a href="#k-way-merge-5">Kth smallest element in sorted matrix</a></li>
      <li><a href="#k-way-merge-6">Median of two sorted arrays</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="k-way-merge-1">
  <div class="card-body">
    <h2 class="card-title">Merge sorted array</h2>

    <h3 class="card-title">Use min heap</h3>
    <ul>
      <li>Push the first element in each list to min heap.</li>
      <li>Pop the root element from min heap. Also, pop that element from the list it came from.</li>
      <li>Insert the next element of the list into min heap.</li>
      <li>Repeat k times.</li>
    </ul>

<pre><code class="python">def merge_sorted(nums1, m, nums2, n):

    # Time: O(klogm). Where m is the number of lists.
    # Space: O(n). Where n is the number of all elements combined.

    p1 = m-1
    p2 = n-1
    p = m + n - 1

    while p2 >= 0 and p1 >= 0:

        if nums1[p1] > nums2[p2]:
            nums1[p] = nums1[p1]
            p1 -= 1
            p -= 1
        else:
            nums1[p] = nums2[p2]
            p2 -= 1
            p -= 1

    while p1 >= 0:
        nums1[p] = nums1[p1]
        p1 -= 1
        p -= 1

    while p2 >= 0:
        nums1[p] = nums2[p2]
        p2 -= 1
        p -= 1</code></pre>

    <h3 class="card-title">Test cases</h3>
    <ul>
      <li>One of inputs arrays are empty.</li>
      <li>Input arrays are not ordered.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/merge-sorted-array/">88. Merge Sorted Array</a>
  </div>
</div>

<div class="card mb-4" id="k-way-merge-2">
  <div class="card-body">
    <h2 class="card-title">Kth smallest number in M sorted lists</h2>

    <h3 class="card-title">Use 3 pointers</h3>
    <ul>
      <li>Pointer p1 and p2 will be moving backwards depending on which item is greater in nums1 and nums2.</li>
      <li>Pointer p will be moving backwards filling the numbers in the right position.</li>
    </ul>

<pre><code class="python">from heapq import heappush, heappop

def k_smallest_number(lists, k):

    # Time: O(n+m)
    # Space: O(1)

    min_heap = []
    count = 0

    for i, li in enumerate(lists):
        heappush(min_heap, (li[0], i))

    while count < k:

        item = heappop(min_heap)
        number = item[0]
        index = item[1]
        del lists[index][0]
        if lists[index]:
            heappush(min_heap, (lists[index][0], index))
        count += 1

        # Heap will be empty when k is greater than the total
        # number of elements in all lists.
        if not min_heap:
            return number

    return number</code></pre>

    <h3 class="card-title">Test cases</h3>
    <ul>
      <li>One of two arrays are empty.</li>
      <li>Both arrays are empty.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/path/ace-python-coding-interview">Ace the Python Coding Interview</a>
  </div>
</div>

<div class="card mb-4" id="k-way-merge-3">
  <div class="card-body">
    <h2 class="card-title">Find K pairs with smallest sums</h2>

    <h3 class="card-title">Get every possible pair and put it in to min_heap</h3>

<pre><code class="python">from heapq import heappush, heappop

def k_smallest_pairs(list1, list2, k):

    # Time: O(n^2)
    # Space: O(n^2)

    result = []
    min_heap = []

    for v1 in list1:
        for v2 in list2:
            heappush(min_heap, (v1+v2, v1, v2))

    for i in range(k):
        if not min_heap:
            break
        item = heappop(min_heap)
        result.append([item[1], item[2]])

    return result</code></pre>

    <h3 class="card-title">Pop/push from/to min heap one at a time</h3>
    <ul>
      <li>Initialize a min heap with pairs. (Pairs are constructed by all items in the first list and the first item in the second list)</li>
      <li>Each time popping out the min pair, the next pair to come into the min heap is (item that is popped out from the first list, next time to the item that is popped out from the second list)</li>
    </ul>

<pre><code class="python">from heapq import heappush, heappop

def k_smallest_pairs(list1, list2, k):

    # Time: O((n+m)log(n+m))
    # Space: O(n+m)

    count = 0
    result = []
    min_heap = []

    for i1, v1 in enumerate(list1):
        heappush(min_heap, (v1+list2[0], i1, 0))

    while min_heap and count < k:
        sum_pair, i, j = heappop(min_heap)
        result.append([list1[i], list2[j]])
        next_j = j + 1
        if next_j < len(list2):
            heappush(min_heap, (list1[i]+list2[next_j], i, next_j))
        count += 1

    return result</code></pre>

    <h3 class="card-title">Test cases</h3>
    <ui>
      <li>One of two lists is empty.</li>
      <li>There are pairs that add up to the same sum.</li>
    </ui>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/">373. Find K Pairs with Smallest Sums</a>
  </div>
</div>

<div class="card mb-4" id="k-way-merge-4">
  <div class="card-body">
    <h2 class="card-title">Merge K sorted linked lists</h2>

    <h3 class="card-title">Pop/push from/to min heap one at a time</h3>
    <ul>
      <li>From all linked lists, push all the items from its head pointer into the min heap.</li>
      <li>Pop the smallest into the min heap and push the next item (from the same linked list) into the min heap.</li>
      <li>At the same time, create a node in the resuling linked list one at time.</li>
    </ul>

<pre><code class="python">from heapq import heappush, heappop


class LinkedListNode:
    # __init__ will be used to make a LinkedListNode type object.
    def __init__(self, data, next=None):
        self.data = data
        self.next = next

def merge_k_lists(lists):

    # Time: O(nlog(k)) where n is the total number of items in all linked lists and k is the number of linked lists.
    # Space: O(n)

    min_heap = []
    # Init head to some placeholder node.
    head = LinkedListNode(-1)
    # "temp" will be the pointer at the very beginning.
    temp = head

    for i, ll in enumerate(lists):
        heappush(min_heap, (ll.head.data, i))

    while min_heap:
        item = heappop(min_heap)
        ll_head_data = item[0]
        ll_index = item[1]

        lists[ll_index].head = lists[ll_index].head.next
        if lists[ll_index].head:
            heappush(min_heap, (lists[ll_index].head.data, ll_index))

        node = LinkedListNode(ll_head_data)
        head.next = node
        head = head.next

    return temp.next</code></pre>

    <h3 class="card-title">Test cases</h3>
    <ul>
      <li>One of linked lists are empty.</li>
      <li>Linked lists have different length.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/path/ace-python-coding-interview">Ace the Python Coding Interview</a>
  </div>
</div>

<div class="card mb-4" id="k-way-merge-5">
  <div class="card-body">
    <h2 class="card-title">Kth smallest element in sorted matrix</h2>

    <h3 class="card-title">Pop/push from/to min heap one at a time</h3>
    <ul>
      <li>Initally put the first element at each column into min heap.</li>
      <li>Whenever popping out from min heap, put the rest of items in that row into the min heap.</li>
    </ul>

<pre><code class="python">from heapq import heappush, heappop

def kth_smallest_element(matrix, k):

    # Time: O(nlog(n)) where n is the length of matrix.
    # Space: O(n^2)

    min_heap = []
    seen = set()
    count = 0
    next_min_number = None

    # Put the first item in each row to min heap.
    for i, row in enumerate(matrix):
        heappush(min_heap, (row[0], i))

    while min_heap and count < k:
        next_min_number, i = heappop(min_heap)
        if i not in seen:
            for num in matrix[i][1:]:
                heappush(min_heap, (num, i))
            seen.add(i)

        count += 1

    return next_min_number</code></pre>

    <h3 class="card-title">Test cases</h3>
    <ul>
      <li>There is zero element in the matrix.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/">378. Kth Smallest Element in a Sorted Matrix</a>
  </div>
</div>

<div class="card mb-4" id="k-way-merge-6">
  <div class="card-body">
    <h2 class="card-title">Median of two sorted arrays</h2>

    <h3 class="card-title">Pop/push from/to min heap one at a time</h3>
    <ul>
      <li>Numbers greater than higher median cannot be the overall median.</li>
      <ui>
        <li>If list length is even, numbers higher than bigger of two medians must go.</li>
      </ui>
      <li>Numbers smaller than smaller median cannot be the overall median.</li>
      <ui>
        <li>If list length is even, numbers less than smaller of two medians must go.</li>
      </ui>
    </ul>

<pre><code class="python">from heapq import heappush, heappop

def kth_smallest_element(matrix, k):

    # Time: O(log(m+n))
    # Space: O(1)

    min_heap = []
    seen = set()
    count = 0
    next_min_number = None

    # Put the first item in each row to min heap.
    for i, row in enumerate(matrix):
        heappush(min_heap, (row[0], i))

    while min_heap and count < k:
        next_min_number, i = heappop(min_heap)
        if i not in seen:
            for num in matrix[i][1:]:
                heappush(min_heap, (num, i))
            seen.add(i)

        count += 1

    return next_min_number</code></pre>

    <h3 class="card-title">Test cases</h3>
    <ul>
      <li>There is zero element in the matrix.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">4. Median of Two Sorted Arrays</a>
  </div>
</div>
<!-- K-way merge END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>