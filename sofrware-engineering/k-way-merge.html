<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js"></script>
<script src="/js/bootstrap.bundle.min.js"></script>
<script src="/js/highlight.pack.js"></script>
<script type="text/javascript" src="/js/include_html.js"></script>
<script type="text/javascript" src="/js/site.js"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- K-way merge BEGIN -->
<div class="card mb-4" id="k-way-merge">
  <div class="card-body">
    <h2 class="card-title">K-way merge</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#k-way-merge-1">K-way merge</a></li>
      <li><a href="#k-way-merge-2">Kth smallest number in M sorted lists</a></li>
      <li><a href="#k-way-merge-3">Find K pairs with smallest sums</a></li>
      <li><a href="#k-way-merge-4">Merge K sorted linked lists</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="k-way-merge-1">
  <div class="card-body">
    <h2 class="card-title">Merge sorted array</h2>

    <h3 class="card-title">Use min heap</h3>
    <ul>
      <li>Push the first element in each list to min heap.</li>
      <li>Pop the root element from min heap. Also, pop that element from the list it came from.</li>
      <li>Insert the next element of the list into min heap.</li>
      <li>Repeat k times.</li>
      <li>Time: O(klogm). Where m is the number of lists.</li>
      <li>Space: O(n). Where n is the number of all elements combined.</li>
    </ul>

<pre><code class="python">from heapq import heappush, heappop

def k_smallest_number(lists, k):

    min_heap = []
    count = 0

    for i, li in enumerate(lists):
        heappush(min_heap, (li[0], i))

    while count < k:

        item = heappop(min_heap)
        number = item[0]
        index = item[1]
        del lists[index][0]
        if lists[index]:
            heappush(min_heap, (lists[index][0], index))
        count += 1

        # Heap will be empty when k is greater than the total
        # number of elements in all lists.
        if not min_heap:
            return number

    return number</code></pre>

    <h3 class="card-title">Test cases</h3>
    <ul>
      <li>One of inputs arrays are empty.</li>
      <li>Input arrays are not ordered.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-coding-interview-patterns-python">Grokking Coding Interview Patterns in Python</a>
  </div>
</div>

<div class="card mb-4" id="k-way-merge-2">
  <div class="card-body">
    <h2 class="card-title">Kth smallest number in M sorted lists</h2>

    <h3 class="card-title">Use 3 pointers</h3>
    <ul>
      <li>Pointer p1 and p2 will be moving backwards depending on which item is greater in nums1 and nums2.</li>
      <li>Pointer p will be moving backwards filling the numbers in the right position.</li>
      <li>Time: O(n+m)</li>
      <li>Space: O(1)</li>
    </ul>

<pre><code class="python">def merge_sorted(nums1, m, nums2, n):

    p1 = m-1
    p2 = n-1
    p = m + n - 1

    while p2 >= 0 and p1 >= 0:

        if nums1[p1] > nums2[p2]:
            nums1[p] = nums1[p1]
            p1 -= 1
            p -= 1
        else:
            nums1[p] = nums2[p2]
            p2 -= 1
            p -= 1

    while p1 >= 0:
        nums1[p] = nums1[p1]
        p1 -= 1
        p -= 1

    while p2 >= 0:
        nums1[p] = nums2[p2]
        p2 -= 1
        p -= 1</code></pre>

    <h3 class="card-title">Test cases</h3>
    <ul>
      <li>One of two arrays are empty.</li>
      <li>Both arrays are empty.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-coding-interview-patterns-python">Grokking Coding Interview Patterns in Python</a>
  </div>
</div>

<div class="card mb-4" id="k-way-merge-3">
  <div class="card-body">
    <h2 class="card-title">Find K pairs with smallest sums</h2>

    <h3 class="card-title">Get every possible pair and put it in to min_heap</h3>
    <ul>
      <li>Time: O(n^2)</li>
      <li>Space: O(n^2)</li>
    </ul>

<pre><code class="python">def k_smallest_pairs(list1, list2, k):

    result = []
    min_heap = []

    for v1 in list1:
        for v2 in list2:
            heappush(min_heap, (v1+v2, v1, v2))

    for i in range(k):
        if not min_heap:
            break
        item = heappop(min_heap)
        result.append([item[1], item[2]])

    return result</code></pre>

    <h3 class="card-title">Get every possible pair and put it in to min_heap</h3>
    <ul>
      <li>Initialize a min heap with pairs. (Pairs are constructed by all items in the first list and the first item in the second list)</li>
      <li>Each time popping out the min pair, the next pair to come into the min heap is (item that is popped out from the first list, next time to the item that is popped out from the second list)</li>
      <li>Time: O((n+m)log(n+m))</li>
      <li>Space: O(n+m)</li>
    </ul>

<pre><code class="python">def k_smallest_pairs(list1, list2, k):

    count = 0
    result = []
    min_heap = []

    for i1, v1 in enumerate(list1):
        heappush(min_heap, (v1+list2[0], i1, 0))

    while min_heap and count < k:
        sum_pair, i, j = heappop(min_heap)
        result.append([list1[i], list2[j]])
        next_j = j + 1
        if next_j < len(list2):
            heappush(min_heap, (list1[i]+list2[next_j], i, next_j))
        count += 1

    return result</code></pre>

    <h3 class="card-title">Test cases</h3>
    <ui>
      <li>One of two lists is empty.</li>
      <li>There are pairs that add up to the same sum.</li>
    </ui>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-coding-interview-patterns-python">Grokking Coding Interview Patterns in Python</a>
  </div>
</div>

<div class="card mb-4" id="k-way-merge-4">
  <div class="card-body">
    <h2 class="card-title">Merge K sorted linked lists</h2>

    <h3 class="card-title"></h3>
    <ul>
      <li></li>
      <li></li>
      <li>Time: </li>
      <li>Space: </li>
    </ul>

<pre><code class="python"></code></pre>

    <h3 class="card-title">Test cases</h3>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-coding-interview-patterns-python">Grokking Coding Interview Patterns in Python</a>
  </div>
</div>
<!-- K-way merge END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>