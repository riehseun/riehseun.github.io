=<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- System design BEGIN -->
<div class="card mb-4" id="system-design">
  <div class="card-body">
    <h2 class="card-title">System design</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#system-design-">System design</a></li>
      <li><a href="#system-design-">Distributed system</a></li>
      <li><a href="#system-design-">Scalability</a></li>
      <li><a href="#system-design-">Reliability</a></li>
      <li><a href="#system-design-">Availability</a></li>
      <li><a href="#system-design-">Quorum</a></li>
      <li><a href="#system-design-">CAP theorem</a></li>
      <li><a href="#system-design-">Consistency</a></li>
      <li><a href="#system-design-">Isolation level</a></li>
      <li><a href="#system-design-">Anomaly</a></li>
      <li><a href="#system-design-">RPC</a></li>
      <li><a href="#system-design-">Non-functional requirements</a></li>
      <li><a href="#system-design-">Back-of-the-envelop</a></li>
      <li><a href="#system-design-">Resource estimation</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">System design</h2>
    <ul>
      <li>Discuss trade-off</li>
      <ul>
        <li>Consider 2-3 solutions.</li>
        <li>Justify chosen decision.</li>
      </ul>
      <li>Communicate</li>
      <ul>
        <li>Ask to clarify the requirement, understand the scale and constraints.</li>
        <li>Be open to feedbacks.</li>
      </ul>
      <li>Talking points</li>
      <ul>
        <li>Describe components and their interactions.</li>
        <li>Describe complete lifecycle of a request.</li>
        <li>Discuss trade-off and user experience.</li>
        <li>Discuss potential bottlenecks.</li>
        <li>Dicusss future problems as system scales.</li>
        <li>Describe failover.</li>
        <li>Discuss user experience when failure happens.</li>
        <li>Discuss peak load</li>
      </ul>
      <li>Building blocks</li>
      <ul>
        <li>Search system</li>
        <ul>
          <li>Crawler</li>
          <li>Indexer</li>
          <li>Searcher</li>
        </ul>
        <li>Load balancer</li>
        <li>CDN</li>
        <li>Cache</li>
        <li>Front-end (web) servers</li>
        <ul>
          <li>Servers static content</li>
        </ul>
        <li>Analytics</li>
        <li>Storage</li>
        <ul>
          <li>Relational DB</li>
          <li>Non-relational DB</li>
          <li>Blob store</li>
        </ul>
        <li>Task queue</li>
      </ul>
      <li>RESHADED</li>
      <ul>
        <li>Requirement</li>
        <li>Estimation</li>
        <li>Storage schema (optional)</li>
        <li>High-level design</li>
        <li>API</li>
        <li>Detailed design</li>
        <li>Evaludation</li>
        <li>Distinct component</li>
      </ul>
    </ul>

    <h3 class="card-title">High level design</h3>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/sd-cicd.png" alt="Card image cap">

    <h3 class="card-title">Component design</h3>

  </div>
  <div class="card-footer text-muted">

  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Distributed System</h2>

    <h3 class="card-title">Distributed system challenges</h3>
    <ul>
      <li>Network asynchrony: messages take long to deliver, deliver out of order, or not deliver at all.</li>
      <li>Partial failures: only some components fail.</li>
      <li>Concurrency: execution of multiple computations intervene each other.</li>
    </ul>

    <h3 class="card-title">Failure types</h3>
    <ul>
      <li>Fail-stop: a node halts and remains halted permanently. (Easiest scenario)</li>
      <li>Crash: a node halts, but silently.</li>
      <li>Omission: a node fails to respond to incoming requests.</li>
      <li>Byzantine: a node exhibits arbitrary behavior.</li>
    </ul>

    <h3 class="card-title">State</h3>
    <ul>
      <li>Stateless: maintains no state. Performs purely based on the inputs.</li>
      <li>Stateful: maintains and updates states. Results depend on this state.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-the-system-design-interview">Grokking the System Design Interview</a> | <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Scalability</h2>
    <ul>
      <li>Capability to manage increased demand.</li>
      <li>Compute load patterns - Consistent growth, constantly fluctuating loads, cyclical loads, unpredictable bursts.</li>
      <li>Scale sets - Load balancer distributes requests across VMs. Uses health probe to determine availability of each VM by pinging it.</li>
      <li>Scaling up (vertical scaling) - Adds more resources to a single instance.</li>
      <li>Scaling out (horizontal scaling) - Addition more instances.</li>
    </ul>

    <h3 class="card-title">Strategies to achieve scalability and performance</h3>
    <ul>
      <li>Data partitioning - data partitions can be managed and accessed separately.</li>
      <li>Caching - store frequently used data for fast retrieval. Could be placed at database or application layer.</li>
      <li>Autoscaling - dynamically allocate resources to match performance requirements.</li>
      <li>Background jobs - tasks such as batch jobs, intensive processing tasks, and long-running processes should run as background jobs, decoupled from applicatio UI to minimize load.</li>
      <li>Messaging - requests can continue to flow-in without error if application can’t keep up.</li>
      <li>Scale units - define units for scaling.</li>
    </ul>

    <h3 class="card-title">Vertical partitioning</h3>
    <ul>
      <li>Divides tables into different servers based on features of data. (Split columns)</li>
      <li>Problem when data experiences additional growth.</li>
      <li>Queries must hit multiple servers and join operations are needed.</li>
    </ul>

    <h3 class="card-title">Horizontal partitioning (Sharding)</h3>
    <ul>
      <li>Puts different rows to different tables.</li>
      <li>Atomic operation is hard to achieve.</li>
      <li>It is cheaper to add more servers than growing the existing server as data increases.</li>
    </ul>

    <h4 class="card-title">Range partitioning</h4>
    <ul>
      <li>Split dataset based on specific attribute.</li>
      <li>Range based query is easy to implement.</li>
      <li>May result in unbalanced servers.</li>
    </ul>

    <h4 class="card-title">Hash partitioning</h4>
    <ul>
      <li>Apply hash function to some attribute of data and mod that hash value by the number of paritions.</li>
      <li>Uniform allocation of data across servers.</li>
      <li>Range based query is hard to implement.</li>
      <li>Adding new servers mean changing hash function and redistribution of data.</li>
    </ul>

    <h4 class="card-title">Consistent hashing</h4>
    <ul>
      <li>Create conceptual ring of hashes from 0 to n−1, where n is the number of available hash values.</li>
      <li>Each node and request are put into the ring based on its hash value.</li>
      <li>Each request is served by the next node in the ring.</li>
      <li>When a new node is added to the ring, its next node need to share keys with the newly added node.</li>
      <li>Some node could be heavily loaded compared to others.</li>
    </ul>

    <h5 class="card-title">Virtual node</h5>
    <ul>
      <li>Each node is put into multiple positions in the ring based on multiple hash functions.</li>
      <li>Each node can have different number of virtual nodes based on hardware capability.</li>
      <li>Load is more uniform.</li>
      <li>Used in Dynamo and Cassandra.</li>
    </ul>

    <h5 class="card-title">Fixed number of partitions</h5>
    <ul>
      <li>Number of partitions is fixed when DB is setup.</li>
      <li>Higher number of partitions are created than the nodes.</li>
      <li>Paritions are assigned to nodes.</li>
      <li>If partition is too small, results in overhead. If partition is too large, rebalancing the nodes will be expensive.</li>
      <li>Used in Elasticsearch.</li>
    </ul>

    <h5 class="card-title">Dynamic partitioning</h5>
    <ul>
      <li>When the size of a partition reaches the threshold, it is split into two partitions.</li>
      <li>Difficult to apply dynamic rebalancing while serving the reads and writes.</li>
      <li>Used in HBase and MongoDB.</li>
    </ul>

    <h5 class="card-title">Partition proportionally to nodes</h5>
    <ul>
      <li>Number of partitions is proportionate to the number of nodes, so that every node has fixed partitions.</li>
      <li>As the number of nodes increases, the partitions shrink. Rebalancing between paritions may result in unfair split.</li>
      <li>Used in Cassandra.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-the-system-design-interview">Grokking the System Design Interview</a> | <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Reliability</h2>
    <ul>
      <li>Delivering services even when some components fail.</li>
      <li>Redunduncy of both software components and data.</li>
      <li>Recovery point objective - Maximum duration of acceptable data loss. For example, 30 minutes of data or four hours of data.</li>
      <li>Recovery time objective - Maximum duration of acceptable downtime.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-the-system-design-interview">Grokking the System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Availability</h2>
    <ul>
      <li>Ability of the system to remain functional despite failures.</li>
      <li>Achieved by replication. (Keep multiple copies of data at preferrably different geographic location)</li>
      <li>Reliability means availability, but the opposite is not true.</li>
    </ul>

    <h3 class="card-title">Replication</h3>
    <ul>
      <li>Synchrounous - primary responds to client after receving acknowledgements from all backups.</li>
      <li>Asynchrounous - primary responds to client without receving acknowledgements from all backups.</li>
    </ul>

    <h3 class="card-title">Single-master replication (Primary-backup replication)</h3>
    <ul>
      <li>Primary processes updates/writes locally and propagates to backups.</li>
      <li>Scalable for read-heavy (read can happen from any backups) but not so for write-heavy. (Only primary can handle writes)</li>
      <li>Statement based replication</li>
      <ul>
        <li>Problem: non-deterministic functions such as NOW() or RAND() lead to different values on different nodes.</li>
      </ul>
      <li>Write-ahead log (WAL) shipping</li>
      <ul>
        <li>Primary node saves the query before executing it in a log file.</li>
        <li>Then, it uses these logs to copy data into the backup nodes.</li>
      </ul>
      <li>Logical (row-based) log replication</li>
      <ul>
        <li>All backup nodes replicate the actual data changes.</li>
      </ul>
    </ul>

    <h3 class="card-title">Multi-master replication (multi-primary replication)</h3>
    <ul>
      <li>Multiple primary nodes that process the writes and send them to all other primary and backup nodes to replicate.</li>
      <li>Conflict can happen where mutiple nodes modify the same data.</li>
    </ul>

    <h3 class="card-title">Leaderless replication</h3>
    <ul>
      <li>Always write or read from a majority (more than half) of the number of nodes in the system.</li>
      <li>The latest value is written to at least one of the nodes in the system.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-the-system-design-interview">Grokking the System Design Interview</a> | <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Quorum</h2>
    <ul>
      <li>We write data to the nodes that are only resposible for write operations. We read data from all nodes and return the latest value.</li>
      <ul>
        <li>Write is successful when w-1 nodes respond. (Coordinator writes to itself first, so we get w writes in total)</li>
        <li>Wait for r answers before returning the results to the client.</li>
      </ul>
      <li>Quorum is achieved when R + W > N. At least one node should be both read and write so that readers could get the latest-written value.</li>
      <li>If w > r, fast write but slow read because need to go to many nodes for a value.</li>
      <li>If r > w, fast read but slow write because need to write to many nodes synchronously.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-the-system-design-interview">Grokking the System Design Interview</a> | <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">CAP theorem</h2>
    <ul>
      <li>It is impossible to acheive all three at the same time. We can only have two out of three.</li>
      <li>Consistency: all nodes see the same data at the same time.</li>
      <li>Availability: system must be accessible even when nodes fail.</li>
      <li>Partition tolerance: system must operate even when communications between nodes break.</li>
    </ul>

    <p class="card-text">In distributed system, If there is no partition tolerance, there is no consistency or availability. This means we can only choose between consistency or availability in distributed system.</p>
    <ul>
      <li>CA - RDBMS (Non-distributed system)</li>
      <li>PA - Dynamo, Cassandra, CouchDB (BASE DBs choose availability - respond with local data w/o ensuring its the latest with peers)</li>
      <li>PC - BigTable, HBase (ACID DBs choose consistency - refuse response if cannot check peers)</li>
    </ul>

    <h3 class="card-title">PACELC theorem</h3>
    <ul>
      <li>When there is no network partition during normal operation, then choose between latency or consistency.</li>
      <li>To guarantee data consistency, the system will have to delay write operations until the data has been propagated across the system successfully, taking a latency hit.</li>
      <li>PA system would go for L (latency) and PC system would go for C (consistency)</li>
    </ul>

    <p class="card-text"><strong>Systems that choose A over C can still support eventual consistency but no linearizability/sequential/casual!</strong></p>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-the-system-design-interview">Grokking the System Design Interview</a> | <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Consistency</h2>
    <ul>
      <li>Considers single object operations.</li>
    </ul>

    <h3 class="card-title">Linearizability</h3>
    <ul>
      <li>Synchronous replication technique. (Acknowledgment is not sent to the client until the new value is written to all replicas)</li>
      <li>Once an operation is complete and the ack is delivered to client, it is visible to all other clients.</li>
      <li>Ex. updating account password.</li>
    </ul>

    <h3 class="card-title">Sequential consistency</h3>
    <ul>
      <li>Preserves the ordering specified by each client’s program.</li>
      <li>For example, we don't care what’s the ordering of posts between our friends. But, the posts from a single friend has to be displayed in the right order.</li>
    </ul>

    <h3 class="card-title">Causal consistency</h3>
    <ul>
      <li>Operations that are not causally related can be seen in different orders.</li>
      <li>For example, comments and their sub-comments must appear in the right order.</li>
    </ul>

    <h3 class="card-title">Eventual consistency</h3>
    <ul>
      <li>Do not need to return the latest write as long as the system eventually arrives at a stable state.</li>
      <li>Can achieve high availability.</li>
      <li>Ex. DNS, Cassandra.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-the-system-design-interview">Grokking the System Design Interview</a> | <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Isolation level</h2>
    <ul>
      <li>Considers multi object operations.</li>
    </ul>

    <h3 class="card-title">Serializability</h3>
    <ul>
      <li>Two transactions executed concurrently should give same result.</li>
      <li>Prevents all anomalies.</li>
    </ul>

    <h3 class="card-title">Repeatable read</h3>
    <ul>
      <li>Data once read by a transaction will not change throughout its course.</li>
    </ul>

    <h3 class="card-title">Snapshot isolation</h3>
    <ul>
      <li>All reads made in a transaction see a consistent snapshot of the database.</li>
    </ul>

    <h3 class="card-title">Read committed</h3>
    <ul>
      <li>Does not allows a transaction to read a data that has not yet been committed by other transaction.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-the-system-design-interview">Grokking the System Design Interview</a> | <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Anomaly</h2>

    <h3 class="card-title">Dirty write</h3>
    <ul>
      <li>Transaction overwrites a value that was written by another transaction that is not committed yet.</li>
    </ul>

    <h3 class="card-title">Dirty read</h3>
    <ul>
      <li>Transaction reads a value that was written by another transaction that is not committed yet.</li>
    </ul>

    <h3 class="card-title">Fuzzy or non-repeatable read</h3>
    <ul>
      <li>Value is retrieved twice during a transaction and the value is different.</li>
    </ul>

    <h3 class="card-title">Phantom read</h3>
    <ul>
      <li>For example, transaction of two queries runs to calculate the maximum and the average. However, another transaction intervenes to insert lots of record, thus making the first transaction return an average that is larger than the maximum.</li>
    </ul>

    <h3 class="card-title">Lost update</h3>
    <ul>
      <li>Two transactions read the same value and then try to update it to two different values.</li>
    </ul>

    <h3 class="card-title">Read skew</h3>
    <ul>
      <li>A transaction can only see partial results of another transaction.</li>
    </ul>

    <h3 class="card-title">Dirty write</h3>
    <ul>
      <li>Two transactions read the same data, but then modify disjoint sets of data.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-the-system-design-interview">Grokking the System Design Interview</a> | <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">RPC</h2>
    <ul>
      <li>For building applications on top of distributed system.</li>
    </ul>

    <h3 class="card-title">RPC process</h3>
    <ul>
      <li>Client initiates client stub process by giving parameters.</li>
      <li>Client stub converts the parameters into standardized format and packs them into a message.</li>
      <li>Client RPC runtime delivers the message to the server over the network.</li>
      <li>Server RPC runtime receives the message and passes it to the server stub.</li>
      <li>Server stub unpacks the message to retrieve the parameters and calls the desired server routine.</li>
      <li>Server stub packs the returned result into a message and sends it to RPC runtime at the server.</li>
      <li>Server RPC runtime returns the packed result to Client RPC runtime over the network.</li>
      <li>Client RPC runtime sends the result to the client stub.</li>
      <li>Client stub unpacks the result.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Non-functional requirements</h2>

    <h2 class="card-title">Availability</h2>
    <ul>
      <li>Percentage of time that the service is accessible to clients.</li>
      <li>Associated with time loss.</li>
    </ul>

    <h2 class="card-title">Reliability</h2>
    <ul>
      <li>Probability that the service will perform its functions.</li>
      <li>Associated with frequency and impact of failure.</li>
      <li>Metrics are mean time between failures and mean time to repair.</li>
    </ul>

    <h2 class="card-title">Scalability</h2>
    <ul>
      <li>Ability to handle increasing workload without degrading performance.</li>
      <li>Workload can be number of requests or amounts of data.</li>
    </ul>

    <h2 class="card-title">Maintainability</h2>
    <ul>
      <li>Probability that the service will restore its function. (When broken)</li>
      <li>Workload can be number of requests or amounts of data.</li>
      <li>Metrics are mean time to repair.</li>
    </ul>

    <h2 class="card-title">Fault tolerance</h2>
    <ul>
      <li>Ability to continue to perform when some components fail.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">

  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Back-of-the-envelop</h2>

    <h3 class="card-title">Web servers</h3>
    <ul>
      <li>Typically serve static content to client. (Web browser)</li>
      <li>Usually handle API calls from clients.</li>
    </ul>

    <h3 class="card-title">App servers</h3>
    <ul>
      <li>Typically serve dynamic content to client.</li>
      <li>Core business logic.</li>
    </ul>

    <h3 class="card-title">Important latencies</h3>
    <table>
      <tr>
        <td>L1 cache reference</td>
        <td>0.9</td>
      </tr>
      <tr>
        <td>L2 cache reference</td>
        <td>2.8</td>
      </tr>
      <tr>
        <td>L3 cache reference</td>
        <td>12.9</td>
      </tr>
      <tr>
        <td>Main memory reference</td>
        <td>100</td>
      </tr>
      <tr>
        <td>Compress 1KB with Snzip</td>
        <td>3,000 (3 microseconds)</td>
      </tr>
      <tr>
        <td>Read 1 MB sequentially from memory</td>
        <td>9,000 (9 microseconds)</td>
      </tr>
      <tr>
        <td>Read 1 MB sequentially from SSD</td>
        <td>200,000 (200 microseconds)</td>
      </tr>
      <tr>
        <td>Round trip within same datacenter</td>
        <td>500,000 (500 microseconds)</td>
      </tr>
      <tr>
        <td>Read 1 MB sequentially from SSD with speed ~1GB/sec SSD</td>
        <td>1,000,000 (1 milliseconds)</td>
      </tr>
      <tr>
        <td>Disk seek</td>
        <td>4,000,000 (4 milliseconds)</td>
      </tr>
      <tr>
        <td>Read 1 MB sequentially from disk</td>
        <td>2,000,000 (2 milliseconds)</td>
      </tr>
      <tr>
        <td>Send packet SF->NYC</td>
        <td>71,000,000 (71 milliseconds)</td>
      </tr>
    </table>

    <h3 class="card-title">Important rates</h3>
    <table>
      <tr>
        <td>QPS handled by MySQL</td>
        <td>1000</td>
      </tr>
      <tr>
        <td>QPS handled by key-value store</td>
        <td>10,000</td>
      </tr>
      <tr>
        <td>QPS handled by cache server</td>
        <td>100,000–1 M</td>
      </tr>
    </table>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Resource estimation</h2>

    <h3 class="card-title">Request per second</h3>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Server has 36 cores (72 threads), 256 GB RAM</li>
        <li>OS and other processes consumed 16 GB RAM.</li>
        <li>Each worker consumes 300 MB RAM to complte a request.</li>
        <li>Each CPU-bound request takes 200 millisecond.</li>
        <li>Each memory-bound request takes 50 milliseconds.</li>
      </ul>
      <li>RPS (CPU) = number of thread / time each task takes = 72 / 200 ms = 360 RPS</li>
      <li>RPS (RAM) = Available memory / (time each task takes * worker memory comsumption) = 240 GB / (50 ms * 300 MB)= 16,000 RPS</li>
      <li>Assume half requests are CPU bound and half requests are memory bound: 360 / 2 + 16,000 / 2 = 8,000 RPS</li>
    </ul>

    <h3 class="card-title">Estimate number of servers</h3>
    <ul>
      <li>Assume 500M daily users and 20 request per day on average.</li>
      <li>Then, 10B requests per day, which is 115K requests per seconds.</li>
      <li>So, looks like 15 servers (that can handle 8,000 RPS) can handle 500M users?</li>
      <li>In reality, requests may go through many differnt servers, not just a single server.</li>
      <li>First, assume each user sends one request per day. (Number of requests per day / 8,000 RPS)</li>
      <li>Then, assume all requests from all users arrive simultaneously during peak load. (Number of requests per second / 8,000 RPS)</li>
      <li>Thus, 500M / 8,000 = 62,000 servers are needed.</li>
    </ul>


    <h3 class="card-title">Estimate storage</h3>
    <ul>
      <li>Assume 250M daily active users and each user makes 3 write requests per day.</li>
      <li>Assume 10% contains images, 5% contains videos, 85% contain just text.</li>
      <li>Assume each image is 200 KB, video is 3 MB, and text is 250 bytes.</li>
      <li>Storage required: (250 * 3) * (250 B + 200 KB * 0.1 + 3 MB * 0.05) = 128 TB per day.</li>
    </ul>

    <h3 class="card-title">Estimate bandwitdth</h3>
    <ul>
      <li>Incoming traffic: (128 TB per day / 86400 seconds per day) * 8 bits per byte = 12 Gbps.</li>
      <li>Assume each user make 50 read requests per day.</li>
      <li>Outgoing traffic: (12 Gbps / 3) * 50 = 197.5 Gbps.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>
<!-- System design END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>