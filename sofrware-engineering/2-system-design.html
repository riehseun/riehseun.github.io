<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- System design BEGIN -->
<div class="card mb-4" id="system-design">
  <div class="card-body">
    <h2 class="card-title">System design</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#system-design-">System design</a></li>
      <li><a href="#system-design-">Building blocks</a></li>
      <li><a href="#system-design-">Non-functional requirements</a></li>
      <li><a href="#system-design-">Distributed system</a></li>
      <li><a href="#system-design-">Back-of-the-envelop</a></li>
      <li><a href="#system-design-">Resource estimation</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">System design</h2>
    <ul>
      <li>Communicate</li>
      <ul>
        <li>Do not jump into a solution</li>
        <li>Ask to clarify the requirement, make proper assumption, gather information to understand the scale and constraints</li>
        <ul>
          <li>What specific features are we building?</li>
          <li>How many users?</li>
          <li>How fast does the system scale? 3 months, 6 months, etc?</li>
          <li>What existing services are there to leaverage?</li>
        </ul>
        <li>Do a recap of design</li>
        <li>Be open to feedbacks</li>
      </ul>
      <li>Talking points</li>
      <ul>
        <li>Discuss trade-off and user experience.</li>
        <ul>
          <li>Consider 2-3 solutions</li>
          <li>Justify chosen decision</li>
        </ul>
        <li>Describe components and their interactions</li>
        <li>Describe complete lifecycle of a request</li>
        <li>Discuss potential bottlenecks</li>
        <li>Dicusss future problems as system scales</li>
        <li>Describe failover</li>
        <li>Discuss user experience when failure happens</li>
        <li>Discuss peak load</li>
      </ul>
      <li>Building blocks</li>
      <ul>
        <li>Search system</li>
        <ul>
          <li>Crawler</li>
          <li>Indexer</li>
          <li>Searcher</li>
        </ul>
        <li>Load balancer</li>
        <li>CDN</li>
        <li>Cache</li>
        <li>Front-end (web) servers</li>
        <ul>
          <li>Serves static content</li>
        </ul>
        <li>Analytics</li>
        <li>Storage</li>
        <ul>
          <li>Relational DB</li>
          <li>Non-relational DB</li>
          <li>Blob store</li>
        </ul>
        <li>Task queue</li>
      </ul>
      <li>RESHADED</li>
      <ul>
        <li>Requirement</li>
        <li>Estimation</li>
        <li>Storage schema (optional)</li>
        <li>High-level design</li>
        <li>API</li>
        <li>Detailed design</li>
        <li>Evaludation</li>
        <li>Distinct component</li>
      </ul>
    </ul>

    <!-- <h3 class="card-title">High level design</h3>
    <img class="img-fluid" class="card-img-top" src="/img/system-design/sd-cicd.png" alt="Card image cap">

    <h3 class="card-title">Component design</h3> -->

  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/system-design-interview-handbook">The System Design Interview Prep Handbook</a>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Building blocks</h2>

    <img class="img-fluid" class="card-img-top" src="/img/system-design/system-design1.png" alt="Card image cap">

    <h3 class="card-title">DNS</h3>
    <ul>
      <li>Maps domain names to IP addresses</li>
      <li>Resource record</li>
      <ul>
        <li>A - hostname to IP address mapping</li>
        <li>CNAME - alias to canonical hostname mapping</li>
      </ul>
      <li>Ex. CloudFlare, Route 53</li>
      <li>Router or ISP tells which DNS server to contact for IP lookup</li>
    </ul>

    <h4 class="card-title">FQDN (Fully Qualified Domain Name)</h4>
    <ul>
      <li>Complete domain name of computer, host, or internet</li>
      <li>Ex. www.github.com - [hostname].[domain].[tld (top-level-domain)]</li>
      <li>When connecting to a host, FQDN must be specified. Then, DNS server finds IP address from the hostname looking at DNS table</li>
    </ul>

    <h4 class="card-title">Example</h4>
    <table>
      <tr>
        <td>NAME</td>
        <td>TYPE</td>
        <td>VALUE</td>
      </tr>
      <tr>
        <td>bar.example.com</td>
        <td>CNAME</td>
        <td>foo.example.com</td>
      </tr>
      <tr>
        <td>foo.example.com</td>
        <td>A</td>
        <td>192.0.2.23</td>
      </tr>
    </table>
    <ul>
      <li>The canonical (true) name of "bar.example.com" is "foo.example.com"</li>
      <li>"foo.example.com" has A record pointing to IP address 192.0.2.23</li>
    </ul>

    <h4 class="card-title">DNS servers</h4>
    <ul>
      <li>DNS resolver - forward requests to the other DNS name servers</li>
      <ul>
        <li><code>/etc/resolv.conf</code> in Linux contains DNS resolver's IP address</li>
      </ul>
      <li>Root-level name servers - return a list of top-level domain (TLD) servers that hold the IP addresses of the domain (Doamin is for example .com, .org, .io)</li>
      <li>Top-level domain (TLD) name servers - hold the IP addresses of authoritative name servers</li>
      <li>Authoritative name servers - provide the IP addresses of the web or application servers</li>
    </ul>

    <h3 class="card-title">CDN</h3>
    <ul>
      <li>Geographically distributed proxy servers, that are placed on the network edge, close to end users</li>
      <li>Generally serves static content like image, video, CSS, JS</li>
      <li>Run by third party providers (Ex. Amazon CloudFront)</li>
    </ul>

    <h4 class="card-title">Push CDN</h4>
    <ul>
      <li>Content gets sent automatically to the CDN proxy servers from the origin server</li>
      <li>Appropriate for static content delivery and low traffic</li>
    </ul>

    <h4 class="card-title">Pull CDN</h4>
    <ul>
      <li>A CDN pulls the unavailable data from origin servers when requested by a user</li>
      <li>TTL determines how long content is cached on CDN</li>
      <li>Appropriate for dynamic content delivery and heavy traffic</li>
    </ul>

    <h3 class="card-title">Load balancer</h3>
    <ul>
      <li>GSLB (Global Server Load Balancing) distributes traffic across different geographical regions</li>
      <li>Private IP is used to communitcate between servers (reachable only within the same network, unreachable over internet)</li>
      <li>Redundancy</li>
      <ul>
        <li>Use multiple LBs so that they can't be single point of failure</li>
        <li>They monitor health of each other</li>
        <li>In case primary fails, the secondary takes over</li>
      </ul>
      <li>Ex. NGINX, HAProxy</li>
    </ul>

    <h4 class="card-text">Benefites</h4>
    <ul>
      <li>Throughput is improved by parallel processing</li>
      <li>Yield higher availability</li>
      <li>SSL offload - client connects to load balancer via SSL, but redirect requests to servers are made via unencrypted HTTP to reduce load on the servers</li>
      <ul>
        <li>Removes need to install X.509 certificates on each server</li>
      </ul>
      <li>Caching - load balancer can cache popular requests</li>
    </ul>

    <h4 class="card-text">Serving response back</h4>
    <ul>
      <li>Proxing - load balancer receives response from backend and relays it back to the client</li>
      <li>TCP Handoff - server sends response directly to the client</li>
    </ul>

    <h4 class="card-text">Types</h4>
    <ul>
      <li>Equitable dispatching - uses simple round-robin algorithm to distribute traffic evenly between all nodes. For example, Elastic Load Balancer (ELB) of AWS</li>
      <li>Hash-based distribution - requests from the same client for the duration of session are directed to the same server every time by hashing metadata. For example, Azure Load Balancer</li>
      <ul>
        <li>Pros - store session data in memory than shared data storage like Redis cache</li>
        <li>Cons - caching work causes small latency</li>
      </ul>
    </ul>

    <h4 class="card-title">Reverse proxy</h4>
    <ul>
      <li>Proxy hides identity of clients. Reverse proxy hides identity of servers</li>
      <li>Proxy sits on top of clients - used for blocking certain contents (servers are freely accessible through internet)</li>
      <li>Reverse proxy sit on top of servers - used for protection from attacks and SSL encrypting (clients can freely connect to internet)</li>
      <li>Can act as load-balancing but is also useful when there is a single server to increase security</li>
    </ul>

    <h3 class="card-title">Database</h3>
    <ul>
      <li>Performance and scalability - sepatate read and write server so that queries can be procesed in parallel</li>
      <li>Reliability - queries can still be served when some servers are down</li>
    </ul>

    <h4 class="card-title">Relational model</h4>
    <ul>
      <li>Attribute - a column</li>
      <li>Tuple - a row</li>
      <li>Degree - number of columns</li>
      <li>Cardinality - number of rows</li>
    </ul>

    <h4 class="card-title">Data types</h4>
    <ul>
      <li>Structured - relational data</li>
      <li>Semi-structured - ymal, json, xml</li>
      <li>Unstructured - photo, video, audio, text</li>
    </ul>

    <h4 class="card-title">Delete Vs. Truncate</h4>
    <ul>
      <li>Truncate - DDL (Data Definition Language), does not require commit to make the change permanent, deleted rows cannot be rolled back, always removes all rows from the table (Table structure remains intact)</li>
      <li>Delete - DML (Data Manipulation Language), requires commit to make the change permanent. <strong>where</strong> clause can be used</li>
    </ul>

    <h4 class="card-title">DB indexing</h4>
    <ul>
      <li>Applying indexing on a field creates a data structure holding field value and pointer</li>
      <li>Data structure gets sorted so that search time can be O(logn) with binary search</li>
      <li>Fields with lots of duplicate values degrade benefits of indexing</li>
      <li>Degrade write performance having to index data each time write happens</li>
    </ul>

    <h4 class="card-title">Transaction (ACID)</h4>
    <ul>
      <li>Atomicity - either all is done or none is done</li>
      <li>Consistency - data is consistent before and after transaction</li>
      <li>Isolation - trasaction doesn't get affected by other transactions</li>
      <li>Durablility - transactions are permanently saved</li>
    </ul>

    <h4 class="card-title">Tokenization vs Encryption</h4>
    <ul>
      <li>Tokenized data is irreversible. (Detokenization can only be done by the original tokenization system)</li>
      <li>Encryption is reversible with the key</li>
    </ul>

    <h4 class="card-title">Key</h4>
    <ul>
      <li>Primary key - unique identifier which consists of a single attribute. Cannot be NULL</li>
      <li>Candidate key - columns together can uniquely identify a row</li>
      <li>Super key - colums together can uniquely identify all columns</li>
      <li>Foreign key - primary key from another table</li>
      <ul>
        <li>Cannot insert foreign key (which is primary key in the original table) in reference table that does not actually exist in the original table</li>
        <li>Cannot delete primary key in the original table if it is used in the reference table</li>
      </ul>
    </ul>

    <h4 class="card-title">Functional dependency</h4>
    <ul>
      <li>Partial dependency - non-key attribute depends on subset of a composite primary key</li>
      <li>Transitive dependency - non-key attribute depends on another non-key attribute</li>
    </ul>

    <h4 class="card-title">Normalization</h4>
    <ul>
      <li>Process of determining how much redundancy exists in a table</li>
      <li>First normal form - attributes must have single value, not a set of values</li>
      <li>Second normal form - must not have partial dependency</li>
      <li>Third normal form - must not have transitive dependency</li>
      <li>Boyce-Codd normal form - If A->B and B is primary key, then A must also be primary key</li>
    </ul>

    <h4 class="card-title">SQL</h4>
    <ul>
      <li>Oracle, DB2, Microsoft SQL Server, PostgreSQL, and MySQL</li>
    </ul>

    <h4 class="card-title">NoSQL</h4>
    <ul>
      <li>Key-value store</li>
      <ul>
        <li>Array of key-value pairs</li>
        <li>Efficient for session-oriented applications like web applications, cache</li>
        <li>Ex. Redis, Voldemort, Amazon Dynamo DB, Memcached DB</li>
      </ul>
      <li>Document DB</li>
      <ul>
        <li>Documents (XML, JSON) are grouped into collections</li>
        <li>Suitable for unstructured catalog data</li>
        <li>Ex. CouchDB, MongoDB</li>
      </ul>
      <li>Column DB</li>
      <ul>
        <li>Columns instead of tables, no need to know columns up front, best for large datasets</li>
        <li>Ex. Cassandra, HBase</li>
      </ul>
      <li>Graph DB</li>
      <ul>
        <li>When relations are best represented in graphs</li>
        <li>Can be used in social applications</li>
        <li>Ex. Neo4J, OrientDB, InfiniteGraph</li>
      </ul>
      <li>Search engines</li>
      <ul>
        <li>Ex. Solr, ElasticSearch, Splunk</li>
      </ul>
    </ul>

    <h4 class="card-title">When to choose what</h4>
    <ul>
      <li>SQL - ACID, data is unchanging</li>
      <li>NoSQL - large amount of data with no structure, rapid development</li>
    </ul>

    <h3 class="card-title">Cache</h3>
    <ul>
      <li>When receiving requests, web servers check if cache has the responses</li>
    </ul>

    <h3 class="card-title">NoSQL</h3>
    <ul>
      <li>Store session data</li>
    </ul>

    <h3 class="card-title">Message queue</h3>
    <ul>
      <li>Decoupling producer and consumer makes system scalable and reliable</li>
    </ul>

    <h3 class="card-title">Data center</h3>
    <ul>
      <li>Data is replicated across data centers</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: System Design Interview, Alex Xu | <a href="https://github.com/donnemartin/system-design-primer">The System Design Primer</a>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Non-functional requirements</h2>

    <h3 class="card-title">Availability</h3>
    <ul>
      <li>Percentage of time that the service is accessible to clients (Associated with time loss)</li>
      <li>Ability of the system to remain functional despite failures</li>
      <li>Achieved by replication (Keep multiple copies of data at preferrably different geographic location)</li>
      <li>Reliability means availability, but the opposite is not true</li>
    </ul>

    <h4 class="card-title">Fail over</h4>
    <ul>
      <li>Acive-passive</li>
      <ul>
        <li>Heartbeats are sent from active to passive</li>
        <li>If heartbeats are stopping, passive takes over IP address of active and resumes service</li>
      </ul>
      <li>Acive-active</li>
      <ul>
        <li>Both servers are managing traffic, spreading load between them</li>
      </ul>
    </ul>

    <h4 class="card-title">Replication</h4>
    <ul>
      <li>Single-master replication / primary-backup replication</li>
      <ul>
        <li>Primary processes updates/writes locally and propagates to backups</li>
        <li>Scalable for read-heavy (read can happen from any backups) but not so for write-heavy (only primary can handle writes)</li>
        <li>Statement based replication</li>
        <ul>
          <li>Problem: non-deterministic functions such as NOW() or RAND() lead to different values on different nodes</li>
        </ul>
        <li>Write-ahead log (WAL) shipping</li>
        <ul>
          <li>Primary node saves the query before executing it in a log file</li>
          <li>Then, it uses these logs to copy data into the backup nodes</li>
        </ul>
        <li>Logical (row-based) log replication</li>
        <ul>
          <li>All backup nodes replicate the actual data changes</li>
        </ul>
      </ul>
      <li>Multi-master replication / multi-primary replication</li>
      <ul>
        <li>Multiple primary nodes that process the writes and send them to all other primary and backup nodes to replicate</li>
        <li>Conflict can happen where mutiple nodes modify the same data</li>
      </ul>
      <li>Leaderless replication</li>
      <ul>
        <li>Always write or read from a majority (more than half) of the number of nodes in the system</li>
        <li>The latest value is written to at least one of the nodes in the system</li>
      </ul>
    </ul>

    <h3 class="card-title">Scalability</h3>
    <ul>
      <li>Capability to manage increased demand (For example, number of requests or amounts of data)</li>
      <ul>
        <li>Performance problem - system is slow for a single user</li>
        <li>Scailability problem - system is fast for a single user but slow under heavy load</li>
      </ul>
      <li>Vertical scaling / Scaling up - Adds more resources to a single instance</li>
      <li>Horizontal scaling / scaling out - Addition more instances</li>
      <li>Compute load patterns</li>
      <ul>
        <li>Consistent growth</li>
        <li>Constantly fluctuating loads</li>
        <li>Cyclical loads</li>
        <li>Unpredictable bursts</li>
      </ul>
    </ul>

    <h4 class="card-title">Data partitioning </h4>
    <ul>
      <li>Vertical partitioning</li>
      <ul>
        <li>Divides tables into different servers based on features of data (Split columns)</li>
        <li>Problem when data experiences additional growth</li>
        <li>Queries must hit multiple servers and join operations are needed</li>
      </ul>
      <li>Horizontal partitioning (Sharding)</li>
      <ul>
        <li>Puts different rows to different tables</li>
        <li>Atomic operation is hard to achieve</li>
        <li>It is cheaper to add more servers than growing the existing server as data increases</li>
        <li>Range partitioning</li>
        <ul>
          <li>Split dataset based on specific attribute</li>
          <li>Range based query is easy to implement</li>
          <li>May result in unbalanced servers</li>
        </ul>
        <li>Hash partitioning</li>
        <ul>
          <li>Apply hash function to some attribute of data and mod that hash value by the number of paritions</li>
          <li>Uniform allocation of data across servers</li>
          <li>Range based query is hard to implement</li>
          <li>Adding new servers mean changing hash function and redistribution of data</li>
        </ul>
        <li>Consistent hashing</li>
        <ul>
          <li>Create conceptual ring of hashes from 0 to n−1, where n is the number of available hash values</li>
          <li>Each node and request are put into the ring based on its hash value</li>
          <li>Each request is served by the next node in the ring</li>
          <li>When a new node is added to the ring, its next node need to share keys with the newly added node</li>
          <li>Some node could be heavily loaded compared to others</li>
          <li>Virtual node</li>
          <ul>
            <li>Each node is put into multiple positions in the ring based on multiple hash functions</li>
            <li>Each node can have different number of virtual nodes based on hardware capability</li>
            <li>Load is more uniform</li>
            <li>Used in Dynamo and Cassandra</li>
          </ul>
          <li>Fixed number of partitions</li>
          <ul>
            <li>Number of partitions is fixed when DB is setup</li>
            <li>Higher number of partitions are created than the nodes</li>
            <li>Paritions are assigned to nodes</li>
            <li>If partition is too small, results in overhead. If partition is too large, rebalancing the nodes will be expensive</li>
            <li>Used in Elasticsearch</li>
          </ul>
          <li>Dynamic partitioning</li>
          <ul>
            <li>When the size of a partition reaches the threshold, it is split into two partitions</li>
            <li>Difficult to apply dynamic rebalancing while serving the reads and writes</li>
            <li>Used in HBase and MongoDB</li>
          </ul>
          <li>Partition proportionally to nodes</li>
          <ul>
            <li>Number of partitions is proportionate to the number of nodes, so that every node has fixed partitions</li>
            <li>As the number of nodes increases, the partitions shrink. Rebalancing between paritions may result in unfair split</li>
            <li>Used in Cassandra</li>
          </ul>
        </ul>
      </ul>
    </ul>

    <h4 class="card-title">Caching</h4>
    <ul>
      <li>Store frequently used data for fast retrieval</li>
      <li>Could be placed at database or application layer</li>
    </ul>

    <h4 class="card-title">Autoscaling</h4>
    <ul>
      <li>Dynamically allocate resources to match performance requirements</li>
    </ul>

    <h4 class="card-title">Background jobs</h4>
    <ul>
      <li>Tasks such as batch jobs, intensive processing tasks, and long-running processes should run as background jobs, decoupled from application UI to minimize load</li>
    </ul>

    <h4 class="card-title">Messaging</h4>
    <ul>
      <li>Requests can continue to flow-in without error if application can’t keep up</li>
    </ul>

    <h4 class="card-title">Scale units</h4>
    <ul>
      <li>Define units for scaling</li>
    </ul>

    <h3 class="card-title">Consistency</h3>
    <ul>
      <li>Considers single object operations</li>
    </ul>

    <h4 class="card-title">Strong consistency / linearizability</h4>
    <ul>
      <li>Synchronous replication technique (Acknowledgment is not sent to the client until the new value is written to all replicas)</li>
      <li>Once an operation is complete and the ack is delivered to client, it is visible to all other clients</li>
      <li>Ex. updating account password</li>
    </ul>

    <h4 class="card-title">Sequential consistency</h4>
    <ul>
      <li>Preserves the ordering specified by each client’s program</li>
      <li>For example, we don't care what’s the ordering of posts between our friends. But, the posts from a single friend has to be displayed in the right order</li>
    </ul>

    <h4 class="card-title">Causal consistency</h4>
    <ul>
      <li>Operations that are not causally related can be seen in different orders</li>
      <li>For example, comments and their sub-comments must appear in the right order</li>
    </ul>

    <h4 class="card-title">Eventual consistency</h4>
    <ul>
      <li>Do not need to return the latest write as long as the system eventually arrives at a stable state</li>
      <li>Can achieve high availability</li>
      <li>Ex. DNS, Cassandra</li>
    </ul>

    <h4 class="card-title">Weak consistency</h4>
    <ul>
      <li>Read may or may not see the written data</li>
      <li>Ex. Memcached</li>
    </ul>

    <h3 class="card-title">Reliability</h3>
    <ul>
      <li>Probability that the service will perform its functions (Associated with frequency and impact of failure)</li>
      <li>Metrics are mean time between failures and mean time to repair</li>
      <li>Redunduncy of both software components and data</li>
    </ul>

    <h3 class="card-title">Maintainability</h3>
    <ul>
      <li>Probability that the service will restore its function (When broken)</li>
      <li>Workload can be number of requests or amounts of data</li>
      <li>Metrics are mean time to repair</li>
    </ul>

    <h3 class="card-title">Fault tolerance</h3>
    <ul>
      <li>Ability to continue to perform when some components fail</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a> | <a href="https://github.com/donnemartin/system-design-primer">The System Design Primer</a>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Distributed System</h2>

    <h3 class="card-title">Distributed system challenges</h3>
    <ul>
      <li>Network asynchrony: messages take long to deliver, deliver out of order, or not deliver at all.</li>
      <li>Partial failures: only some components fail.</li>
      <li>Concurrency: execution of multiple computations intervene each other.</li>
    </ul>

    <h3 class="card-title">Failure types</h3>
    <ul>
      <li>Fail-stop: a node halts and remains halted permanently. (Easiest scenario)</li>
      <li>Crash: a node halts, but silently.</li>
      <li>Omission: a node fails to respond to incoming requests.</li>
      <li>Byzantine: a node exhibits arbitrary behavior.</li>
    </ul>

    <h3 class="card-title">State</h3>
    <ul>
      <li>Stateless: maintains no state. Performs purely based on the inputs.</li>
      <li>Stateful: maintains and updates states. Results depend on this state.</li>
    </ul>

    <h3 class="card-title">Quorum</h3>
    <ul>
      <li>We write data to the nodes that are only resposible for write operations. We read data from all nodes and return the latest value.</li>
      <ul>
        <li>Write is successful when w-1 nodes respond. (Coordinator writes to itself first, so we get w writes in total)</li>
        <li>Wait for r answers before returning the results to the client.</li>
      </ul>
      <li>Quorum is achieved when R + W > N. At least one node should be both read and write so that readers could get the latest-written value.</li>
      <li>If w > r, fast write but slow read because need to go to many nodes for a value.</li>
      <li>If r > w, fast read but slow write because need to write to many nodes synchronously.</li>
    </ul>

    <h3 class="card-title">CAP theorem</h3>
    <ul>
      <li>It is impossible to acheive all three at the same time. We can only have two out of three</li>
      <ul>
        <li>Consistency - all nodes see the same data at the same time, every read received the most recent write</li>
        <li>Availability - system must be accessible even when nodes fail, every request receives a response</li>
        <li>Partition tolerance - system must operate even when communications between nodes break</li>
      </ul>
      <li>Network is not reliable, thus we need to support partition tolerance</li>
      <li>We can only choose between consistency or availability in distributed system</li>
      <ul>
        <li>CA - RDBMS (Non-distributed system)</li>
        <li>AP - Dynamo, Cassandra, CouchDB (BASE DBs choose availability - respond with local data w/o ensuring its the latest with peers)</li>
        <ul>
          <li>Good choice if system can live with eventual consistency</li>
        </ul>
        <li>CP - BigTable, HBase (ACID DBs choose consistency - refuse to respond if cannot check peers)</li>
      </ul>
    </ul>

    <h3 class="card-title">PACELC theorem</h3>
    <ul>
      <li>When there is no network partition during normal operation, then choose between latency or consistency</li>
      <li>To guarantee data consistency, the system will have to delay write operations until the data has been propagated across the system successfully, taking a latency hit</li>
      <li>PA system would go for L (latency) and PC system would go for C (consistency)</li>
    </ul>

    <p class="card-text"><strong>Systems that choose A over C can still support eventual consistency but no linearizability/sequential/casual!</strong></p>

    <h3 class="card-title">Isolation level</h3>
    <ul>
      <li>Considers multi object operations.</li>
    </ul>

    <h4 class="card-title">Serializability</h4>
    <ul>
      <li>Two transactions executed concurrently should give same result.</li>
      <li>Prevents all anomalies.</li>
    </ul>

    <h4 class="card-title">Repeatable read</h4>
    <ul>
      <li>Data once read by a transaction will not change throughout its course.</li>
    </ul>

    <h4 class="card-title">Snapshot isolation</h4>
    <ul>
      <li>All reads made in a transaction see a consistent snapshot of the database.</li>
    </ul>

    <h4 class="card-title">Read committed</h4>
    <ul>
      <li>Does not allows a transaction to read a data that has not yet been committed by other transaction.</li>
    </ul>

    <h3 class="card-title">Anomaly</h3>

    <h4 class="card-title">Dirty write</h4>
    <ul>
      <li>Transaction overwrites a value that was written by another transaction that is not committed yet.</li>
    </ul>

    <h4 class="card-title">Dirty read</h4>
    <ul>
      <li>Transaction reads a value that was written by another transaction that is not committed yet.</li>
    </ul>

    <h4 class="card-title">Fuzzy or non-repeatable read</h4>
    <ul>
      <li>Value is retrieved twice during a transaction and the value is different.</li>
    </ul>

    <h4 class="card-title">Phantom read</h4>
    <ul>
      <li>For example, transaction of two queries runs to calculate the maximum and the average. However, another transaction intervenes to insert lots of record, thus making the first transaction return an average that is larger than the maximum.</li>
    </ul>

    <h4 class="card-title">Lost update</h4>
    <ul>
      <li>Two transactions read the same value and then try to update it to two different values.</li>
    </ul>

    <h4 class="card-title">Read skew</h4>
    <ul>
      <li>A transaction can only see partial results of another transaction.</li>
    </ul>

    <h4 class="card-title">Dirty write</h4>
    <ul>
      <li>Two transactions read the same data, but then modify disjoint sets of data.</li>
    </ul>

    <h3 class="card-title">RPC</h3>
    <ul>
      <li>For building applications on top of distributed system.</li>
    </ul>

    <h4 class="card-title">RPC process</h4>
    <ul>
      <li>Client initiates client stub process by giving parameters.</li>
      <li>Client stub converts the parameters into standardized format and packs them into a message.</li>
      <li>Client RPC runtime delivers the message to the server over the network.</li>
      <li>Server RPC runtime receives the message and passes it to the server stub.</li>
      <li>Server stub unpacks the message to retrieve the parameters and calls the desired server routine.</li>
      <li>Server stub packs the returned result into a message and sends it to RPC runtime at the server.</li>
      <li>Server RPC runtime returns the packed result to Client RPC runtime over the network.</li>
      <li>Client RPC runtime sends the result to the client stub.</li>
      <li>Client stub unpacks the result.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Back-of-the-envelop</h2>

    <h3 class="card-title">Web servers</h3>
    <ul>
      <li>Typically serve static content to client (Web browser)</li>
      <li>Usually handle API calls from clients</li>
    </ul>

    <h3 class="card-title">App servers</h3>
    <ul>
      <li>Typically serve dynamic content to client</li>
      <li>Core business logic</li>
    </ul>

    <h3 class="card-title">Important latencies (in nanoseconds)</h3>
    <table>
      <tr>
        <td>L1 cache reference</td>
        <td>0.9</td>
      </tr>
      <tr>
        <td>L2 cache reference</td>
        <td>2.8</td>
      </tr>
      <tr>
        <td>L3 cache reference</td>
        <td>12.9</td>
      </tr>
      <tr>
        <td>Main memory reference</td>
        <td>100</td>
      </tr>
      <tr>
        <td>Compress 1KB with Snzip</td>
        <td>3,000 (3 microseconds)</td>
      </tr>
      <tr>
        <td>Read 1 MB sequentially from memory</td>
        <td>9,000 (9 microseconds)</td>
      </tr>
      <tr>
        <td>Read 1 MB sequentially from SSD</td>
        <td>200,000 (200 microseconds)</td>
      </tr>
      <tr>
        <td>Round trip within same datacenter</td>
        <td>500,000 (500 microseconds)</td>
      </tr>
      <tr>
        <td>Read 1 MB sequentially from SSD with speed ~1GB/sec SSD</td>
        <td>1,000,000 (1 milliseconds)</td>
      </tr>
      <tr>
        <td>Disk seek</td>
        <td>4,000,000 (4 milliseconds)</td>
      </tr>
      <tr>
        <td>Read 1 MB sequentially from disk</td>
        <td>2,000,000 (2 milliseconds)</td>
      </tr>
      <tr>
        <td>Send packet SF->NYC</td>
        <td>71,000,000 (71 milliseconds)</td>
      </tr>
    </table>

    <h3 class="card-title">Important rates</h3>
    <table>
      <tr>
        <td>QPS handled by MySQL</td>
        <td>1000</td>
      </tr>
      <tr>
        <td>QPS handled by key-value store</td>
        <td>10,000</td>
      </tr>
      <tr>
        <td>QPS handled by cache server</td>
        <td>100,000–1 M</td>
      </tr>
    </table>

    <h3 class="card-title">Availability numbers</h3>
    <table>
      <tr>
        <th>Availability</th>
        <th>Downtime per day</th>
        <th>Downtime per year</th>
      </tr>
      <tr>
        <td>99%</td>
        <td>14.40 minutes</td>
        <td>3.65 days</td>
      </tr>
      <tr>
        <td>99.9%</td>
        <td>1.44 minutes</td>
        <td>8.77 hours</td>
      </tr>
      <tr>
        <td>99.99%</td>
        <td>8.64 seconds</td>
        <td>52.6 minutes</td>
      </tr>
      <tr>
        <td>99.99%</td>
        <td>0.864 seconds</td>
        <td>5.26 minutes</td>
      </tr>
      <tr>
        <td>99.99%</td>
        <td>0.0864 seconds</td>
        <td>31.56 seconds</td>
      </tr>
    </table>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>

<div class="card mb-4" id="system-design-">
  <div class="card-body">
    <h2 class="card-title">Resource estimation</h2>

    <h3 class="card-title">Request per second</h3>
    <ul>
      <li>Assume</li>
      <ul>
        <li>Server has 36 cores (72 threads), 256GB RAM</li>
        <li>OS and other processes consumed 16GB RAM</li>
        <li>Each worker consumes 300MB RAM to complte a request</li>
        <li>Each CPU-bound request takes 200 millisecond</li>
        <li>Each memory-bound request takes 50 milliseconds</li>
      </ul>
      <li>RPS (CPU) = number of thread / time each task takes = 72 / 200ms = 360 RPS</li>
      <li>RPS (RAM) = Available memory / (time each task takes * worker memory comsumption) = 240GB / (50ms * 300MB)= 16,000 RPS</li>
      <li>Assume half requests are CPU bound and half requests are memory bound: 360 / 2 + 16,000 / 2 = 8,000 RPS</li>
    </ul>

    <h3 class="card-title">Estimate number of servers</h3>
    <ul>
      <li>Assume 500M daily users and 20 request per day on average</li>
      <ul>
        <li>Then, it is 500M * 20 = 10B requests per day, which is 115K requests per seconds (RPS)</li>
        <li>But if all users make a request at the same time, it is 500M * 1 = 500M requests per second (RPS)</li>
      </ul>
      <li>Assume a server can handle 8,000 RPS</li>
      <ul>
        <li>It looks like 15 servers can handle 500M users if load is evenly spread throughout the day</li>
        <li>However, at the peak, 500M / 8,000 = 62,000 servers are needed</li>
      </ul>
    </ul>

    <h3 class="card-title">Estimate storage</h3>
    <ul>
      <li>Assume 250M daily active users and each user makes 3 write requests per day</li>
      <li>Assume 10% contains images, 5% contains videos, 85% contain just text</li>
      <li>Assume each image is 200KB, video is 3MB, and text is 250 bytes</li>
      <li>Storage required: (250M * 3) * (0.1 * 200KB + 0.05 * 3MB + 0.85 * 250 bytes) = 128MB per day</li>
    </ul>

    <h3 class="card-title">Estimate bandwitdth</h3>
    <ul>
      <li>Incoming traffic: (128 MB per day / 86400 seconds per day) * 8 bits per byte = 11.8Kbps</li>
      <li>Assume each user make 50 read requests per day</li>
      <li>Outgoing traffic: (12Kbps / 3) * 50 = 197.5Kbps</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/path/deep-dive-into-system-design-interview">Deep Dive into System Design Interview</a>
  </div>
</div>
<!-- System design END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>