<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- Hash table BEGIN -->
<div class="card mb-4" id="hashtable">
  <div class="card-body">
    <h2 class="card-title">Hash table</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#hashtable-1">Two sum</a></li>
      <li><a href="#hashtable-2">Longest substring without repeating characters</a></li>
      <li><a href="#hashtable-3">Substring with concatenation of all words</a></li>
      <li><a href="#hashtable-4">Group anagrams</a></li>
      <li><a href="#hashtable-5">Max points on a line</a></li>
      <li><a href="#hashtable-6">Longest palindrome</a></li>
      <li><a href="#hashtable-7">Next greater element I</a></li>
      <li><a href="#hashtable-8">Design hashMap</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="hashtable-1">
  <div class="card-body">
    <h2 class="card-title">Two sum (E) (Interview/Liked)</h2>

<pre><code class="python">class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:

        my_dict = {}
        for i, num in enumerate(nums):
            my_dict[num] = i

        for i, num in enumerate(nums):
            print(target-num)
            if target-num in my_dict and i != my_dict[target-num]:
                return [i, my_dict[target-num]]

        return []</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/two-sum">1. Two Sum</a>
  </div>
</div>

<div class="card mb-4" id="hashtable-2">
  <div class="card-body">
    <h2 class="card-title">Longest substring without repeating characters (M) (Interview/Liked)</h2>

<pre><code class="python">class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:

        # Time: O(n)
        # Space: O(n)
        # n = length of input string

        # Move the end pointer until seeing repeating chars.
        # Move the start pointer until substring has no repeating chars.
        # Keep the max diff between end and start pointer.
        # Scan finished when both start and end pointers reach the end of string.

        start = 0
        max_length = 0
        char_map = {}  # Store chracter and its index.

        for i,c in enumerate(s):

            # If duplicate is found, compute the length using start and the i pointer.
            # The second condition ensures that we are only looking at the substring
            # after the start index.
            if c in char_map and char_map[c] >= start:
                max_length = max(max_length, i-start)
                # Move the start pointer to plus 1 of the index where the duplicate is.
                start = char_map[c] + 1
            char_map[c] = i

        max_length = max(max_length, len(s)-start)

        return max_length</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters">3. Longest Substring Without Repeating Characters</a>
  </div>
</div>

<div class="card mb-4" id="hashtable-3">
  <div class="card-body">
    <h2 class="card-title">Substring with concatenation of all words (H)</h2>

<pre><code class="python">class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        result = []

        # For this problem, all words have the same length.
        word_length = len(words[0])
        substring_length = word_length * len(words)
        words_converted_to_dict = {}
        for word in words:
            if word in words_converted_to_dict:
                words_converted_to_dict[word] += 1
            else:
                words_converted_to_dict[word] = 0

        # Example: "goodgoodbestword"
        #          ["word","good","best","word"]

        # Run sliding window of substring through s.
        # Time: O(kn) where k = n / word_legnth.
        # Space: O(k) where k = n / word_legnth.
        for i in range(len(s)-substring_length+1):
            # print(i)
            # print(s[i:i+substring_length])

            # Check s[i:substring_length] can be constructed by words.
            # If so, append i to result.

            string_splitted_into_words = {}
            string = s[i:i+substring_length]
            j = 0
            while j < len(string):
                word = string[j:j+word_length]
                # Increment the occurance by 1.
                if word in string_splitted_into_words:
                    string_splitted_into_words[word] += 1
                # Initialize the occurance to 0.
                else:
                    string_splitted_into_words[word] = 0
                j += word_length

            if words_converted_to_dict == string_splitted_into_words:
                result.append(i)

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words">30. Substring with Concatenation of All Words</a>
  </div>
</div>

<div class="card mb-4" id="hashtable-4">
  <div class="card-body">
    <h2 class="card-title">Group anagrams (M) (Interview/Liked)</h2>

<pre><code class="python"></code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/group-anagrams">49. Group Anagrams</a>
  </div>
</div>

<div class="card mb-4" id="hashtable-5">
  <div class="card-body">
    <h2 class="card-title">Max points on a line (H) (Interview)</h2>

<pre><code class="python">from collections import defaultdict

class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:

        if len(points) <= 1:
            return len(points)

        result = 1

        # Compute the slope between all pairs of points.
        # Most frequent slope will form the line.
        for i in range(len(points)):
            # Create a new dictionary for each point!
            frequency = defaultdict(int)
            for j in range(i+1, len(points)):
                if points[i][0] != points[j][0]:
                    slope = (points[i][1]-points[j][1]) / (points[i][0]-points[j][0])
                    # slope = round(slope, 3)
                    frequency[slope] += 1
                    result = max(frequency[slope], result)
                # In case of infinite slope (Or vertical line)
                else:
                    frequency[math.inf] += 1
                    result = max(frequency[math.inf], result)

        return result+1</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/max-points-on-a-line">149. Max Points on a Line</a>
  </div>
</div>

<div class="card mb-4" id="hashtable-6">
  <div class="card-body">
    <h2 class="card-title">Longest palindrome (E)</h2>

<pre><code class="python">class Solution:
    def longestPalindrome(self, s: str) -> int:

        # If every letter has even count, then count(s)
        # Else, round down count for each char + 1

        count = {}

        for char in s:
            if char not in count:
                count[char] = 1
            else:
                count[char] += 1

        max_length = 0
        is_all_count_even_number = True
        for key,val in count.items():
            if val % 2 == 0:
                max_length += val
            else:
                is_all_count_even_number = False
                max_length += (val-1)

        if is_all_count_even_number:
            return max_length
        else:
            return max_length + 1</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/longest-palindrome/">409. Longest Palindrome</a>
  </div>
</div>

<div class="card mb-4" id="hashtable-7">
  <div class="card-body">
    <h2 class="card-title">Next greater element I (E)</h2>

<pre><code class="python">class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:

        # Loop through nums2 in reverse
        # 1. Last num is nums2 will always result in -1
        # 2. If decreasing, the previous is the result
        #    Store this previous number is stack
        # 3. If increasing, result is the first larger
        #    number (than the current value) in the stack
        #    Pop out numbers less than current value in the stack

        # [4,1,2]
        # [1,3,4,2]
        # stack: [-1,4,3]
        # dict: {2:-1, 4:-1, 3:4, 1:3}

        # [1,3,5,2,4]
        # [6,5,4,3,2,1,7]
        # stack: [-1,7]
        # dict: {7:-1, 1:7, 2:7, 3:7, 4:7, 5:7, 6:7}

        nums2_dict = {}
        stack = [-1]
        # Time O(n)
        nums2.reverse()
        # Dictionary is guaranteed to be unique since
        # arrays contain distinct numbers.
        nums2_dict[nums2[0]] = stack[-1]

        # Time O(n)
        # Space O(n)
        for i in range(1, len(nums2)):
            # Increasing
            if nums2[i] > nums2[i-1]:
                while len(stack) > 1:
                    if nums2[i] > stack[-1]:
                        stack.pop()
                    else:
                        break
                nums2_dict[nums2[i]] = stack[-1]
            # Decreasing
            else:
                stack.append(nums2[i-1])
                nums2_dict[nums2[i]] = stack[-1]

        # Time O(n)
        # Space O(n)
        result = []
        for num in nums1:
            if num in nums2_dict:
                result.append(nums2_dict[num])

        return result</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/next-greater-element-i/">496. Next Greater Element I</a>
  </div>
</div>

<div class="card mb-4" id="hashtable-8">
  <div class="card-body">
    <h2 class="card-title">Design hashMap (E)</h2>

<pre><code class="python"></code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/design-hashmap">706. Design HashMap</a>
  </div>
</div>
<!-- Hash table END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>