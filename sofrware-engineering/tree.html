<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js"></script>
<script src="/js/bootstrap.bundle.min.js"></script>
<script src="/js/highlight.pack.js"></script>
<script type="text/javascript" src="/js/include_html.js"></script>
<script type="text/javascript" src="/js/site.js"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- Tree BEGIN -->
<div class="card mb-4" id="tree">
  <div class="card-body">
    <h2 class="card-title">Tree</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#tree-1">Tree</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="tree-1">
  <div class="card-body">
    <h2 class="card-title">Tree</h2>
    <p class="card-text"></p>

<pre><code class="python">class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right</code></pre>

    <h3 class="card-title">Heap (priority queue)</h3>
    <ul>
      <li>Perfectly balanced tree.</li>
      <li>Root element must have the minimum key.</li>
      <li>Runtime</li>
      <ul>
        <li>Insert (add to heap): O(nlogn).</li>
        <li>Extract (remove an element with minimum key): O(nlogn).</li>
        <li>Heapify (n batched inserts): O(n).</li>
        <li>Delete: O(nlogn).</li>
      </ul>
    </ul>

<pre><code class="python"># Insert(key k)
#     stick k at the end of last level
#     bubble-up k until k's parent <= k</code></pre>

<pre><code class="python"># Extract-Min
#     delete root
#     move last node to new root
#     bubble-down k until k's parent <= k</code></pre>

    <h3 class="card-title">Binary search tree</h3>
    <ul>
      <li>Exactly one node per key.</li>
      <li>Each node has</li>
      <ul>
        <li>Left child pointer</li>
        <li>Right child pointer</li>
        <li>Parent</li>
      </ul>
      <li>All nodes left on node X are less than X.</li>
      <li>All nodes right on node X are greater than X.</li>
      <li>Many possible trees for a set of keys.</li>
      <li>Height could be anywhere from log_{2}^{n} to n.</li>
      <li>Generally operations are O(height).</li>
    </ul>

<pre><code class="python"># Search(key k)
#     start at the root
#     traverse left (if k < key at current node) or right (if k > key at current node) child pointers as needed
#     return node with key k or NULL, as appropriate</code></pre>

<pre><code class="python"># Insert(key k)
#     start at the root
#     do search (which will return NULL)
#     rewire final NULL pointer to point to new node with key k</code></pre>

<pre><code class="python"># Min/Max
#     start at the root
#     follow left (min case) or right (max case) until the bottom (return last key found)</code></pre>

<pre><code class="python"># Pred(key k)
#     easy case: if k's left subtree nonempty, return max key in left subtree
#     otherwise: follow parent pointers until you get to a key less than k</code></pre>

<pre><code class="python"># Inorder traversal
#     to print out keys in increasing order
#     let r = root, Tr = right subtree, Tl = left subtree
#     recurse on Tl
#         by recursion, prints out keys of TL in increasing order
#     print out r's key
#     recurse on Tr
#         by recursion, prints out keys of TR in increasing order</code></pre>

<pre><code class="python"># Delete(key k)
#     search for k
#     if k has no children
#         delete k
#     k has one child
#         delete k, and put child under k's parent
#     k has two children
#         compute k's predecessor l
#             for example, traverse k's (non-NULL) left child pointer, then right child pointers until no longer possible
#         swap k and l
#         delete k</code></pre>

<pre><code class="python"># Select(order statistic i)
#     store a little bit of extra info at each tree node about the tree itself
#     start at root x, with children y and z
#     let a = size(y) # a = 0 if x has no left child
#     if a = i-1
#         return x's key
#     if a >= i
#         recurse to compute ith order statistic on new root y
#     if a < i-1
#         recurse to compute (i-a-1)th order statistic on new root z</code></pre>

    <h3 class="card-title">Balanced search tree (sorted array with fast insert & delete)</h3>
    <ul>
      <li>Search: O(logn).</li>
      <li>Select: O(logn).</li>
      <li>Min/Max: O(logn).</li>
      <li>Pred/Succ: O(logn).</li>
      <li>Rank: O(logn).</li>
      <li>Output in sorted order: O(n).</li>
      <li>Insert/Delete: O(logn).</li>
    </ul>

    <h4 class="card-title">Red-Black tree</h4>
    <ul>
      <li>Each node red or black.</li>
      <li>Root is black.</li>
      <li>No 2 reds in a row. (red node => only black children)</li>
      <li>Every root-NULL path (unsuccessful search) has the same number of black nodes.</li>
      <li>Height guarantee.</li>
      <ul>
        <li>Every red-black tree with n nodes has height less than or equal to 2log_{2}(n+1)</li>
      </ul>
      <li>Rotation.</li>
      <ul>
        <li>Locally rebalance subtrees at a node in O(1) time.</li>
        <li>Left rotation.</li>
        <li>Right rotation.</li>
      </ul>
    </ul>

<pre><code class="python"># Insert(x)
#     insert x as usual (makes x a leaf)
#     try coloring x red
#     if x's parent y is black, done
#     else y is red, then y has a black parent w</code></pre>

  </div>
  <div class="card-footer text-muted">

  </div>
</div>
<!-- Tree END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>