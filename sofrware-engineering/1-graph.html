<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- Graph BEGIN -->
<div class="card mb-4" id="graph">
  <div class="card-body">
    <h2 class="card-title">Graph</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#graph-1">Graph</a></li>
      <li><a href="#graph-2">DFS</a></li>
      <li><a href="#graph-3">BFS</a></li>
      <li><a href="#graph-4">DFS or BFS Examples</a></li>
      <li><a href="#graph-5">Union-Find</a></li>
      <li><a href="#graph-6">Dijkstra</a></li>
      <li><a href="#graph-7">Bellman-Ford</a></li>
      <li><a href="#graph-8">Word ladder</a></li>
      <li><a href="#graph-9">Surrounded regions</a></li>
      <li><a href="#graph-10">Number of islands</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="graph-1">
  <div class="card-body">
    <h2 class="card-title">Graph</h2>

    <h3 class="card-title">Representation</h3>
    <ul>
      <li>Adjacency list is space-wise more efficient than list of lists.</li>
      <li>Dictionary can be used where key is each node and value is Python Set of nodes.</li>
    </ul>

<pre><code class="python"># Convert list of lists to adjacency list.

from collections import defaultdict

# Directed graph.

graph = defaultdict(set)

for edge in edges:
    graph[edge[1]].add(edge[0])

# Undirected graph.

graph = {}

for edge in edges:
    graph[edge[1]].add(edge[0])
    graph[edge[0]].add(edge[1])</code></pre>
  </div>
  <div class="card-footer text-muted">

  </div>
</div>

<div class="card mb-4" id="graph-2">
  <div class="card-body">
    <h2 class="card-title">DFS</h2>

    <ul>
      <li>Explore aggressively, only backtrack when necessary.</li>
      <li>O(n+m) using stack.</li>
    </ul>

<pre><code class="python">def dfs(start_node, graph):
    stack = []
    stack.append(start_node)

    explored = set()
    explored.add(start_node)

    while stack:
        node = stack.pop()
        for next_node in graph[node]:
            if next_node not in explored:
                explored.add(next_node)
                stack.append(next_node)</code></pre>

    <h3 class="card-title">Detect cycle</h3>

<pre><code class="python">def is_cycle(start_node, graph):
    stack = []
    stack.append(start_node)

    explored = set()
    explored.add(start_node)

    while stack:
        node = stack.pop()
        for next_node in graph[node]:
            if next_node not in explored:
                explored.add(next_node)
                stack.append(next_node)
            else:
                if next_node == start_node:
                    return True

    return False</code></pre>

    <h3 class="card-title">Topological ordering</h3>
    <ul>
      <li>Approach #1: Remove leaf nodes recursively from the graph while adding leaf nodes to result.</li>
      <li>Approach #2: Remove root nodes recursively from the graph while adding root nodes to result.</li>
      <li>Approach #3: Do DFS starting at each node counting the number of steps each starting node takes to finish DFS.</li>
      <ul>
        <li>If starting node has only small number of children or even no children, DFS will finish quickly.</li>
        <li>If starting node has lots of children, DFS will take time to finish.</li>
      </ul>
    </ul>

<pre><code class="python">def topological_order(graph, num_nodes):

    ordering = []

    for i in range(num_nodes):
        count = self.dfs(i, graph)
        # If cycle.
        if count == -1:
            return []
        ordering.append([count, i])

    ordering.sort(key=lambda x:(-x[0]))

    return [item[1] for item in ordering]

def dfs(self, start_node, graph):
    stack = []
    stack.append(start_node)
    count = 1

    explored = set()
    explored.add(start_node)

    while stack:
        node = stack.pop()
        for next_node in graph[node]:
            if next_node not in explored:
                explored.add(next_node)
                stack.append(next_node)
                count += 1
            else:
                if next_node == start_node:
                    return -1

    return count</code></pre>

    <h3 class="card-title">Strongly connected components</h3>
    <ul>
      <li>There exist path u to v and v to u in graph G.</li>
      <li>Kosaraju's two pass algorithm</li>
      <ul>
        <li>Compute SCC in O(m+n).</li>
        <li>Let G' = G with all arcs reversed.</li>
        <li>Run DFS_loop on G' (compute magical ordering of nodes)</li>
        <li>Run DFS_loop on G (compute strongly connected component one by one)</li>
      </ul>
    </ul>

<pre><code class="python"># dfs_loop(graph G)
#     global variable t=0 # number of nodes processed so far
#     global variable s=null # current source vertex
#     assumes nodes labelled 1 to n
#     for i = n to 1
#         if i not explored
#             s = i
#             DFS(G, i)

# dfs(graph G, node i)
#     mark i as explored
#     set leader(i) = node s
#     for each arc (i,j) in G
#         if j not explored
#             DFS(G, j)
#     t++
#     set f(i) = t # ith finishing time</code></pre>

    <h3 class="card-title">Find mother vertex</h3>
    <ul>
      <li>Every node can be reach from the mother vertex.</li>
      <li>Compute all connected groups in the graph.</li>
      <li>The last visited node is the mother node.</li>
    </ul>

<pre><code class="python">def find_mother_vertex(g):
    explored = set()
    last_vertex = 0

    for i in range(num_nodes):
        if i not in explored:
            dfs(i, graph, explored)
            last_vertex = i</code></pre>

    <h3 class="card-title">Check if graph is tree</h3>
    <ul>
      <li>Check if there is no cycle.</li>
      <li>Check if all nodes are connected.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">

  </div>
</div>

<div class="card mb-4" id="graph-3">
  <div class="card-body">
    <h2 class="card-title">BFS</h2>

    <ul>
      <li>Explore nodes in "layers".</li>
      <li>O(n+m) using queue.</li>
    </ul>

<pre><code class="python">from collections import deque

def bfs(start_node, graph):
    queue = deque()
    queue.append(start_node)

    explored = set()
    explored.add(start_node)

    while queue:
        node = queue.popleft()
        for next_node in graph[node]:
            if next_node not in explored:
                explored.add(next_node)
                queue.append(next_node)</code></pre>

    <h3 class="card-title">Shortest path</h3>
    <ul>
      <li>Compute dist(v), the fewest number of edges on path from s to v.</li>
      <li>Assumption: every edge has length of 1.</li>
      <li>Extra code to BFS.</li>
    </ul>

<pre><code class="python">from collections import deque

def bfs(start_node, end_node, graph):
    explored = set()
    explored.add(start_node)

    queue = deque()
    queue.append((start_node, 0))

    while queue:
        item = queue.popleft()
        node = item[0]
        layer = item[1]
        for child_node in graph[node]:
            if child_node == end_node:
                return layer+1

            if child_node not in explored:
                queue.append((child_node, layer+1))
                explored.add(child_node)

    return -1</code></pre>

    <h3 class="card-title">Undirected connectivity</h3>
    <ul>
      <li>Let G(V,E) undirected graph.</li>
      <li>Connected component = pieces of G.</li>
      <li>Compute all connected components.</li>
    </ul>

<pre><code class="python">explored = set()

for i in range(num_nodes):
    if i not in explored:
        bfs(i, graph, explored)</code></pre>

<pre><code class="python">def bfs(start_node, graph, explored):
    queue = deque()
    queue.append(start_node)

    explored.add(start_node)

    while queue:
        node = queue.popleft()
        for next_node in graph[node]:
            if next_node not in explored:
                explored.add(next_node)
                queue.append(next_node)</code></pre>
  </div>
  <div class="card-footer text-muted">

  </div>
</div>

<div class="card mb-4" id="graph-4">
  <div class="card-body">
    <h2 class="card-title">DFS or BFS Examples</h2>

    <h3 class="card-title">Is graph Bipartite?</h3>
    <ul>
      <li>Can use either DFS or BFS.</li>
      <li>Color each node into one of two groups knowing that adjacent nodes cannot belong to a same color.</li>
    </ul>

<pre><code class="python"># Graph may consist of many disconnected sub-graphs.
# Search from all starting nodes must yield True.
# Time O(n), total time O(n*(n+m))
for node in graph.keys():
    result = result and bfs(node, graph)


# Time O(n+m)
# Space O(n)
def bfs(start_node, graph):
    queue = deque()
    queue.append(start_node)

    explored = set()
    explored.add(start_node)

    group = {}
    # Put the first node in group a.
    group[start_node] = "a"

    while queue:
        node = queue.popleft()
        for next_node in graph[node]:
            if next_node not in explored:
                explored.add(next_node)
                queue.append(next_node)
                if group[node] == "a":
                    group[next_node] = "b"
                else:
                    group[next_node] = "a"
            # If next_node is already explored and it is in the same
            # group as node, then graph cannot be bipartite.
            else:
                if group[node] == group[next_node]:
                    return False

    return True</code></pre>

    <h3 class="card-title">Find all possible paths in graph</h3>
    <ul>
      <li>Can use either DFS or BFS.</li>
      <li>Append the path to the child node into the stack.</li>
      <li>When popping out node from the stack, remember the path to that node.</li>
    </ul>

<pre><code class="python"># Assumption: graph is acyclic!
def dfs(start_node, graph):

    # No need to store "explored" node because graph is assumed to be acyclic.

    stack = []
    stack.append((start_node, [start_node]))

    paths = []

    while stack:
        item = stack.pop()
        node = item[0]
        path = item[1]

        paths.append(path)

        for child_node in graph[node]:
            stack.append((child_node, path+[child_node]))

    return paths</code></pre>
  </div>
  <div class="card-footer text-muted">

  </div>
</div>

<div class="card mb-4" id="graph-5">
  <div class="card-body">
    <h2 class="card-title">Union-Find</h2>

    <ul>
      <li>Find: returns the sub-graph that a node belongs to.</li>
      <li>Union: merge two sub-graphs into one sub-graph.</li>
    </ul>

<pre><code class="python"># Key represents each node and value represents the leader of group
# that the node belongs to.
group = {}

def find(group, node):
    return group[node]

def union(group, node, new_leader):

    # Save the previous leader.
    previous_leader = group[group[node]]

    # The node's leader gets the new leader.
    group[group[node]] = new_leader

    # All nodes that had the previous leader as leader must now have
    # the new leader as leader.
    for k,v in group.items():
        if v == previous_leader:
            group[k] = new_leader</code></pre>
  </div>
  <div class="card-footer text-muted">

  </div>
</div>

<div class="card mb-4" id="graph-6">
  <div class="card-body">
    <h2 class="card-title">Dijkstra</h2>

    <h3 class="card-title">Directed graph</h3>
    <ul>
      <li>Find the shortest path from starting node to each node in "positive" weighted graph.</li>
      <li>Add the starting node to the "visited" set.</li>
      <li>Initialize the distance to each node to infinity except the starting node whose distance should be zero.</li>
      <li>For all edges in the graph, consider edges (parent_node, child_node) where parent_node is visited and child_node is unvisited. Pick the edge where the distance to parent + the distance between parent and child is the minimum.</li>
      <li>Add the child to "visited" set.</li>
      <li>Update the distance to child such that dist[child] = dist[parent] + distance between parent and child.</li>
      <li>Continue until all nodes in the graph are explored.</li>
    </ul>

<pre><code class="python">def dijkstra(start_node, graph, n):

    explored = set()
    explored.add(start_node)

    # Distance from start_node to itself is 0.
    # Otherwise, initialize distance to infinity.
    distance = {}
    for i in range(1,n+1):
        if i == start_node:
            distance[i] = 0
        else:
            distance[i] = math.inf

    node = start_node

    while True:

        # If there is no more node to explore in the graph.
        if len(explored) == n:
            return distance

        # Amongst all edges where one node exists in explored and the other
        # does not exist in explored, we will visit the node with smallest distance.
        min_distance = math.inf
        next_node_to_visit = -1
        for node in explored:
            for item in graph[node]:
                child_node = item[0]
                dist = item[1]

                if distance[node] + dist < min_distance \
                    and child_node not in explored:
                    min_distance = distance[node] + dist
                    next_node_to_visit = child_node

        # If there is no unexplored node amongst all "directed" edges in graph.
        if next_node_to_visit == -1:
            return distance

        # Mark the node as visited.
        explored.add(next_node_to_visit)

        # Update the distance.
        distance[next_node_to_visit] = min_distance

        # Visit the next node.
        node = next_node_to_visit

    return distance</code></pre>
  </div>
  <div class="card-footer text-muted">

  </div>
</div>

<div class="card mb-4" id="graph-7">
  <div class="card-body">
    <h2 class="card-title">Bellman-Ford</h2>

    <h3 class="card-title">Directed graph with k stops</h3>
    <ul>
      <li>Consider all possible number of stops possible in the graph. (It should be n-1)</li>
      <li>Consider all directed edges in graph.</li>
      <li>Use dynamic programming to compute the minimum distance from the starting_node to every other node for each number of stops.</li>
      <li>Update the minimum distance as dist[child][k] = min(dist[child][k], dist[parent][k-1] + distance between parent and child)</li>
    </ul>

<pre><code class="python">def bellman_ford(start_node, graph, n):

    # Initiallize 2D array.
    # (number of nodes in graph, number of stops possible in graph)
    distance = {}
    for i in range(n):
        distance[i] = {}
        for j in range(n):
            distance[i][j] = math.inf

    # Distance from start_node in zero stops is 0.
    distance[start_node][0] = 0

    # Consider all possible number of stops j.
    # Time O(nm)
    # Space O(nm)
    for j in range(n-1):
        for item in graph:
            parent = item[0]
            child = item[1]
            dist = item[2]
            distance[child][j+1] = min(distance[child][j+1], distance[parent][j] + dist)

    return distance</code></pre>
  </div>
  <div class="card-footer text-muted">

  </div>
</div>

<div class="card mb-4" id="graph-8">
  <div class="card-body">
    <h2 class="card-title">Word ladder</h2>

<pre><code class="python"></code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/word-ladder">127. Word Ladder</a>
  </div>
</div>

<div class="card mb-4" id="graph-9">
  <div class="card-body">
    <h2 class="card-title">Surrounded regions</h2>

<pre><code class="python"></code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/surrounded-regions">130. Surrounded Regions</a>
  </div>
</div>

<div class="card mb-4" id="graph-10">
  <div class="card-body">
    <h2 class="card-title">Number of islands</h2>

<pre><code class="python"></code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/number-of-islands">200. Number of Islands</a>
  </div>
</div>
<!-- Graph END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>