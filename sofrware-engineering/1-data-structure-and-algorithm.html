<!--

Plan
Implement
Runtime
Test

 -->

<!-- Leetcode

1 hash table
2 linked list
3 sliding window
4 k-way merge
5 string
6 X
7 X
8 X
9 math
10 dynamic programming
11 two pointer
12 X
13 hash table
14 string
15 two pointer
16 two pointer
17 subsets
18 two pointer
19 linked list
20 stack
21 linked list
22 subsets
23 k-way merge
24 reverse linked list
25 reverse linked list
26 X
27 X
28 X
29 X
30 sliding window
31 two pointer
32 stack
33 modified binary search
34 modified binary search
35 modified binary search
36 array
37 backtracking
38 X
39 backtracking
40 backtracking
41 cyclic sort
42 two pointer
43 X
44 dynamic programming
45 greedy
46 subsets
47 backtracking
48 array
49 hash table
50 X
51 backtracking
52 backtracking
53 dynamic programming
54 array
55 greedy
56 merge interval
57 merge interval
58 string
59 array
60 math
61 linked list
62 dynamic programming
63 dynamic programming
64 dynamic programming
65 X
66 X
67 bit manipulation
68 X
69 X
70 dynamic programming
71 string
72 dynamic programming
73 array
74 array
75 two pointer
76 sliding window
77 backtracking
78 subsets
79 backtracking
80 two pointer
81 modified binary search
82 linked list
83 linked list
84 stack
85 array
86 linked list
87 string
88 k-way merge
89 X
90 subset
91 dynamic programming
92 reverse linked list
93 backtracking
94 tree dfs
95 tree
96 tree
97 dynamic programming
98 tree dfs
99 tree dfs
100 tree dfs/bfs
101 tree dfs/bfs
102 tree bfs
103 tree bfs
104 tree dfs/bfs
105 tree
106 tree
107 tree bfs
108 tree
109 tree
110 tree dfs
111 tree dfs/bfs
112 tree dfs/bfs
113 tree dfs
114 tree dfs
115 dynamic programming
116 tree dfs/bfs
117 tree dfs/bfs
118 array
119 array
120 dynamic programming
121 array
122 array | greedy
123 array | dynamic programming
124 tree dfs
125 two pointer
126 graph bfs
127 graph bfs
128 array
129 tree dfs
130 graph dfs/bfs | union find
131 backtracking
132 dynamic programming
133 X
134 greedy
135 greedy
136 bit manipulation
137 bit manipulation
138 linked list
139 dynamic programming
140 dynamic programming
141 fast slow pointer
142 fast slow pointer
143 reverse linkfed list
144 tree dfs
145 tree dfs
146 custom data structure
147 sorting
148 linked list
149 geometry
150 stack
151 two pointer
152 array
153 modified binary search
154 modified binary search
155 custom data structure
156 LP
157 LP
158 LP
159 LP
160 fast slow pointer
161 LP
162 modified binary search
163 LP
164 sorting
165 X
166 X
167 two pointer
168 math
169 hash table
170 LP
171 math
172 math
173 custom data structure
174 dynamic programming
175 sql
176 sql
177 sql
178 sql
179 sorting
180 sql
181 sql
182 sql
183 sql
184 sql
185 sql
186 LP
187 sliding window
188 dynamic programming
189 array
190 bit manipulation
191 bit manipulation
192 bash
193 bash
194 bash
195 bash
196 sql
197 sql
198 dynamic programming
199 tree dfs/bfs
200 graph bfs | union find

207 topological sort
209 sliding window
210 topological sort
226 tree dfs/bfs
238 array
239 sliding window
297 tree dfs/bfs
301 graph bfs
310 topological sort
322 dynamic programming
329 graph dfs/bfs
332 X
394 stack
395 sliding window
399 graph dfs/bfs
416 dynamic programming
424 sliding window
438 sliding window
494 dynamic programming
523 array
543 tree dfs
547 graph dfs/bfs | union find
680 two pointer
684 graph dfs/bfs | union find
685 graph dfs/bfs | union find
687 tree dfs
727 sliding window
743 graph dfs/bfs
753 X
765 graph dfs/bfs | union find
785 graph dfs/bfs | union find
797 graph dfs/bfs
802 graph dfs/bfs
809 X
818 dynamic programming
834 graph dfs
841 graph dfs/bfs
847 graph bfs + bitmask
871 dynamic programming
881 greedy
886 graph dfs/bfs | union find
912 sorting
913 tolopological sort
925 two pointer
938 tree dfs/bfs
947 graph dfs | union find
959 graph dfs/bfs | union find
973 geometry
990 graph dfs/bfs | union find
1007 greedy
1029 greedy
1074 array
1137 dynamic programming
1146 custom data structure

-->

<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- Data structure and algorithm BEGIN -->
<div class="card mb-4" id="data-structure-and-algorithm">
  <div class="card-body">
    <h2 class="card-title">Data structure and algorithm</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#data-structure-and-algorithm-">Big O</a></li>
      <li><a href="#data-structure-and-algorithm-">Hash table</a></li>
      <li><a href="#data-structure-and-algorithm-">Linked list</a></li>
      <li><a href="#data-structure-and-algorithm-">Stack</a></li>
      <li><a href="#data-structure-and-algorithm-">Queue</a></li>
      <li><a href="#data-structure-and-algorithm-">Graph</a></li>
      <li><a href="#data-structure-and-algorithm-">Tree</a></li>
      <li><a href="#data-structure-and-algorithm-">Heap</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Big O</h2>

    <h3 class="card-title">Nested for-loop with dependant variables: O(n^2)</h3>

<pre><code class="python">for i in range(n):
    for x in range(i):
        print(x)</code></pre>

    <h3 class="card-title">Nested for-loop with index modification: O(n^2)</h3>

<pre><code class="python">for i in range(n):
    i *= 2
    for x in range(i):
        print(x)</code></pre>

    <h3 class="card-title">Loop statement that multiplies/divides the loop variable: O(log(n)/log(k))</h3>

<pre><code class="python">while i < n:
    i *= k
    print(i)</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Hash table</h2>
    <ul>
      <li>There is always an underlying array.</li>
      <li>Hash function maps keys to indexes of an array.</li>
      <li>Large number of keys are mapped to small number of indexes, which could cause collision.</li>
      <li>Each element of array holds a linked list to handle collision.</li>
      <li>Search/insert/delete is O(1) on average and O(n) in the worst case.</li>
    </ul>
<pre><code class="python"># Dictionary implementation of hash table.
my_dict = {}

# Set implementation of hash table.
my_set = set()</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Linked list</h2>
    <ul>
      <li>Access: O(n)</li>
      <li>Insert (at head): O(1)</li>
      <li>Delete (at head): O(1)</li>
      <li>Insert (at tail): O(n)</li>
      <li>Delete (at tail): O(n)</li>
    </ul>

<pre><code class="python"># Singly.
class Node:
    def __init__(self, data=0, next=None):
        self.data = data
        self.next = next

# Doubly.
class Node:
    def __init__(self, data=0, next=None, prev=None):
        self.data = data
        self.prev = prev
        self.next = next</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Stack</h2>

<pre><code class="python"># Initialize a stack.
stack = []

# Adding elements at the end of a stack.
stack.append('element')

# Removing elements from the end of a stack.
stack.pop()

# Get the item at the front of a stack.
stack[0]

# Get the item at the end of a stack.
stack[-1]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Queue</h2>

<pre><code class="python"># "deque" implementation of queue.
from collections import deque

# Initialize a queue.
queue = deque()

# Adding elements at the end of a queue.
queue.append('element')

# Removing elements from the front of a queue.
queue.popleft()

# Removing elements from the end of a queue.
queue.pop()

# Get the item at the front of a queue.
queue[0]

# Get the item at the end of a queue.
queue[-1]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Graph</h2>

    <h3 class="card-title">Representation</h3>
    <ul>
      <li>Adjacency list is space-wise more efficient than list of lists.</li>
      <li>Dictionary can be used where key is each node and value is Python Set of nodes.</li>
    </ul>

<pre><code class="python"># Convert list of lists to adjacency list.

from collections import defaultdict

# Directed graph.

graph = defaultdict(set)

for edge in edges:
    graph[edge[1]].add(edge[0])

# Undirected graph.

graph = {}

for edge in edges:
    graph[edge[1]].add(edge[0])
    graph[edge[0]].add(edge[1])</code></pre>

    <h3 class="card-title">DFS</h3>
    <ul>
      <li>Explore aggressively, only backtrack when necessary.</li>
      <li>O(n+m) using stack.</li>
    </ul>

<pre><code class="python">def dfs(start_node, graph):
    stack = []
    stack.append(start_node)

    explored = set()
    explored.add(start_node)

    while stack:
        node = stack.pop()
        for next_node in graph[node]:
            if next_node not in explored:
                explored.add(next_node)
                stack.append(next_node)</code></pre>

    <h3 class="card-title">Detect cycle</h3>

<pre><code class="python">def is_cycle(start_node, graph):
    stack = []
    stack.append(start_node)

    explored = set()
    explored.add(start_node)

    while stack:
        node = stack.pop()
        for next_node in graph[node]:
            if next_node not in explored:
                explored.add(next_node)
                stack.append(next_node)
            else:
                if next_node == start_node:
                    return True

    return False</code></pre>

    <h3 class="card-title">Topological ordering</h3>
    <ul>
      <li>Do DFS starting at each node counting the number of steps each starting node takes to finish DFS.</li>
      <ul>
        <li>If starting node has only small number of children or even no children, DFS will finish quickly.</li>
        <li>If starting node has lots of children, DFS will take time to finish.</li>
      </ul>
    </ul>

<pre><code class="python">def topological_order(graph, num_nodes):

    ordering = []

    for i in range(num_nodes):
        count = self.dfs(i, graph)
        # If cycle.
        if count == -1:
            return []
        ordering.append([count, i])

    ordering.sort(key=lambda x:(-x[0]))

    return [item[1] for item in ordering]

def dfs(self, start_node, graph):
    stack = []
    stack.append(start_node)
    count = 1

    explored = set()
    explored.add(start_node)

    while stack:
        node = stack.pop()
        for next_node in graph[node]:
            if next_node not in explored:
                explored.add(next_node)
                stack.append(next_node)
                count += 1
            else:
                if next_node == start_node:
                    return -1

    return count</code></pre>

    <h3 class="card-title">Strongly connected components</h3>
    <ul>
      <li>There exist path u to v and v to u in graph G.</li>
      <li>Kosaraju's two pass algorithm</li>
      <ul>
        <li>Compute SCC in O(m+n).</li>
        <li>Let G' = G with all arcs reversed.</li>
        <li>Run DFS_loop on G' (compute magical ordering of nodes)</li>
        <li>Run DFS_loop on G (compute strongly connected component one by one)</li>
      </ul>
    </ul>

    <h3 class="card-title">Find mother vertex</h3>
    <ul>
      <li>Every node can be reached from the mother vertex.</li>
      <li>Compute all connected groups in the graph.</li>
      <li>The last visited node is the mother node.</li>
    </ul>

<pre><code class="python">def find_mother_vertex(g):
    explored = set()
    last_vertex = 0

    for i in range(num_nodes):
        if i not in explored:
            dfs(i, graph, explored)
            last_vertex = i</code></pre>

    <h3 class="card-title">Check if graph is tree</h3>
    <ul>
      <li>Check if there is no cycle.</li>
      <li>Check if all nodes are connected.</li>
    </ul>

    <h3 class="card-title">BFS</h3>
    <ul>
      <li>Explore nodes in "layers".</li>
      <li>O(n+m) using queue.</li>
    </ul>

<pre><code class="python">from collections import deque

def bfs(start_node, graph):
    queue = deque()
    queue.append(start_node)

    explored = set()
    explored.add(start_node)

    while queue:
        node = queue.popleft()
        for next_node in graph[node]:
            if next_node not in explored:
                explored.add(next_node)
                queue.append(next_node)</code></pre>

    <h3 class="card-title">Shortest path</h3>
    <ul>
      <li>Compute dist(v), the fewest number of edges on path from s to v.</li>
      <li>Assumption: every edge has length of 1.</li>
      <li>Extra code to BFS.</li>
    </ul>

<pre><code class="python">from collections import deque

def bfs(start_node, end_node, graph):
    explored = set()
    explored.add(start_node)

    queue = deque()
    queue.append((start_node, 0))

    while queue:
        item = queue.popleft()
        node = item[0]
        layer = item[1]
        for child_node in graph[node]:
            if child_node == end_node:
                return layer+1

            if child_node not in explored:
                queue.append((child_node, layer+1))
                explored.add(child_node)

    return -1</code></pre>

    <h3 class="card-title">Undirected connectivity</h3>
    <ul>
      <li>Let G(V,E) undirected graph.</li>
      <li>Connected component = pieces of G.</li>
      <li>Compute all connected components.</li>
    </ul>

<pre><code class="python">explored = set()

for i in range(num_nodes):
    if i not in explored:
        bfs(i, graph, explored)</code></pre>

    <h3 class="card-title">Union-Find</h3>
    <ul>
      <li>Find: returns the sub-graph that a node belongs to.</li>
      <li>Union: merge two sub-graphs into one sub-graph.</li>
    </ul>

<pre><code class="python"># Key represents each node.
# Value represents the leader of group that the node belongs to.
group = {}

def find(group, node):
    return group[node]

def union(group, node, new_leader):

    # Save the previous leader.
    previous_leader = group[group[node]]

    # The node's leader gets the new leader.
    group[group[node]] = new_leader

    # All nodes that had the previous leader as leader must now have
    # the new leader as leader.
    for k,v in group.items():
        if v == previous_leader:
            group[k] = new_leader</code></pre>

    <h3 class="card-title">Dijkstra</h3>
    <ul>
      <li>Find the shortest path from starting node to each node in "positive" weighted graph.</li>
      <li>Add the starting node to the "visited" set.</li>
      <li>Initialize the distance to each node to infinity except the starting node whose distance should be zero.</li>
      <li>For all edges in the graph, consider edges (parent_node, child_node) where parent_node is visited and child_node is unvisited. Pick the edge where the distance to parent + the distance between parent and child is the minimum.</li>
      <li>Add the child to "visited" set.</li>
      <li>Update the distance to child such that dist[child] = dist[parent] + distance between parent and child.</li>
      <li>Continue until all nodes in the graph are explored.</li>
    </ul>

<pre><code class="python">def dijkstra(start_node, graph, n):

    explored = set()
    explored.add(start_node)

    # Distance from start_node to itself is 0.
    # Otherwise, initialize distance to infinity.
    distance = {}
    for i in range(1,n+1):
        if i == start_node:
            distance[i] = 0
        else:
            distance[i] = math.inf

    node = start_node

    while True:

        # If there is no more node to explore in the graph.
        if len(explored) == n:
            return distance

        # Amongst all edges where one node exists in explored and the other
        # does not exist in explored, we will visit the node with smallest distance.
        min_distance = math.inf
        next_node_to_visit = -1
        for node in explored:
            for item in graph[node]:
                child_node = item[0]
                dist = item[1]

                if distance[node] + dist < min_distance \
                    and child_node not in explored:
                    min_distance = distance[node] + dist
                    next_node_to_visit = child_node

        # If there is no unexplored node amongst all "directed" edges in graph.
        if next_node_to_visit == -1:
            return distance

        # Mark the node as visited.
        explored.add(next_node_to_visit)

        # Update the distance.
        distance[next_node_to_visit] = min_distance

        # Visit the next node.
        node = next_node_to_visit

    return distance</code></pre>

    <h3 class="card-title">Bellman-Ford</h3>
    <ul>
      <li>Consider all possible number of stops possible in the graph. (It should be n-1)</li>
      <li>Consider all directed edges in graph.</li>
      <li>Use dynamic programming to compute the minimum distance from the starting_node to every other node for each number of stops.</li>
      <li>Update the minimum distance as dist[child][k] = min(dist[child][k], dist[parent][k-1] + distance between parent and child)</li>
    </ul>

<pre><code class="python">def bellman_ford(start_node, graph, n):

    # Initiallize 2D array.
    # (number of nodes in graph, number of stops possible in graph)
    distance = {}
    for i in range(n):
        distance[i] = {}
        for j in range(n):
            distance[i][j] = math.inf

    # Distance from start_node in zero stops is 0.
    distance[start_node][0] = 0

    # Consider all possible number of stops j.
    # Time O(nm)
    # Space O(nm)
    for j in range(n-1):
        for item in graph:
            parent = item[0]
            child = item[1]
            dist = item[2]
            distance[child][j+1] = min(distance[child][j+1], distance[parent][j] + dist)

    return distance</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Tree</h2>

<pre><code class="python">class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right</code></pre>

    <h3 class="card-title">Heap (priority queue)</h3>
    <ul>
      <li>Perfectly balanced tree.</li>
      <li>Root element must have the minimum key.</li>
      <li>Runtime</li>
      <ul>
        <li>Insert (add to heap): O(nlogn).</li>
        <li>Extract (remove an element with minimum key): O(nlogn).</li>
        <li>Heapify (n batched inserts): O(n).</li>
        <li>Delete: O(nlogn).</li>
      </ul>
    </ul>

<pre><code class="python"># Insert(key k)
#     stick k at the end of last level
#     bubble-up k until k's parent <= k</code></pre>

<pre><code class="python"># Extract-Min
#     delete root
#     move last node to new root
#     bubble-down k until k's parent <= k</code></pre>

<pre><code class="python"># Search(key k)
#     start at the root
#     traverse left (if k < key at current node) or right (if k > key at current node) child pointers as needed
#     return node with key k or NULL, as appropriate</code></pre>

<pre><code class="python"># Insert(key k)
#     start at the root
#     do search (which will return NULL)
#     rewire final NULL pointer to point to new node with key k</code></pre>

<pre><code class="python"># Min/Max
#     start at the root
#     follow left (min case) or right (max case) until the bottom (return last key found)</code></pre>

<pre><code class="python"># Pred(key k)
#     easy case: if k's left subtree nonempty, return max key in left subtree
#     otherwise: follow parent pointers until you get to a key less than k</code></pre>

<pre><code class="python"># Inorder traversal
#     to print out keys in increasing order
#     let r = root, Tr = right subtree, Tl = left subtree
#     recurse on Tl
#         by recursion, prints out keys of TL in increasing order
#     print out r's key
#     recurse on Tr
#         by recursion, prints out keys of TR in increasing order</code></pre>

<pre><code class="python"># Delete(key k)
#     search for k
#     if k has no children
#         delete k
#     k has one child
#         delete k, and put child under k's parent
#     k has two children
#         compute k's predecessor l
#             for example, traverse k's (non-NULL) left child pointer, then right child pointers until no longer possible
#         swap k and l
#         delete k</code></pre>

<pre><code class="python"># Select(order statistic i)
#     store a little bit of extra info at each tree node about the tree itself
#     start at root x, with children y and z
#     let a = size(y) # a = 0 if x has no left child
#     if a = i-1
#         return x's key
#     if a >= i
#         recurse to compute ith order statistic on new root y
#     if a < i-1
#         recurse to compute (i-a-1)th order statistic on new root z</code></pre>

    <h3 class="card-title">Balanced search tree (sorted array with fast insert & delete)</h3>
    <ul>
      <li>Search: O(logn).</li>
      <li>Select: O(logn).</li>
      <li>Min/Max: O(logn).</li>
      <li>Pred/Succ: O(logn).</li>
      <li>Rank: O(logn).</li>
      <li>Output in sorted order: O(n).</li>
      <li>Insert/Delete: O(logn).</li>
    </ul>

    <h4 class="card-title">Red-Black tree</h4>
    <ul>
      <li>Each node red or black.</li>
      <li>Root is black.</li>
      <li>No 2 reds in a row. (red node => only black children)</li>
      <li>Every root-NULL path (unsuccessful search) has the same number of black nodes.</li>
      <li>Height guarantee.</li>
      <ul>
        <li>Every red-black tree with n nodes has height less than or equal to 2log_{2}(n+1)</li>
      </ul>
      <li>Rotation.</li>
      <ul>
        <li>Locally rebalance subtrees at a node in O(1) time.</li>
        <li>Left rotation.</li>
        <li>Right rotation.</li>
      </ul>
    </ul>

<pre><code class="python"># Insert(x)
#     insert x as usual (makes x a leaf)
#     try coloring x red
#     if x's parent y is black, done
#     else y is red, then y has a black parent w</code></pre>




    <h3 class="card-title">Binary tree</h3>
    <ul>
      <li>Exactly one node per key.</li>
      <li>Each node has</li>
      <ul>
        <li>Left child pointer</li>
        <li>Right child pointer</li>
        <li>Parent</li>
      </ul>
      <li>All nodes left on node X are less than X.</li>
      <li>All nodes right on node X are greater than X.</li>
      <li>Many possible trees for a set of keys.</li>
      <li>Height could be anywhere from log_{2}^{n} to n.</li>
      <li>Generally operations are O(height).</li>
    </ul>

    <h3 class="card-title">Binary search tree</h3>
    <ul>
      <li>Binary tree where each node of the tree has key-value pairs.</li>
    </ul>

<pre><code class="python">class Node(object):
    def __init__(self, val=0, left=None, right=None, parent=None):
        self.val = val
        self.left = left
        self.right = right
        self.parent = parent</code></pre>

    <h4 class="card-title">Insert</h4>

<pre><code class="python">def insert(self, val):
    current = self
    parent = None

    while current:
        parent = current
        if val < current.val:
            current = current.left
        else:
            current = current.right

    if val < parent.val:
        parent.left = Node(val)
    else:
        parent.right = Node(val)</code></pre>

    <h4 class="card-title">Search</h4>

<pre><code class="python">def search(self, val):
    current = self

    while current is not None:

        if val < current.val:
            current = current.left
        elif val > current.val:
            current = current.right
        else:
            return True

    return False</code></pre>

    <h4 class="card-title">Delete</h4>

<pre><code class="python">def delete(self, val):

    if val < self.val:
        if self.left:
            self.left = self.left.delete(val)
        else:
            print(str(val) + " not found in the tree")
            return self
    elif val > self.val:
        if self.right:
            self.right = self.right.delete(val)
        else:
            print(str(val) + " not found in the tree")
            return self
    else:
        # Delete node with no children.
        if self.left is None and self.right is None:
            self = None
            return None

        # Delete node with right child.
        elif self.left is None:
            tmp = self.right
            self = None
            return tmp

        # Delete node with left child.
        elif self.right is None:
            tmp = self.left
            self = None
            return tmp

        # Delete node with two children.
        else:
            current = self.right

            # Find the leftmost leaf.
            while current.left is not None:
                current = current.left
            self.val = current.val
            self.right = self.right.delete(current.val)

    return self</code></pre>

    <h4 class="card-title">Pre-order traversal</h4>

<pre><code class="python">def pre_order_traversal(node):
    if node is not None:
        print(node.val)
        pre_order_traversal(node.left)
        pre_order_traversal(node.right)</code></pre>

    <h4 class="card-title">Post-order traversal</h4>

<pre><code class="python">def post_order_traversal(node):
    if node is not None:
        post_order_traversal(node.left)
        post_order_traversal(node.right)
        print(node.val)</code></pre>

    <h4 class="card-title">In-order traversal</h4>

<pre><code class="python">def in_order_traversal(node):
    if node is not None:
        in_order_traversal(node.left)
        print(node.val)
        in_order_traversal(node.right)</code></pre>

    <h3 class="card-title">AVL tree</h3>
    <ul>
      <li>Balanced binary search tree.</li>
    </ul>

    <h3 class="card-title">Red-black tree</h3>
    <ul>
      <li>AVL tree where</li>
      <ul>
        <li>Root is always black.</li>
        <li>Two red nodes cannot be adjacent.</li>
      </ul>
    </ul>

<pre><code class="python">class Node:
    def __init__(self,val):
        self.val = val
        self.left = None
        self.right = None
        is_red = None</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-">
  <div class="card-body">
    <h2 class="card-title">Heap</h2>
    <ul>
      <li>Complete binary tree.</li>
    </ul>

    <h3 class="card-title">Insert</h3>
    <ul>
      <li>Create a new node at the end of the heap.</li>
      <li>Place the new key at that node.</li>
      <li>Perculate (swap values if needed) up until reaching the root and the heap property is satisfied.</li>
    </ul>

    <h3 class="card-title">Delete</h3>
    <ul>
      <li>Delete the root.</li>
      <li>Move the key of the last child node to root.</li>
      <li>Perculate (swap values if needed) up until reaching the last node and the heap property is satisfied.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>
<!-- Data structure and algorithm END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>