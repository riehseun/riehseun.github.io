<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- Data structure and algorithm BEGIN -->
<div class="card mb-4" id="data-structure-and-algorithm">
  <div class="card-body">
    <h2 class="card-title">Data structure and algorithm</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#data-structure-and-algorithm-1">Big O</a></li>
      <li><a href="#data-structure-and-algorithm-2">Hash table</a></li>
      <li><a href="#data-structure-and-algorithm-3">Linked list</a></li>
      <li><a href="#data-structure-and-algorithm-4">Stack</a></li>
      <li><a href="#data-structure-and-algorithm-5">Queue</a></li>
      <li><a href="#data-structure-and-algorithm-6">Graph</a></li>
      <li><a href="#data-structure-and-algorithm-7">Tree</a></li>
      <li><a href="#data-structure-and-algorithm-8">Heap</a></li>
    </ul>
  </div>
</div>

<!-- <div class="card mb-4" id="data-structure-and-algorithm-0">
  <div class="card-body">
    <h2 class="card-title">Approach</h2>
    <ul>
      <li>Plan</li>
      <li>Implement</li>
      <li>Runtime</li>
      <li>Test</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div> -->

<!-- Leetcode
1 hash table
2 linked list
3 sliding window
4 k-way merge
5 string
6 X
7 X
8 X
9 string
10 dynamic programming
11 two pointer
12 X
13 hash table
14 string
15 two pointer
16 two pointer
17 subsets
18 two pointer
19 linked list
20 stack
21 linked list
22 subsets
23 k-way merge
24 reverse linked list
25 reverse linked list
26 X
27 X
28 X
29 X
30 sliding window
31 two pointer
32 stack
33 modified binary search
34 modified binary search
35 modified binary search
36 array
37 backtracking
38 X
39 backtracking
40 backtracking
41 cyclic sort
42 two pointer
43 X
44 dynamic programming
45 greedy
46 subsets
47 backtracking
48 array
49 hash table
50 X
51 backtracking
52 backtracking
53 dynamic programming
54 array
55 greedy
56 merge interval
57 merge interval
58 string
59 array
60 ?
61 linked list
62 dynamic programming
63 dynamic programming
64 dynamic programming
65 X
66 X
67 bit manipulation
68 X
69 X
70 dynamic programming
71 string
72 dynamic programming
73 array
74 array
75 two pointers
76 sliding window
77 backtracking
78 subsets
79 backtracking
80 two pointers
81 modified binary search
82 linked list
83 linked list
84 stack
85 array
86 linked list
87 string
88 k-way merge
89 X
90 subset
91 dynamic programming
92 reverse linked list
93 backtracking
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122 greedy
123
124
125 two pointer
126
127
128
129
130
131 backtracking
132
133
134 greedy
135
136
137
138
139 dynamic programming
140 dynamic programming
141 fast slow pointer
142
143 reverse linked list
144
145
146
147
148
149
150
151 two pointer
152
153
154
155
156
157
158
159
160 fast slow pointer
161
162 modified binary search
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187 sliding window
188
189
190
191
192
193
194
195
196
197
198 dynamic programming
199
200 -->



<div class="card mb-4" id="data-structure-and-algorithm-1">
  <div class="card-body">
    <h2 class="card-title">Big O</h2>

    <h3 class="card-title">Nested for-loop with dependant variables: O(n^2)</h3>

<pre><code class="python">for i in range(n):
    for x in range(i):
        print(x)</code></pre>

    <h3 class="card-title">Nested for-loop with index modification: O(n^2)</h3>

<pre><code class="python">for i in range(n):
    i *= 2
    for x in range(i):
        print(x)</code></pre>

    <h3 class="card-title">Loop statement that multiplies/divides the loop variable: O(log(n)/log(k))</h3>

<pre><code class="python">while i < n:
    i *= k
    print(i)</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-2">
  <div class="card-body">
    <h2 class="card-title">Hash table</h2>
    <ul>
      <li>There is always an underlying array.</li>
      <li>Hash function maps keys to indexes of an array.</li>
      <li>Large number of keys are mapped to small number of indexes, which could cause collision.</li>
      <li>Each element of array holds a linked list to handle collision.</li>
      <li>Search/insert/delete is O(1) on average and O(n) in the worst case.</li>
    </ul>
<pre><code class="python"># Dictionary implementation of hash table.
my_dict = {}

# Set implementation of hash table.
my_set = set()</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-3">
  <div class="card-body">
    <h2 class="card-title">Linked list</h2>
    <ul>
      <li>Access: O(n)</li>
      <li>Insert (at head): O(1)</li>
      <li>Delete (at head): O(1)</li>
      <li>Insert (at tail): O(n)</li>
      <li>Delete (at tail): O(n)</li>
    </ul>

<pre><code class="python"># Singly.
class Node:
    def __init__(self, data=0, next=None):
        self.data = data
        self.next = next

# Doubly.
class Node:
    def __init__(self, data=0, next=None, prev=None):
        self.data = data
        self.prev = prev
        self.next = next</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-4">
  <div class="card-body">
    <h2 class="card-title">Stack</h2>

<pre><code class="python"># Initialize a stack.
stack = []

# Adding elements at the end of a stack.
stack.append('element')

# Removing elements from the end of a stack.
stack.pop()

# Get the item at the front of a stack.
stack[0]

# Get the item at the end of a stack.
stack[-1]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-5">
  <div class="card-body">
    <h2 class="card-title">Queue</h2>

<pre><code class="python"># "deque" implementation of queue.
from collections import deque

# Initialize a queue.
queue = deque()

# Adding elements at the end of a queue.
queue.append('element')

# Removing elements from the front of a queue.
queue.popleft()

# Removing elements from the end of a queue.
queue.pop()

# Get the item at the front of a queue.
queue[0]

# Get the item at the end of a queue.
queue[-1]</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-6">
  <div class="card-body">
    <h2 class="card-title">Graph</h2>

    <h3 class="card-title">Representation</h3>
    <ul>
      <li>Adjacency list is space-wise more efficient than list of lists.</li>
      <li>Dictionary can be used where key is each node and value is Python Set of nodes.</li>
    </ul>

<pre><code class="python"># Convert list of lists to adjacency list.

from collections import defaultdict

# Directed graph.

graph = defaultdict(set)

for edge in edges:
    graph[edge[1]].add(edge[0])

# Undirected graph.

graph = {}

for edge in edges:
    graph[edge[1]].add(edge[0])
    graph[edge[0]].add(edge[1])</code></pre>

    <h3 class="card-title">DFS</h3>
    <ul>
      <li>Explore aggressively, only backtrack when necessary.</li>
      <li>O(n+m) using stack.</li>
    </ul>

<pre><code class="python">def dfs(start_node, graph):
    stack = []
    stack.append(start_node)

    explored = set()
    explored.add(start_node)

    while stack:
        node = stack.pop()
        for next_node in graph[node]:
            if next_node not in explored:
                explored.add(next_node)
                stack.append(next_node)</code></pre>

    <h3 class="card-title">BFS</h3>
    <ul>
      <li>Explore nodes in "layers".</li>
      <li>O(n+m) using queue.</li>
    </ul>

<pre><code class="python">from collections import deque

def bfs(start_node, graph):
    queue = deque()
    queue.append(start_node)

    explored = set()
    explored.add(start_node)

    while queue:
        node = queue.popleft()
        for next_node in graph[node]:
            if next_node not in explored:
                explored.add(next_node)
                queue.append(next_node)</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-7">
  <div class="card-body">
    <h2 class="card-title">Tree</h2>

<pre><code class="python">class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right</code></pre>

    <h3 class="card-title">Heap (priority queue)</h3>
    <ul>
      <li>Perfectly balanced tree.</li>
      <li>Root element must have the minimum key.</li>
      <li>Runtime</li>
      <ul>
        <li>Insert (add to heap): O(nlogn).</li>
        <li>Extract (remove an element with minimum key): O(nlogn).</li>
        <li>Heapify (n batched inserts): O(n).</li>
        <li>Delete: O(nlogn).</li>
      </ul>
    </ul>

<pre><code class="python"># Insert(key k)
#     stick k at the end of last level
#     bubble-up k until k's parent <= k</code></pre>

<pre><code class="python"># Extract-Min
#     delete root
#     move last node to new root
#     bubble-down k until k's parent <= k</code></pre>

<pre><code class="python"># Search(key k)
#     start at the root
#     traverse left (if k < key at current node) or right (if k > key at current node) child pointers as needed
#     return node with key k or NULL, as appropriate</code></pre>

<pre><code class="python"># Insert(key k)
#     start at the root
#     do search (which will return NULL)
#     rewire final NULL pointer to point to new node with key k</code></pre>

<pre><code class="python"># Min/Max
#     start at the root
#     follow left (min case) or right (max case) until the bottom (return last key found)</code></pre>

<pre><code class="python"># Pred(key k)
#     easy case: if k's left subtree nonempty, return max key in left subtree
#     otherwise: follow parent pointers until you get to a key less than k</code></pre>

<pre><code class="python"># Inorder traversal
#     to print out keys in increasing order
#     let r = root, Tr = right subtree, Tl = left subtree
#     recurse on Tl
#         by recursion, prints out keys of TL in increasing order
#     print out r's key
#     recurse on Tr
#         by recursion, prints out keys of TR in increasing order</code></pre>

<pre><code class="python"># Delete(key k)
#     search for k
#     if k has no children
#         delete k
#     k has one child
#         delete k, and put child under k's parent
#     k has two children
#         compute k's predecessor l
#             for example, traverse k's (non-NULL) left child pointer, then right child pointers until no longer possible
#         swap k and l
#         delete k</code></pre>

<pre><code class="python"># Select(order statistic i)
#     store a little bit of extra info at each tree node about the tree itself
#     start at root x, with children y and z
#     let a = size(y) # a = 0 if x has no left child
#     if a = i-1
#         return x's key
#     if a >= i
#         recurse to compute ith order statistic on new root y
#     if a < i-1
#         recurse to compute (i-a-1)th order statistic on new root z</code></pre>

    <h3 class="card-title">Balanced search tree (sorted array with fast insert & delete)</h3>
    <ul>
      <li>Search: O(logn).</li>
      <li>Select: O(logn).</li>
      <li>Min/Max: O(logn).</li>
      <li>Pred/Succ: O(logn).</li>
      <li>Rank: O(logn).</li>
      <li>Output in sorted order: O(n).</li>
      <li>Insert/Delete: O(logn).</li>
    </ul>

    <h4 class="card-title">Red-Black tree</h4>
    <ul>
      <li>Each node red or black.</li>
      <li>Root is black.</li>
      <li>No 2 reds in a row. (red node => only black children)</li>
      <li>Every root-NULL path (unsuccessful search) has the same number of black nodes.</li>
      <li>Height guarantee.</li>
      <ul>
        <li>Every red-black tree with n nodes has height less than or equal to 2log_{2}(n+1)</li>
      </ul>
      <li>Rotation.</li>
      <ul>
        <li>Locally rebalance subtrees at a node in O(1) time.</li>
        <li>Left rotation.</li>
        <li>Right rotation.</li>
      </ul>
    </ul>

<pre><code class="python"># Insert(x)
#     insert x as usual (makes x a leaf)
#     try coloring x red
#     if x's parent y is black, done
#     else y is red, then y has a black parent w</code></pre>




    <h3 class="card-title">Binary tree</h3>
    <ul>
      <li>Exactly one node per key.</li>
      <li>Each node has</li>
      <ul>
        <li>Left child pointer</li>
        <li>Right child pointer</li>
        <li>Parent</li>
      </ul>
      <li>All nodes left on node X are less than X.</li>
      <li>All nodes right on node X are greater than X.</li>
      <li>Many possible trees for a set of keys.</li>
      <li>Height could be anywhere from log_{2}^{n} to n.</li>
      <li>Generally operations are O(height).</li>
    </ul>

    <h3 class="card-title">Binary search tree</h3>
    <ul>
      <li>Binary tree where each node of the tree has key-value pairs.</li>
    </ul>

<pre><code class="python">class Node(object):
    def __init__(self, val=0, left=None, right=None, parent=None):
        self.val = val
        self.left = left
        self.right = right
        self.parent = parent</code></pre>

    <h4 class="card-title">Insert</h4>

<pre><code class="python">def insert(self, val):
    current = self
    parent = None

    while current:
        parent = current
        if val < current.val:
            current = current.left
        else:
            current = current.right

    if val < parent.val:
        parent.left = Node(val)
    else:
        parent.right = Node(val)</code></pre>

    <h4 class="card-title">Search</h4>

<pre><code class="python">def search(self, val):
    current = self

    while current is not None:

        if val < current.val:
            current = current.left
        elif val > current.val:
            current = current.right
        else:
            return True

    return False</code></pre>

    <h4 class="card-title">Delete</h4>

<pre><code class="python">def delete(self, val):

    if val < self.val:
        if self.left:
            self.left = self.left.delete(val)
        else:
            print(str(val) + " not found in the tree")
            return self
    elif val > self.val:
        if self.right:
            self.right = self.right.delete(val)
        else:
            print(str(val) + " not found in the tree")
            return self
    else:
        # Delete node with no children.
        if self.left is None and self.right is None:
            self = None
            return None

        # Delete node with right child.
        elif self.left is None:
            tmp = self.right
            self = None
            return tmp

        # Delete node with left child.
        elif self.right is None:
            tmp = self.left
            self = None
            return tmp

        # Delete node with two children.
        else:
            current = self.right

            # Find the leftmost leaf.
            while current.left is not None:
                current = current.left
            self.val = current.val
            self.right = self.right.delete(current.val)

    return self</code></pre>

    <h4 class="card-title">Pre-order traversal</h4>

<pre><code class="python">def pre_order_traversal(node):
    if node is not None:
        print(node.val)
        pre_order_traversal(node.left)
        pre_order_traversal(node.right)</code></pre>

    <h4 class="card-title">Post-order traversal</h4>

<pre><code class="python">def post_order_traversal(node):
    if node is not None:
        post_order_traversal(node.left)
        post_order_traversal(node.right)
        print(node.val)</code></pre>

    <h4 class="card-title">In-order traversal</h4>

<pre><code class="python">def in_order_traversal(node):
    if node is not None:
        in_order_traversal(node.left)
        print(node.val)
        in_order_traversal(node.right)</code></pre>

    <h3 class="card-title">AVL tree</h3>
    <ul>
      <li>Balanced binary search tree.</li>
    </ul>

    <h3 class="card-title">Red-black tree</h3>
    <ul>
      <li>AVL tree where</li>
      <ul>
        <li>Root is always black.</li>
        <li>Two red nodes cannot be adjacent.</li>
      </ul>
    </ul>

<pre><code class="python">class Node:
    def __init__(self,val):
        self.val = val
        self.left = None
        self.right = None
        is_red = None</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="data-structure-and-algorithm-8">
  <div class="card-body">
    <h2 class="card-title">Heap</h2>
    <ul>
      <li>Complete binary tree.</li>
    </ul>

    <h3 class="card-title">Insert</h3>
    <ul>
      <li>Create a new node at the end of the heap.</li>
      <li>Place the new key at that node.</li>
      <li>Perculate (swap values if needed) up until reaching the root and the heap property is satisfied.</li>
    </ul>

    <h3 class="card-title">Delete</h3>
    <ul>
      <li>Delete the root.</li>
      <li>Move the key of the last child node to root.</li>
      <li>Perculate (swap values if needed) up until reaching the last node and the heap property is satisfied.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>
<!-- Data structure and algorithm END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>