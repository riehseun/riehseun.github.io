<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js"></script>
<script src="/js/bootstrap.bundle.min.js"></script>
<script src="/js/highlight.pack.js"></script>
<script type="text/javascript" src="/js/include_html.js"></script>
<script type="text/javascript" src="/js/site.js"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- Top K element BEGIN -->
<div class="card mb-4" id="top-k-element">
  <div class="card-body">
    <h2 class="card-title">Top K element</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#top-k-element-1">Kth largest element in a stream</a></li>
      <li><a href="#top-k-element-2">Reorganize string</a></li>
      <li><a href="#top-k-element-3">K closest points to origin</a></li>
      <li><a href="#top-k-element-4">Top K frequent elements</a></li>
      <li><a href="#top-k-element-5">Kth largest element in an array</a></li>
      <li><a href="#top-k-element-6">Kth smallest element in a BST</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="top-k-element-1">
  <div class="card-body">
    <h2 class="card-title">Kth largest element in a stream</h2>

    <h3 class="card-title">Use min heap</h3>
    <ul>
      <li>Initialize min_heap with just K elements from input array.</li>
      <li>As items are added, maintain K elements in min_heap</li>
    </ul>

<pre><code class="python">from heapq import heapify, heappush, heappop

class KthLargest:

    # Constructor to initialize heap and add values in it.
    # Time O(nlogn).
    # Space O(n).
    def __init__(self, k, nums):
        self.k = k
        self.min_heap = nums
        heapify(self.min_heap)
        while len(self.min_heap) > k:
            heappop(self.min_heap)
        print(self.min_heap)

    # Adds element in the heap.
    # Time O(logk).
    def add(self, val):
        heappush(self.min_heap, val)
        if len(self.min_heap) > self.k:
            heappop(self.min_heap)
        return self.return_Kth_largest()

    # Returns kth largest element from heap.
    # Time O(1).
    def return_Kth_largest(self):
        return self.min_heap[0]</code></pre>

    <h3 class="card-title">Test cases</h3>
    <ul>
      <li>K greater than length of array.</li>
      <li>Empty array and K=0.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-coding-interview-patterns-python">Grokking Coding Interview Patterns in Python</a>
  </div>
</div>

<div class="card mb-4" id="top-k-element-2">
  <div class="card-body">
    <h2 class="card-title">Reorganize string</h2>

    <h3 class="card-title">Use dictionary and max_heap</h3>
    <ul>
      <li>Store frequency of each char in a dictionary.</li>
      <li>Store each char into max_heap by the frequency.</li>
      <li>Pop out char from max_heap, decrement the frequency, and add the char to the resulting string.</li>
      <li>Do not push back the char into the max_heap in the same iteration. Push back in the next interation if the frequency is greater than 0. This is to ensure not to repeat the same char in the resulting string.</li>
      <li>Time: O(n)</li>
      <li>Space: O(1)</li>
    </ul>

<pre><code class="python">from collections import defaultdict
from heapq import heapify, heappush, heappop

def reorganize_string(input_string):

    frequency = defaultdict(str)
    max_heap = []
    result_string = ""

    for char in input_string:
        if char in frequency:
            frequency[char] += 1
        else:
            frequency[char] = 1

    for k,v in frequency.items():
        heappush(max_heap, [-v,k])

    previous = None
    # If previous still exists after max_heap is emptied out, then return empty string.
    while max_heap or previous:

        if previous and len(max_heap) == 0:
            return ""

        v, k = heappop(max_heap)
        v = -v

        # Decrement the frequency.
        v -= 1
        result_string += k

        # Idea is that char popped out in this interation must not be pushed back
        # to max_heap in this interation, but the next iteration.
        if previous:
            heappush(max_heap, previous)
            previous = None

        # "previous" should be set to most recently used char.
        if v > 0:
            previous = [-v,k]

    return result_string</code></pre>

    <h3 class="card-title">Test cases</h3>
    <ul>
      <li>String with just a single char.</li>
      <li>Empty string.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-coding-interview-patterns-python">Grokking Coding Interview Patterns in Python</a>
  </div>
</div>

<div class="card mb-4" id="top-k-element-3">
  <div class="card-body">
    <h2 class="card-title">K closest points to origin</h2>

    <h3 class="card-title">Pop/push from/to min heap one at a time</h3>
    <ul>
      <li>First, push k elements to min heap.</li>
      <li>Loop through the rest of points, if the dist is smaller than root of min heap, pop and push.</li>
      <li>Time: O(nlogk)</li>
      <li>Space: O(k)</li>
    </ul>

<pre><code class="python">import math

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def get(self):
        return (self.x, self.y)

    def get_distance(self):
        return math.sqrt(self.x ** 2 + self.y ** 2)</code></pre>

<pre><code class="python">from heapq import heappush, heappop

def k_closest(points, k):

    min_heap = []

    for i in range(k):
        heappush(min_heap, [points[i].get_distance(), points[i]])

    for j in range(k+1, len(points)):
        dist = points[j].get_distance()
        if dist < min_heap[-1][0]:
            heappop(min_heap)
            heappush(min_heap, [points[j].get_distance(), points[j]])

    result = []
    while min_heap:
        dist, point = heappop(min_heap)
        result.append(point)

    return result</code></pre>

    <h3 class="card-title">Test cases</h3>
    <ul>
      <li>K bigger than length of input array.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-coding-interview-patterns-python">Grokking Coding Interview Patterns in Python</a>
  </div>
</div>

<div class="card mb-4" id="top-k-element-4">
  <div class="card-body">
    <h2 class="card-title">Top K frequent elements</h2>

    <h3 class="card-title">Use min heap of size K</h3>
    <ul>
      <li>Create a hash table with number and its frequency mapping.</li>
      <li>Push number and frequency pair to min heap. When min heap size exceeds K, pop out the root item.</li>
      <li>Time: O(nlogk)</li>
      <li>Space: O(n+k) hash table and heap</li>
    </ul>

<pre><code class="python">from heapq import heappush, heappop
from collections import defaultdict

def top_k_frequent(arr, k):

    frequency = defaultdict(int)

    for num in arr:
        frequency[num] += 1

    min_heap = []

    for key,val in frequency.items():
        heappush(min_heap, [val, key])

        if len(min_heap) > k:
            heappop(min_heap)

    result = []
    while min_heap:
        result.append(heappop(min_heap)[1])

    return result</code></pre>

    <h3 class="card-title">Test cases</h3>
    <ul>
      <li>K bigger than length of input array.</li>
      <li>K bigger than the number of unique numbers in the input array.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-coding-interview-patterns-python">Grokking Coding Interview Patterns in Python</a>
  </div>
</div>

<div class="card mb-4" id="top-k-element-5">
  <div class="card-body">
    <h2 class="card-title">Kth largest element in an array</h2>

    <h3 class="card-title">Use min heap of size K</h3>
    <ul>
      <li>Insert first K numbers into min heap.</li>
      <li>Iterate the rest of the numbers, checking to see if they are greater than the root of min heap. If so, pop it out and insert the greater number.</li>
      <li>Time: O(nlogk)</li>
      <li>Space: O(k)</li>
    </ul>

<pre><code class="python">from heapq import heappush, heappop

def find_kth_largest(arr, k):

    min_heap = []

    for i in range(k):
        heappush(min_heap, arr[i])

    for j in range(k, len(arr)):
        if arr[j] > min_heap[0]:
            heappop(min_heap)
            heappush(min_heap, arr[j])

    return heappop(min_heap)</code></pre>

    <h3 class="card-title">Test cases</h3>
    <ul>
      <li>K bigger than length of input array.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-coding-interview-patterns-python">Grokking Coding Interview Patterns in Python</a>
  </div>
</div>

<div class="card mb-4" id="top-k-element-6">
  <div class="card-body">
    <h2 class="card-title">Kth smallest element in a BST</h2>

    <h3 class="card-title">Use min heap of size K</h3>
    <ul>
      <li>First do inorder traversal on BST.</li>
      <li>Insert first K numbers into max heap.</li>
      <li>Iterate the rest of the numbers, checking to see if they are smaller than the root of max heap. If so, pop it out and insert the smaller number.</li>
      <li>Time: O(nlogk)</li>
      <li>Space: O(k)</li>
    </ul>

<pre><code class="python">class BinaryTreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None</code></pre>

<pre><code class="python">from binary_tree_node import *
from binary_tree import *
from heapq import heappush, heappop

def kth_smallest_element(root, k):
    array = []
    in_order_traversal(root, array)

    max_heap = []

    for i in range(k):
        heappush(max_heap, -array[i])

    for j in range(k, len(array)):
        if array[j] < -max_heap[0]:
            heappop(max_heap)
            heappush(max_heap, -array[j])

    return -heappop(max_heap)


def in_order_traversal(root, array):
    array.append(root.data)

    if root.left:
        in_order_traversal(root.left, array)
    if root.right:
        in_order_traversal(root.right, array)</code></pre>

    <h3 class="card-title">Test cases</h3>
    <ul>
      <li>K bigger than length of input tree.</li>
    </ul>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://www.educative.io/courses/grokking-coding-interview-patterns-python">Grokking Coding Interview Patterns in Python</a>
  </div>
</div>
<!-- Top K element END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>