<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/bootstrap.bundle.min.js" type="text/javascript"></script>
<script src="/js/highlight.pack.js" type="text/javascript"></script>
<script src="/js/include_html.js" type="text/javascript"></script>
<script src="/js/mathjax.js" type="text/javascript"></script>
<script src="/js/site.js" type="text/javascript"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- Topological sort BEGIN -->
<div class="card mb-4" id="topological-sort">
  <div class="card-body">
    <h2 class="card-title">Topological sort</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#topological-sort-1">Compliation order</a></li>
      <li><a href="#topological-sort-2">Alien dictionary</a></li>
      <li><a href="#topological-sort-3">Verifying alien dictionary</a></li>
      <li><a href="#topological-sort-4">Find all possible recipes from given supplies</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="topological-sort-1">
  <div class="card-body">
    <h2 class="card-title">Compliation order</h2>

<pre><code class="python">from collections import defaultdict

def find_compilation_order(dependencies):

    child_nodes = [v[0] for v in dependencies]
    parent_nodes = [v[1] for v in dependencies]
    all_nodes = set(parent_nodes+child_nodes)
    child_nodes = set(child_nodes)

    graph = defaultdict(list)
    for a,b in dependencies:
        graph[b].append(a)

    ordering = []
    for node in all_nodes:
        count = dfs(graph, node)
        # If cycle.
        if count == -1:
            return []
        ordering.append([count, node])

    ordering.sort(key=lambda x:(-x[0]))

    return [v[1] for v in ordering]

def dfs(graph, start):
    explored = set()
    explored.add(start)
    count = 1

    stack = []
    stack.append(start)

    while stack:
        node = stack.pop()
        for child_node in graph[node]:
            if child_node not in explored:
                explored.add(child_node)
                stack.append(child_node)
                count += 1
            # Cycle.
            if child_node == start:
                return -1

    return count</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="topological-sort-2">
  <div class="card-body">
    <h2 class="card-title">Alien dictionary</h2>

<pre><code class="python">from collections import defaultdict, Counter, deque

def alien_order(words):

    all_chars = set()
    graph = defaultdict(set)

    for i in range(len(words)):
        for char in words[i]:
            all_chars.add(char)
        if i != len(words)-1 \
            and words[i][0] != words[i+1][0]:
            graph[words[i][0]].add(words[i+1][0])
        for j in range(i+1, len(words)):
            for k in range(1, min(len(words[i]),len(words[j]))):
                if words[i][:k] == words[j][:k] \
                    and words[i][k] != words[j][k]:
                    graph[words[i][k]].add(words[j][k])

    ordering = []
    are_all_counts_one = True
    for node in all_chars:
        count = dfs(graph, node)
        # If cycle.
        if count == -1:
            return ""
        if count != 1:
            are_all_counts_one = False
        ordering.append([count, node])

    if are_all_counts_one:
        return ""

    ordering.sort(key=lambda x:(-x[0]))

    return [v[1] for v in ordering]

def dfs(graph, start):
    explored = set()
    explored.add(start)
    count = 1

    stack = []
    stack.append(start)

    while stack:
        node = stack.pop()
        for child_node in graph[node]:
            if child_node not in explored:
                explored.add(child_node)
                stack.append(child_node)
                count += 1
            # Cycle.
            if child_node == start:
                return -1

    return count</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="topological-sort-3">
  <div class="card-body">
    <h2 class="card-title">Verifying alien dictionary</h2>

<pre><code class="python">from collections import defaultdict

def verify_alien_dictionary(words, order):

    are_all_counts_one = True
    ordering = alien_order(words)
    ordering_greater_than_one = []

    for count, node in ordering:
        if count != 1:
            are_all_counts_one = False
            ordering_greater_than_one.append(node)

    # If all counts are 1, any order works.
    if are_all_counts_one:
        return True

    print(ordering_greater_than_one)

    for char in order:
        if char in ordering_greater_than_one:
            if char == ordering_greater_than_one[0]:
                del ordering_greater_than_one[0]
            else:
                return False

    return True

def alien_order(words):

    all_chars = set()
    graph = defaultdict(set)

    for i in range(len(words)):
        for char in words[i]:
            all_chars.add(char)
        if i != len(words)-1 \
            and words[i][0] != words[i+1][0]:
            graph[words[i][0]].add(words[i+1][0])
        for j in range(i+1, len(words)):
            # if len(words[i]) == len(words[j]):
            for k in range(1, min(len(words[i]),len(words[j]))):
                if words[i][:k] == words[j][:k] \
                    and words[i][k] != words[j][k]:
                    graph[words[i][k]].add(words[j][k])

    ordering = []
    for node in all_chars:
        count = dfs(graph, node)
        # If cycle.
        if count == -1:
            return ""
        ordering.append([count, node])

    ordering.sort(key=lambda x:(-x[0]))

    return ordering

def dfs(graph, start):
    explored = set()
    explored.add(start)
    count = 1

    stack = []
    stack.append(start)

    while stack:
        node = stack.pop()
        for child_node in graph[node]:
            if child_node not in explored:
                explored.add(child_node)
                stack.append(child_node)
                count += 1
            # Cycle.
            if child_node == start:
                return -1

    return count</code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href=""></a>
  </div>
</div>

<div class="card mb-4" id="topological-sort-4">
  <div class="card-body">
    <h2 class="card-title">Find all possible recipes from given supplies</h2>

<pre><code class="python"></code></pre>
  </div>
  <div class="card-footer text-muted">
    Reference: <a href="https://leetcode.com/problems/find-all-possible-recipes-from-given-supplies/">2115. Find All Possible Recipes from Given Supplies</a>
  </div>
</div>
<!-- Topological sort END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>