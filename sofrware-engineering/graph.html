<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="Seungmoon Rieh">
<meta name="keywords" content="">

<!-- Title and image -->
<title>Seungmoon Rieh</title>
<link href="/img/seungmoonrieh.jpg" rel="icon">

<!-- CSS -->
<link href="/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/monokai-sublime.css" rel="stylesheet">
<link href="/css/site.css" rel="stylesheet">

<!-- JavaScript -->
<script src="/js/jquery.min.js"></script>
<script src="/js/bootstrap.bundle.min.js"></script>
<script src="/js/highlight.pack.js"></script>
<script type="text/javascript" src="/js/include_html.js"></script>
<script type="text/javascript" src="/js/site.js"></script>

</head>

<body>

<include src="/header.html"></include>

<div class="container">
<div class="row">
<div class="col-md-12">
<h1 class="my-4">Software Engineering</h1>

<!-- Graph BEGIN -->
<div class="card mb-4" id="graph">
  <div class="card-body">
    <h2 class="card-title">Graph</h2>
    <ul class="list-unstyled mb-0">
      <li><a href="#graph-1">Graph</a></li>
    </ul>
  </div>
</div>

<div class="card mb-4" id="graph-1">
  <div class="card-body">
    <h2 class="card-title">Graph</h2>
    <p class="card-text"></p>

    <h3 class="card-title">Representation</h3>
    <ul>
      <li>Adjacency list is space-wise more efficient than list of lists.</li>
      <li>Dictionary can be used where key is each node and value is Python Set of nodes.</li>
    </ul>

<pre><code class="python"># Convert list of lists to adjacency list. (Assume directed graph)

graph = {}

for edge in edges:

    if edge[1] not in graph:
        graph[edge[1]] = set()
        graph[edge[1]].add(edge[0])
    else:
        graph[edge[1]].add(edge[0])</code></pre>

    <h3 class="card-title">DFS</h3>
    <ul>
      <li>Explore aggressively, only backtrack when necessary.</li>
      <li>O(n+m) using stack.</li>
    </ul>

<pre><code class="python">def dfs(start_node, graph):
    stack = []
    stack.append(start_node)

    explored = {}
    explored[start_node] = True

    while stack:
        node = stack.pop()
        if node in graph:
            for next_node in graph[node]:
                if next_node not in explored:
                    explored[next_node] = True
                    stack.append(next_node)</code></pre>

    <h4 class="card-title">Detect cycle</h4>
<pre><code class="python">def is_cycle(start_node, graph):
    stack = []
    stack.append(start_node)

    explored = {}
    explored[start_node] = True

    while stack:
        node = stack.pop()
        if node in graph:
            for next_node in graph[node]:
                if next_node not in explored:
                    explored[next_node] = True
                    stack.append(next_node)
                else:
                    if next_node == start_node:
                        return True

    return False</code></pre>

    <h4 class="card-title">Topological ordering</h4>
    <ul>
      <li>Approach #1: Remove leaf nodes recursively from the graph while adding leaf nodes to result.</li>
      <li>Approach #2: Remove root nodes recursively from the graph while adding root nodes to result.</li>
      <li>Approach #3: Do DFS starting at each node counting the number of steps each starting node takes to finish DFS.</li>
      <ul>
        <li>If starting node has only small number of children or even no children, DFS will finish quickly.</li>
        <li>If starting node has lots of children, DFS will take time to finish.</li>
      </ul>
    </ul>

<pre><code class="python">def topological_order(graph, num_nodes):

    ordering = []

    for i in range(num_nodes):
        count = self.dfs(i, graph)
        # If cycle.
        if count == -1:
            return []
        ordering.append([count, i])

    ordering.sort(key=lambda x:(-x[0]))

    return [item[1] for item in ordering]

def dfs(self, start_node, graph):
    stack = []
    stack.append(start_node)
    count = 1

    explored = {}
    explored[start_node] = True

    while stack:
        node = stack.pop()
        if node in graph:
            for next_node in graph[node]:
                if next_node not in explored:
                    explored[next_node] = True
                    stack.append(next_node)
                    count += 1
                else:
                    if next_node == start_node:
                        return -1

    return count</code></pre>

    <h4 class="card-title">Strongly connected components</h4>
    <ul>
      <li>There exist path u to v and v to u in graph G.</li>
      <li>Kosaraju's two pass algorithm</li>
      <ul>
        <li>Compute SCC in O(m+n).</li>
        <li>Let G' = G with all arcs reversed.</li>
        <li>Run DFS_loop on G' (compute magical ordering of nodes)</li>
        <li>Run DFS_loop on G (compute strongly connected component one by one)</li>
      </ul>
    </ul>

<pre><code class="python"># DFS_loop(graph G)
#     global variable t=0 # number of nodes processed so far
#     global variable s=null # current source vertex
#     assumes nodes labelled 1 to n
#     for i = n to 1
#         if i not explored
#             s = i
#             DFS(G, i)

# DFS(graph G, node i)
#     mark i as explored
#     set leader(i) = node s
#     for each arc (i,j) in G
#         if j not explored
#             DFS(G, j)
#     t++
#     set f(i) = t # ith finishing time</code></pre>

    <h3 class="card-title">BFS</h3>
    <ul>
      <li>Explore ndoes in "layers".</li>
      <li>O(n+m) using queue.</li>
    </ul>

<pre><code class="python">from collections import deque

def bfs(start_node, graph):
    queue = deque()
    queue.append(start_node)

    explored = {}
    explored[start_node] = True

    while queue:
        node = queue.popleft()
        if node in graph:
            for next_node in graph[node]:
                if next_node not in explored:
                    explored[next_node] = True
                    queue.append(next_node)</code></pre>

    <h4 class="card-title">Shortest path</h4>
    <ul>
      <li>Compute dist(v), the fewest number of edges on path from s to v.</li>
      <li>Assumption: every edge has length of 1.</li>
      <li>Extra code to BFS.</li>
    </ul>

<pre><code class="python"># initialize dist(v): 0 if v=s, large number if v != s
# when considering edge (v,w)
#   if w unexplored, then set dist(w) = dist(v) + 1</code></pre>

    <h4 class="card-title">Undirected connectivity</h4>
    <ul>
      <li>Let G(V,E) undirected graph.</li>
      <li>Connected component = pieces of G.</li>
      <li>Compute all connected components.</li>
    </ul>

<pre><code class="python">explored = {}

for i in range(num_nodes):
    if i not in explored:
        bfs(i, graph, explored)</code></pre>

<pre><code class="python">def bfs(start_node, graph, explored):
    queue = deque()
    queue.append(start_node)

    explored[start_node] = True

    while queue:
        node = queue.popleft()
        if node in graph:
            for next_node in graph[node]:
                if next_node not in explored:
                    explored[next_node] = True
                    queue.append(next_node)</code></pre>

  </div>
  <div class="card-footer text-muted">

  </div>
</div>
<!-- Graph END -->

</div> <!-- /.col-md-12 -->
</div> <!-- /.row -->
</div> <!-- /.container -->

<include src="/footer.html"></include>

</body>

</html>